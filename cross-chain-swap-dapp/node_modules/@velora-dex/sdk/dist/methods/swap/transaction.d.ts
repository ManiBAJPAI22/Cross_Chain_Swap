import type { WithGasPrice, WithMaxFee } from '../../gas';
import type { ConstructFetchInput, Address, PriceString, OptimalRate, RequestParameters } from '../../types';
import type { OrderData } from '../limitOrders/buildOrder';
import { AssetTypeVariant } from '../nftOrders/helpers/types';
export interface TransactionParams {
    to: string;
    from: string;
    value: string;
    data: string;
    gas?: string;
    chainId: number;
    gasPrice?: string;
    maxFeePerGas?: string;
    maxPriorityFeePerGas?: string;
}
export type SwappableOrder = OrderData & {
    permitMakerAsset?: string;
    signature: string;
};
export type SwappableNFTOrder = SwappableOrder & {
    makerAssetId: string;
    takerAssetId: string;
    makerAssetType: AssetTypeVariant;
    takerAssetType: AssetTypeVariant;
};
export type TxInputAmountsPartSell = {
    slippage: number;
    srcAmount: PriceString;
    destAmount?: never;
};
export type TxInputAmountsPartBuy = {
    slippage: number;
    srcAmount?: never;
    destAmount: PriceString;
};
export type TxInputAmountsPartBuyOrSell = {
    slippage?: never;
    srcAmount: PriceString;
    destAmount: PriceString;
};
export type BuildTxInputBase = {
    srcToken: Address;
    destToken: Address;
    userAddress: Address;
    /** @description Whenever msg.sender (`userAddress`) i.e. address calling the Velora contract is different than the address sending the transaction, `txOrigin` must be passed along with `userAddress` */
    txOrigin?: string;
    /** @description used with referral link */
    referrer?: string;
    partner?: string;
    partnerAddress?: string;
    partnerFeeBps?: number;
    /** @description If user should receive surplus instead of partner. Default: false */
    isSurplusToUser?: boolean;
    /** @description If fees should be sent directly to the partner instead of registering them on FeeClaimer. v6 only. Default: false */
    isDirectFeeTransfer?: boolean;
    /** @deprecated Use "takeSurplus" instead. Positive slippage goes to user, true by default */
    positiveSlippageToUser?: boolean;
    /** @description Set to true to take positive slippage. Works with partnerAddress. Default: false */
    takeSurplus?: boolean;
    /** @description Cap the surplus at 1% maximum. Default: true */
    isCapSurplus?: boolean;
    receiver?: Address;
    srcDecimals?: number;
    destDecimals?: number;
    permit?: string;
    deadline?: string;
};
export type BuildSwapTxInput = BuildTxInputBase & {
    priceRoute: OptimalRate;
} & (TxInputAmountsPartSell | TxInputAmountsPartBuy | TxInputAmountsPartBuyOrSell);
type BuildTxInputBaseBUYForOrders<K extends keyof TxInputAmountsPartBuy | keyof BuildTxInputBase = never> = Omit<BuildTxInputBase, K> & (Omit<TxInputAmountsPartBuy, 'destAmount' | K> | Omit<TxInputAmountsPartBuyOrSell, 'destAmount' | K>);
export type BuildLimitOrderTxInput = BuildTxInputBaseBUYForOrders & {
    orders: SwappableOrder[];
    srcDecimals: number;
    destDecimals: number;
};
export type BuildNFTOrderTxInput = BuildTxInputBaseBUYForOrders<'destDecimals'> & {
    orders: SwappableNFTOrder[];
    srcDecimals: number;
};
export interface BuildSwapAndLimitOrderTxInput0 extends Omit<BuildTxInputBase, 'destAmount'> {
    priceRoute: OptimalRate;
    orders: SwappableOrder[];
    destDecimals: number;
}
export type BuildSwapAndLimitOrderTxInput = BuildTxInputBaseBUYForOrders & {
    priceRoute: OptimalRate;
    orders: SwappableOrder[];
    destDecimals: number;
};
export type BuildSwapAndNFTOrderTxInput = BuildTxInputBaseBUYForOrders & {
    priceRoute: OptimalRate;
    orders: SwappableNFTOrder[];
};
export type BuildTxInput = BuildSwapTxInput | BuildLimitOrderTxInput | BuildNFTOrderTxInput | BuildSwapAndLimitOrderTxInput | BuildSwapAndNFTOrderTxInput;
export type BuildOptionsBase = {
    /** @description Allows the API to skip performing onchain checks such as balances, allowances, as well as transaction simulations. The response does not contain `gas` parameter when set to `true` */
    ignoreChecks?: boolean;
    /** @description Allows the API to skip gas checks. The response does not contain `gas` parameter when set to `true` */
    ignoreGasEstimate?: boolean;
    /** @description Allows the API to skip performing onchain allowance checks. */
    ignoreAllowance?: boolean;
    /** @description Allows the API to return the contract parameters only. */
    onlyParams?: boolean;
};
export type BuildOptionsWithGasPrice = BuildOptionsBase & Partial<WithGasPrice>;
export type BuildOptionsWitWithMaxFee = BuildOptionsBase & Partial<WithMaxFee>;
export type BuildOptions = BuildOptionsWithGasPrice | BuildOptionsWitWithMaxFee;
type BuildTx = (params: BuildTxInput, options?: BuildOptions, requestParams?: RequestParameters) => Promise<TransactionParams>;
export type BuildTxFunctions = {
    buildTx: BuildTx;
};
export declare const constructBuildTx: ({ apiURL, chainId, fetcher, }: ConstructFetchInput) => BuildTxFunctions;
export {};
//# sourceMappingURL=transaction.d.ts.map