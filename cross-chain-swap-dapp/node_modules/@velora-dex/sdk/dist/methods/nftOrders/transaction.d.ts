import type { ConstructFetchInput, OptimalRate } from '../../types';
import { BuildNFTOrderTxInput, BuildOptions, BuildSwapAndNFTOrderTxInput, TransactionParams } from '../swap/transaction';
import { GetRateInput } from '../swap/rates';
import type { NFTOrderData } from './buildOrder';
import type { RequestParameters } from '../../types';
type MinBuildSwapAndNFTOrderTxInput = Omit<BuildSwapAndNFTOrderTxInput, 'srcToken' | 'srcAmount' | 'destToken' | 'destDecimals'>;
type BuildSwapAndNFTOrdersTx = (params: MinBuildSwapAndNFTOrderTxInput, options?: BuildOptions, requestParams?: RequestParameters) => Promise<TransactionParams>;
type MinBuildNFTOrderTxInput = Omit<BuildNFTOrderTxInput, 'srcToken' | 'srcAmount' | 'destToken' | 'slippage'>;
type BuildNFTOrdersTx = (params: MinBuildNFTOrderTxInput, options?: BuildOptions, requestParams?: RequestParameters) => Promise<TransactionParams>;
export type BuildNFTOrdersTxFunctions = {
    getNFTOrdersRate: GetNFTOrdersRate;
    buildNFTOrderTx: BuildNFTOrdersTx;
    buildSwapAndNFTOrderTx: BuildSwapAndNFTOrdersTx;
};
type GetNFTOrdersRate = (options: Omit<GetRateInput, 'amount' | 'side'> & {
    amount?: string;
}, orders: CheckableOrderData[], requestParams?: RequestParameters) => Promise<OptimalRate>;
export declare const constructBuildNFTOrderTx: ({ apiURL, version, chainId, fetcher, }: ConstructFetchInput) => BuildNFTOrdersTxFunctions;
type CheckableOrderData = Pick<NFTOrderData, 'takerAsset' | 'makerAsset' | 'takerAmount' | 'maker'> & {
    taker?: NFTOrderData['taker'];
};
export {};
//# sourceMappingURL=transaction.d.ts.map