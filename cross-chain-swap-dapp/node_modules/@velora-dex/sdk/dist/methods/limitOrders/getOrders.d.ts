import type { Address, ConstructFetchInput, RequestParameters } from '../../types';
import type { LimitOrderFromApi, LimitOrdersApiResponse, LimitOrderType } from './helpers/types';
type PaginationParams = {
    limit?: number;
    offset?: number;
    hideSmallBalances?: boolean;
    orderBy?: 'createdAt' | 'updatedAt' | 'expiry';
};
export type LimitOrdersUserParams = ({
    maker: Address;
    type: LimitOrderType;
} | {
    taker: Address;
    type: LimitOrderType;
}) & PaginationParams;
export type GetRequiredAllowanceParams = {
    maker: Address;
    token?: Address;
};
type GetLimitOrderByHash = (orderHash: string, requestParams?: RequestParameters) => Promise<LimitOrderFromApi>;
type GetLimitOrders = (userParams: LimitOrdersUserParams, requestParams?: RequestParameters) => Promise<LimitOrdersApiResponse>;
type GetRequiredBalance = (userParams: GetRequiredAllowanceParams, requestParams?: RequestParameters) => Promise<Record<string, string>>;
export type GetLimitOrdersFunctions = {
    getLimitOrders: GetLimitOrders;
    getLimitOrderByHash: GetLimitOrderByHash;
    /**
     * Gets fillableBalance for tokens from user's active orders.
     * User needs to have enough balance & allowance to cover active orders before creating new orders.
     * @param userParams - parameters to get allowance for active orders
     * @param {string} userParams.maker - user to get required allowances for
     * @param {string=} userParams.token - if given `token`, the mapping will contain that token address only
     * @param {RequestParameters=} requestParams - requestParams passed to fetcher, can include {signal: AbortSignal, timeout: for axios, etc.}
     * @returns `{Lowercase<Address> => wei number as string}` mapping of token to fillableBalance
     */
    getRequiredBalance: GetRequiredBalance;
};
export declare const constructGetLimitOrders: ({ apiURL, chainId, fetcher, }: ConstructFetchInput) => GetLimitOrdersFunctions;
export {};
//# sourceMappingURL=getOrders.d.ts.map