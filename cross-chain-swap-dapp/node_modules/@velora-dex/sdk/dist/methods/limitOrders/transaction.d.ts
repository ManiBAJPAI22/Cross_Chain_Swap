import type { ConstructFetchInput, OptimalRate } from '../../types';
import { BuildLimitOrderTxInput, BuildOptions, BuildSwapAndLimitOrderTxInput, TransactionParams } from '../swap/transaction';
import { GetRateInput } from '../swap/rates';
import type { OrderData } from './buildOrder';
import type { RequestParameters } from '../../types';
type MinBuildSwapAndLimitOrderTxInput = Omit<BuildSwapAndLimitOrderTxInput, 'srcToken' | 'srcAmount' | 'destToken' | 'destDecimals'>;
type BuildSwapAndLimitOrdersTx = (params: MinBuildSwapAndLimitOrderTxInput, options?: BuildOptions, requestParams?: RequestParameters) => Promise<TransactionParams>;
type MinBuildLimitOrderTxInput = Omit<BuildLimitOrderTxInput, 'srcToken' | 'srcAmount' | 'destToken' | 'slippage'>;
type BuildLimitOrdersTx = (params: MinBuildLimitOrderTxInput, options?: BuildOptions, requestParams?: RequestParameters) => Promise<TransactionParams>;
export type BuildLimitOrdersTxFunctions = {
    getLimitOrdersRate: GetLimitOrdersRate;
    buildLimitOrderTx: BuildLimitOrdersTx;
    buildSwapAndLimitOrderTx: BuildSwapAndLimitOrdersTx;
};
type GetLimitOrdersRate = (options: Omit<GetRateInput, 'amount' | 'side'> & {
    amount?: string;
}, orders: CheckableOrderData[], requestParams?: RequestParameters) => Promise<OptimalRate>;
export declare const constructBuildLimitOrderTx: ({ apiURL, version, chainId, fetcher, }: ConstructFetchInput) => BuildLimitOrdersTxFunctions;
type CheckableOrderData = Pick<OrderData, 'takerAsset' | 'makerAsset' | 'takerAmount' | 'maker'> & {
    taker?: OrderData['taker'];
};
export {};
//# sourceMappingURL=transaction.d.ts.map