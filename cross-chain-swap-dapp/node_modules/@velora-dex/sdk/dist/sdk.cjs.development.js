'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var core = require('@paraswap/core');
var tsEssentials = require('ts-essentials');

function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function asyncGeneratorStep(n, t, e, r, o, a, c) {
  try {
    var i = n[a](c),
      u = i.value;
  } catch (n) {
    return void e(n);
  }
  i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
  return function () {
    var t = this,
      e = arguments;
    return new Promise(function (r, o) {
      var a = n.apply(t, e);
      function _next(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
      }
      function _throw(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
      }
      _next(void 0);
    });
  };
}
function _construct(t, e, r) {
  if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
  var o = [null];
  o.push.apply(o, e);
  var p = new (t.bind.apply(t, o))();
  return r && _setPrototypeOf(p, r.prototype), p;
}
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function (n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}
function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, _getPrototypeOf(t);
}
function _inheritsLoose(t, o) {
  t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o);
}
function _isNativeFunction(t) {
  try {
    return -1 !== Function.toString.call(t).indexOf("[native code]");
  } catch (n) {
    return "function" == typeof t;
  }
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function () {
    return !!t;
  })();
}
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.includes(n)) continue;
    t[n] = r[n];
  }
  return t;
}
function _regeneratorRuntime() {
  _regeneratorRuntime = function () {
    return e;
  };
  var t,
    e = {},
    r = Object.prototype,
    n = r.hasOwnProperty,
    o = Object.defineProperty || function (t, e, r) {
      t[e] = r.value;
    },
    i = "function" == typeof Symbol ? Symbol : {},
    a = i.iterator || "@@iterator",
    c = i.asyncIterator || "@@asyncIterator",
    u = i.toStringTag || "@@toStringTag";
  function define(t, e, r) {
    return Object.defineProperty(t, e, {
      value: r,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), t[e];
  }
  try {
    define({}, "");
  } catch (t) {
    define = function (t, e, r) {
      return t[e] = r;
    };
  }
  function wrap(t, e, r, n) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype),
      c = new Context(n || []);
    return o(a, "_invoke", {
      value: makeInvokeMethod(t, r, c)
    }), a;
  }
  function tryCatch(t, e, r) {
    try {
      return {
        type: "normal",
        arg: t.call(e, r)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart",
    l = "suspendedYield",
    f = "executing",
    s = "completed",
    y = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var p = {};
  define(p, a, function () {
    return this;
  });
  var d = Object.getPrototypeOf,
    v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t) {
    ["next", "throw", "return"].forEach(function (e) {
      define(t, e, function (t) {
        return this._invoke(e, t);
      });
    });
  }
  function AsyncIterator(t, e) {
    function invoke(r, o, i, a) {
      var c = tryCatch(t[r], t, o);
      if ("throw" !== c.type) {
        var u = c.arg,
          h = u.value;
        return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
          invoke("next", t, i, a);
        }, function (t) {
          invoke("throw", t, i, a);
        }) : e.resolve(h).then(function (t) {
          u.value = t, i(u);
        }, function (t) {
          return invoke("throw", t, i, a);
        });
      }
      a(c.arg);
    }
    var r;
    o(this, "_invoke", {
      value: function (t, n) {
        function callInvokeWithMethodAndArg() {
          return new e(function (e, r) {
            invoke(t, n, e, r);
          });
        }
        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e, r, n) {
    var o = h;
    return function (i, a) {
      if (o === f) throw Error("Generator is already running");
      if (o === s) {
        if ("throw" === i) throw a;
        return {
          value: t,
          done: !0
        };
      }
      for (n.method = i, n.arg = a;;) {
        var c = n.delegate;
        if (c) {
          var u = maybeInvokeDelegate(c, n);
          if (u) {
            if (u === y) continue;
            return u;
          }
        }
        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
          if (o === h) throw o = s, n.arg;
          n.dispatchException(n.arg);
        } else "return" === n.method && n.abrupt("return", n.arg);
        o = f;
        var p = tryCatch(e, r, n);
        if ("normal" === p.type) {
          if (o = n.done ? s : l, p.arg === y) continue;
          return {
            value: p.arg,
            done: n.done
          };
        }
        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
      }
    };
  }
  function maybeInvokeDelegate(e, r) {
    var n = r.method,
      o = e.iterator[n];
    if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
    var i = tryCatch(o, e.iterator, r.arg);
    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
    var a = i.arg;
    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
  }
  function pushTryEntry(t) {
    var e = {
      tryLoc: t[0]
    };
    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
  }
  function resetTryEntry(t) {
    var e = t.completion || {};
    e.type = "normal", delete e.arg, t.completion = e;
  }
  function Context(t) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(e) {
    if (e || "" === e) {
      var r = e[a];
      if (r) return r.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) {
        var o = -1,
          i = function next() {
            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
            return next.value = t, next.done = !0, next;
          };
        return i.next = i;
      }
    }
    throw new TypeError(typeof e + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
    var e = "function" == typeof t && t.constructor;
    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
  }, e.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
  }, e.awrap = function (t) {
    return {
      __await: t
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(wrap(t, r, n, o), i);
    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
    return this;
  }), define(g, "toString", function () {
    return "[object Generator]";
  }), e.keys = function (t) {
    var e = Object(t),
      r = [];
    for (var n in e) r.push(n);
    return r.reverse(), function next() {
      for (; r.length;) {
        var t = r.pop();
        if (t in e) return next.value = t, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function (e) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
    },
    stop: function () {
      this.done = !0;
      var t = this.tryEntries[0].completion;
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function (e) {
      if (this.done) throw e;
      var r = this;
      function handle(n, o) {
        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
      }
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i.completion;
        if ("root" === i.tryLoc) return handle("end");
        if (i.tryLoc <= this.prev) {
          var c = n.call(i, "catchLoc"),
            u = n.call(i, "finallyLoc");
          if (c && u) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          } else if (c) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
          } else {
            if (!u) throw Error("try statement without catch or finally");
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function (t, e) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var o = this.tryEntries[r];
        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
          var i = o;
          break;
        }
      }
      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
      var a = i ? i.completion : {};
      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
    },
    complete: function (t, e) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
    },
    finish: function (t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
      }
    },
    catch: function (t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.tryLoc === t) {
          var n = r.completion;
          if ("throw" === n.type) {
            var o = n.arg;
            resetTryEntry(r);
          }
          return o;
        }
      }
      throw Error("illegal catch attempt");
    },
    delegateYield: function (e, r, n) {
      return this.delegate = {
        iterator: values(e),
        resultName: r,
        nextLoc: n
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
    return t.__proto__ = e, t;
  }, _setPrototypeOf(t, e);
}
function _wrapNativeSuper(t) {
  var r = "function" == typeof Map ? new Map() : void 0;
  return _wrapNativeSuper = function (t) {
    if (null === t || !_isNativeFunction(t)) return t;
    if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
    if (void 0 !== r) {
      if (r.has(t)) return r.get(t);
      r.set(t, Wrapper);
    }
    function Wrapper() {
      return _construct(t, arguments, _getPrototypeOf(this).constructor);
    }
    return Wrapper.prototype = Object.create(t.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), _setPrototypeOf(Wrapper, t);
  }, _wrapNativeSuper(t);
}

var API_URL = 'https://api.paraswap.io';
var DEFAULT_VERSION = '6.2';

var objectToFilledEntries = function objectToFilledEntries(object) {
  return Object.entries(object)
  // removes keys with undefined values
  .filter(function (_ref) {
    var value = _ref[1];
    return value !== undefined;
  }).map(function (_ref2) {
    var key = _ref2[0],
      value = _ref2[1];
    return [key, String(value)];
  });
};
var constructSearchString = function constructSearchString(queryOptions) {
  var queryEntries = objectToFilledEntries(queryOptions);
  var queryString = new URLSearchParams(queryEntries).toString();
  // returns empty string or `?${string}`
  return queryString && "?" + queryString;
};
var isFetcherError = function isFetcherError(error) {
  return error instanceof FetcherError;
};
var FetcherError = /*#__PURE__*/function (_Error) {
  function FetcherError(_ref3) {
    var _this;
    var code = _ref3.code,
      request = _ref3.request,
      response = _ref3.response,
      isAxiosError = _ref3.isAxiosError,
      message = _ref3.message;
    _this = _Error.call(this) || this;
    // Maintains proper stack trace for where our error was thrown (only available on V8)
    _this.code = void 0;
    _this.status = void 0;
    _this.request = void 0;
    _this.response = void 0;
    _this.isAxiosError = false;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(_this, FetcherError);
    }
    _this.name = _this.constructor.name;
    _this.code = code;
    _this.request = request;
    _this.isAxiosError = isAxiosError;
    // no response on AxiosError
    if (!response) {
      _this.message = message;
      return _assertThisInitialized(_this);
    }
    _this.response = response;
    var data = response.data,
      status = response.status;
    _this.status = status;
    _this.message = isDataWithError(data) ? data.error : message;
    _this.message = isDataWithError2(data) ? "" + data.errorType + (data.description ? ": " + data.description : '') : _this.message;
    return _this;
  }
  _inheritsLoose(FetcherError, _Error);
  return FetcherError;
}(/*#__PURE__*/_wrapNativeSuper(Error));
// to turn `object -> Record` for indexed variable access
function isObject(obj) {
  return !!obj && typeof obj === 'object';
}
function isDataWithError(data) {
  return isObject(data) && typeof data['error'] === 'string';
}
function isDataWithError2(data) {
  return isObject(data) && typeof data['errorType'] === 'string';
}
// checks that array has at least one element
var isFilledArray = function isFilledArray(array) {
  return array.length > 0;
};
function getRandomInt() {
  return Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
}
function runOnceAndCache(
// can pass `(...any[]) => any but null | undefined`
func) {
  var result;
  return function () {
    var _result;
    return (_result = result) != null ? _result : result = func.apply(void 0, arguments);
  };
}

var constructGetSpender = function constructGetSpender(_ref) {
  var _ref$apiURL = _ref.apiURL,
    apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL,
    _ref$version = _ref.version,
    version = _ref$version === void 0 ? DEFAULT_VERSION : _ref$version,
    chainId = _ref.chainId,
    fetcher = _ref.fetcher;
  var search = constructSearchString({
    network: chainId,
    version: version
  });
  var fetchURL = apiURL + "/adapters/contracts" + search;
  var _getContracts = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(requestParams) {
      var data;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return fetcher({
              url: fetchURL,
              method: 'GET',
              requestParams: requestParams
            });
          case 2:
            data = _context.sent;
            return _context.abrupt("return", data);
          case 4:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function _getContracts(_x) {
      return _ref2.apply(this, arguments);
    };
  }();
  // cached for the same instance of `{getContracts, getSpender, getAugustusSwapper, getAugustusRFQ} = constructGetSpender()`
  // so should persist across same apiUrl & network
  var getContracts = runOnceAndCache(_getContracts);
  var getSpender = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(requestParams) {
      var _yield$getContracts, TokenTransferProxy;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return getContracts(requestParams);
          case 2:
            _yield$getContracts = _context2.sent;
            TokenTransferProxy = _yield$getContracts.TokenTransferProxy;
            return _context2.abrupt("return", TokenTransferProxy);
          case 5:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return function getSpender(_x2) {
      return _ref3.apply(this, arguments);
    };
  }();
  var getAugustusSwapper = /*#__PURE__*/function () {
    var _ref4 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(requestParams) {
      var _yield$getContracts2, AugustusSwapper;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return getContracts(requestParams);
          case 2:
            _yield$getContracts2 = _context3.sent;
            AugustusSwapper = _yield$getContracts2.AugustusSwapper;
            return _context3.abrupt("return", AugustusSwapper);
          case 5:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    return function getAugustusSwapper(_x3) {
      return _ref4.apply(this, arguments);
    };
  }();
  var getAugustusRFQ = /*#__PURE__*/function () {
    var _ref5 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(requestParams) {
      var _yield$getContracts3, AugustusRFQ;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return getContracts(requestParams);
          case 2:
            _yield$getContracts3 = _context4.sent;
            AugustusRFQ = _yield$getContracts3.AugustusRFQ;
            return _context4.abrupt("return", AugustusRFQ);
          case 5:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }));
    return function getAugustusRFQ(_x4) {
      return _ref5.apply(this, arguments);
    };
  }();
  return {
    getContracts: getContracts,
    getSpender: getSpender,
    getAugustusSwapper: getAugustusSwapper,
    getAugustusRFQ: getAugustusRFQ
  };
};

// much smaller than the whole ERC20_ABI
var MinERC20Abi = [{
  constant: false,
  inputs: [{
    name: '_spender',
    type: 'address'
  }, {
    name: '_value',
    type: 'uint256'
  }],
  name: 'approve',
  outputs: [{
    name: '',
    type: 'bool'
  }],
  payable: false,
  stateMutability: 'nonpayable',
  type: 'function'
}];
function approveTokenMethodFactory(contractCaller, getSpender) {
  return /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(amount, tokenAddress, overrides, requestParams) {
      var spender, res;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (overrides === void 0) {
              overrides = {};
            }
            _context.next = 3;
            return getSpender(requestParams);
          case 3:
            spender = _context.sent;
            _context.next = 6;
            return contractCaller.transactCall({
              address: tokenAddress,
              abi: MinERC20Abi,
              contractMethod: 'approve',
              args: [spender, amount],
              overrides: overrides
            });
          case 6:
            res = _context.sent;
            return _context.abrupt("return", res);
          case 8:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function (_x, _x2, _x3, _x4) {
      return _ref.apply(this, arguments);
    };
  }();
}

// returns whatever `contractCaller` returns
// to allow for better versatility
var constructApproveToken = function constructApproveToken(options) {
  // getSpender is cached internally for the same instance of SDK
  // so should persist across same apiUrl & network
  var _constructGetSpender = constructGetSpender(options),
    getSpender = _constructGetSpender.getSpender;
  var approveToken = approveTokenMethodFactory(options.contractCaller, getSpender);
  var approveTokenBulk = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(amount, tokenAddresses, overrides, requestParams) {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", Promise.all(tokenAddresses.map(function (tokenAddress) {
              return approveToken(amount, tokenAddress, overrides, requestParams);
            })));
          case 1:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function approveTokenBulk(_x, _x2, _x3, _x4) {
      return _ref.apply(this, arguments);
    };
  }();
  return {
    approveToken: approveToken,
    approveTokenBulk: approveTokenBulk
  };
};

var _excluded$a = ["tokenType", "mainConnector", "connectors", "network"];
var constructToken = function constructToken(tokenProps) {
  var _tokenProps$tokenType = tokenProps.tokenType,
    tokenType = _tokenProps$tokenType === void 0 ? 'ERC20' : _tokenProps$tokenType,
    _tokenProps$mainConne = tokenProps.mainConnector,
    mainConnector = _tokenProps$mainConne === void 0 ? 'ETH' : _tokenProps$mainConne,
    _tokenProps$connector = tokenProps.connectors,
    connectorsInput = _tokenProps$connector === void 0 ? [] : _tokenProps$connector,
    _tokenProps$network = tokenProps.network,
    network = _tokenProps$network === void 0 ? 1 : _tokenProps$network,
    rest = _objectWithoutPropertiesLoose(tokenProps, _excluded$a);
  var connectors = connectorsInput.length > 0 ? connectorsInput : [mainConnector];
  return _extends({
    tokenType: tokenType,
    connectors: connectors,
    mainConnector: mainConnector,
    network: network
  }, rest);
};

var isAllowance = function isAllowance(arg) {
  return 'allowance' in arg;
};
var NOT_FOUND_RESPONSE = {
  message: 'Not Found'
};
var constructGetBalances = function constructGetBalances(_ref) {
  var _ref$apiURL = _ref.apiURL,
    apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL,
    chainId = _ref.chainId,
    fetcher = _ref.fetcher;
  var tokensUrl = apiURL + "/users/tokens/" + chainId;
  var getBalances = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(userAddress, requestParams) {
      var fetchURL, data, tokens;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            fetchURL = tokensUrl + "/" + userAddress;
            _context.next = 3;
            return fetcher({
              url: fetchURL,
              method: 'GET',
              requestParams: requestParams
            });
          case 3:
            data = _context.sent;
            tokens = data.tokens.map(constructToken);
            return _context.abrupt("return", tokens);
          case 6:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function getBalances(_x, _x2) {
      return _ref2.apply(this, arguments);
    };
  }();
  var getBalance = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(userAddress, tokenAddressOrSymbol, requestParams) {
      var fetchURL, data;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            fetchURL = tokensUrl + "/" + userAddress + "/" + tokenAddressOrSymbol;
            _context2.next = 3;
            return fetcher({
              url: fetchURL,
              method: 'GET',
              requestParams: requestParams
            });
          case 3:
            data = _context2.sent;
            if (data.token) {
              _context2.next = 6;
              break;
            }
            return _context2.abrupt("return", NOT_FOUND_RESPONSE);
          case 6:
            return _context2.abrupt("return", constructToken(data.token));
          case 7:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return function getBalance(_x3, _x4, _x5) {
      return _ref3.apply(this, arguments);
    };
  }();
  var getAllowances = /*#__PURE__*/function () {
    var _ref4 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(userAddress, tokenAddresses, requestParams) {
      var tokenAddressesLowercaseSet, balances, allowances;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            tokenAddressesLowercaseSet = new Set(tokenAddresses.map(function (address) {
              return address.toLowerCase();
            }));
            _context3.next = 3;
            return getBalances(userAddress, requestParams);
          case 3:
            balances = _context3.sent;
            allowances = balances.filter(function (token) {
              return tokenAddressesLowercaseSet.has(token.address.toLowerCase());
            }).map(function (_ref5) {
              var address = _ref5.address,
                _ref5$allowance = _ref5.allowance,
                allowance = _ref5$allowance === void 0 ? '0' : _ref5$allowance;
              return {
                tokenAddress: address,
                allowance: allowance
              };
            });
            return _context3.abrupt("return", allowances);
          case 6:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    return function getAllowances(_x6, _x7, _x8) {
      return _ref4.apply(this, arguments);
    };
  }();
  var getAllowance = /*#__PURE__*/function () {
    var _ref6 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(userAddress, tokenAddress, requestParams) {
      var balanceOrNotFound, address, _balanceOrNotFound$al, allowance;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return getBalance(userAddress, tokenAddress, requestParams);
          case 2:
            balanceOrNotFound = _context4.sent;
            if (!('message' in balanceOrNotFound)) {
              _context4.next = 5;
              break;
            }
            return _context4.abrupt("return", balanceOrNotFound);
          case 5:
            address = balanceOrNotFound.address, _balanceOrNotFound$al = balanceOrNotFound.allowance, allowance = _balanceOrNotFound$al === void 0 ? '0' : _balanceOrNotFound$al;
            return _context4.abrupt("return", {
              tokenAddress: address,
              allowance: allowance
            });
          case 7:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }));
    return function getAllowance(_x9, _x10, _x11) {
      return _ref6.apply(this, arguments);
    };
  }();
  return {
    getBalance: getBalance,
    getBalances: getBalances,
    getAllowance: getAllowance,
    getAllowances: getAllowances
  };
};

var constructGetAdapters = function constructGetAdapters(_ref) {
  var _ref$apiURL = _ref.apiURL,
    apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL,
    _ref$version = _ref.version,
    version = _ref$version === void 0 ? DEFAULT_VERSION : _ref$version,
    chainId = _ref.chainId,
    fetcher = _ref.fetcher;
  var getAdapters = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(requestParams) {
      var query, fetchURL, data;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            // always pass explicit type to make sure UrlSearchParams are correct
            query = constructSearchString({
              network: chainId,
              version: version
            });
            fetchURL = apiURL + "/adapters/list" + query;
            _context.next = 4;
            return fetcher({
              url: fetchURL,
              method: 'GET',
              requestParams: requestParams
            });
          case 4:
            data = _context.sent;
            return _context.abrupt("return", data);
          case 6:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function getAdapters(_x) {
      return _ref2.apply(this, arguments);
    };
  }();
  return {
    getAdapters: getAdapters
  };
};

var _excluded$9 = ["options"],
  _excluded2$4 = ["excludeContractMethods", "includeContractMethods", "partner", "includeDEXS", "excludeDEXS", "excludePools"];
function normalizeRateOptions(_ref) {
  var _ref$options = _ref.options,
    options = _ref$options === void 0 ? {} : _ref$options,
    restInput = _objectWithoutPropertiesLoose(_ref, _excluded$9);
  var excludeContractMethods = options.excludeContractMethods,
    includeContractMethods = options.includeContractMethods,
    partner = options.partner,
    includeDEXS = options.includeDEXS,
    excludeDEXS = options.excludeDEXS,
    excludePools = options.excludePools,
    restOptions = _objectWithoutPropertiesLoose(options, _excluded2$4);
  var _map = [includeDEXS, excludeDEXS, excludePools, excludeContractMethods, includeContractMethods
    //                                                                                              no "" empty string
    ].map(function (array) {
      return (array == null ? void 0 : array.join(',')) || undefined;
    }),
    _includeDEXS = _map[0],
    _excludeDEXS = _map[1],
    _excludePools = _map[2],
    _excludeContractMethods = _map[3],
    _includeContractMethods = _map[4];
  var transformed = {
    excludeContractMethods: _excludeContractMethods,
    includeContractMethods: _includeContractMethods,
    partner: partner,
    includeDEXS: _includeDEXS,
    excludeDEXS: _excludeDEXS,
    excludePools: _excludePools
  };
  return _extends({}, transformed, restOptions, restInput);
}

var _excluded$8 = ["srcToken", "destToken"],
  _excluded2$3 = ["route"];
var INVALID_ROUTE = 'Invalid Route';
var constructGetRate = function constructGetRate(_ref) {
  var _ref$apiURL = _ref.apiURL,
    apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL,
    _ref$version = _ref.version,
    version = _ref$version === void 0 ? DEFAULT_VERSION : _ref$version,
    chainId = _ref.chainId,
    fetcher = _ref.fetcher;
  var pricesUrl = apiURL + "/prices";
  var getRate = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref2, requestParams) {
      var srcToken, destToken, rest, parsedOptions, search, fetchURL, data;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            srcToken = _ref2.srcToken, destToken = _ref2.destToken, rest = _objectWithoutPropertiesLoose(_ref2, _excluded$8);
            parsedOptions = normalizeRateOptions(rest); // always pass explicit type to make sure UrlSearchParams are correct
            search = constructSearchString(_extends({
              srcToken: srcToken,
              destToken: destToken,
              network: chainId,
              version: version
            }, parsedOptions));
            fetchURL = pricesUrl + "/" + search;
            _context.next = 6;
            return fetcher({
              url: fetchURL,
              method: 'GET',
              requestParams: requestParams
            });
          case 6:
            data = _context.sent;
            return _context.abrupt("return", data.priceRoute);
          case 8:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function getRate(_x, _x2) {
      return _ref3.apply(this, arguments);
    };
  }();
  var getRateByRoute = /*#__PURE__*/function () {
    var _ref5 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref4, requestParams) {
      var route, rest, parsedOptions, _route, search, fetchURL, data;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            route = _ref4.route, rest = _objectWithoutPropertiesLoose(_ref4, _excluded2$3);
            if (!(route.length < 2)) {
              _context2.next = 3;
              break;
            }
            throw new Error(INVALID_ROUTE);
          case 3:
            parsedOptions = normalizeRateOptions(rest);
            _route = route.join('-');
            search = constructSearchString(_extends({
              route: _route,
              // route can be used in place of srcToken+destToken
              network: chainId,
              version: version
            }, parsedOptions));
            fetchURL = pricesUrl + "/" + search;
            _context2.next = 9;
            return fetcher({
              url: fetchURL,
              method: 'GET',
              requestParams: requestParams
            });
          case 9:
            data = _context2.sent;
            return _context2.abrupt("return", data.priceRoute);
          case 11:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return function getRateByRoute(_x3, _x4) {
      return _ref5.apply(this, arguments);
    };
  }();
  return {
    getRate: getRate,
    getRateByRoute: getRateByRoute
  };
};

var _excluded$7 = ["srcToken", "destToken", "amount", "route"];
var constructSwapTx = function constructSwapTx(_ref) {
  var _ref$apiURL = _ref.apiURL,
    apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL,
    _ref$version = _ref.version,
    version = _ref$version === void 0 ? DEFAULT_VERSION : _ref$version,
    chainId = _ref.chainId,
    fetcher = _ref.fetcher;
  var pricesUrl = apiURL + "/swap";
  var getSwapTxData = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref2, requestParams) {
      var srcToken, destToken, amount, route, rest, parsedOptions, _route, search, fetchURL, data;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            srcToken = _ref2.srcToken, destToken = _ref2.destToken, amount = _ref2.amount, route = _ref2.route, rest = _objectWithoutPropertiesLoose(_ref2, _excluded$7);
            parsedOptions = normalizeRateOptions(rest);
            _route = route == null ? void 0 : route.join('-'); // always pass explicit type to make sure UrlSearchParams are correct
            search = constructSearchString(_extends({
              amount: amount,
              srcToken: srcToken,
              destToken: destToken,
              route: _route,
              network: chainId,
              version: version
            }, parsedOptions));
            fetchURL = pricesUrl + "/" + search;
            _context.next = 7;
            return fetcher({
              url: fetchURL,
              method: 'GET',
              requestParams: requestParams
            });
          case 7:
            data = _context.sent;
            return _context.abrupt("return", data);
          case 9:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function getSwapTxData(_x, _x2) {
      return _ref3.apply(this, arguments);
    };
  }();
  return {
    getSwapTxData: getSwapTxData
  };
};

var constructGetTokens = function constructGetTokens(_ref) {
  var _ref$apiURL = _ref.apiURL,
    apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL,
    chainId = _ref.chainId,
    fetcher = _ref.fetcher;
  var fetchURL = apiURL + "/tokens/" + chainId;
  var getTokens = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(requestParams) {
      var data, tokens;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return fetcher({
              url: fetchURL,
              method: 'GET',
              requestParams: requestParams
            });
          case 2:
            data = _context.sent;
            tokens = data.tokens.map(constructToken);
            return _context.abrupt("return", tokens);
          case 5:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function getTokens(_x) {
      return _ref2.apply(this, arguments);
    };
  }();
  return {
    getTokens: getTokens
  };
};

var name = 'AUGUSTUS RFQ';
var version = '1';
var ZERO_ADDRESS = '0x0000000000000000000000000000000000000000';

function baseFetchUrlGetterFactory(orderKind) {
  return function constructBaseFetchUrlGetter(_ref) {
    var chainId = _ref.chainId,
      apiURL = _ref.apiURL;
    function urlGetter(type) {
      if (!type) return apiURL + "/" + orderKind + "/order";
      if (type === 'fillablebalance') return apiURL + "/" + orderKind + "/fillablebalance/" + chainId;
      var orderURLpart = type === 'LIMIT' ? 'orders' : 'p2p';
      return apiURL + "/" + orderKind + "/" + orderURLpart + "/" + chainId;
    }
    return urlGetter;
  };
}

function sanitizeOrderData$1(_ref) {
  var nonceAndMeta = _ref.nonceAndMeta,
    expiry = _ref.expiry,
    makerAsset = _ref.makerAsset,
    takerAsset = _ref.takerAsset,
    maker = _ref.maker,
    taker = _ref.taker,
    makerAmount = _ref.makerAmount,
    takerAmount = _ref.takerAmount;
  return {
    nonceAndMeta: nonceAndMeta,
    expiry: expiry,
    makerAsset: makerAsset,
    takerAsset: takerAsset,
    maker: maker,
    taker: taker,
    makerAmount: makerAmount,
    takerAmount: takerAmount
  };
}
var constructBaseFetchUrlGetter$1 = /*#__PURE__*/baseFetchUrlGetterFactory('ft');

var OrderNFT = [{
  name: 'nonceAndMeta',
  type: 'uint256'
}, {
  name: 'expiry',
  type: 'uint128'
}, {
  name: 'makerAsset',
  type: 'uint256'
}, {
  name: 'makerAssetId',
  type: 'uint256'
}, {
  name: 'takerAsset',
  type: 'uint256'
}, {
  name: 'takerAssetId',
  type: 'uint256'
}, {
  name: 'maker',
  type: 'address'
}, {
  name: 'taker',
  type: 'address'
}, {
  name: 'makerAmount',
  type: 'uint256'
}, {
  name: 'takerAmount',
  type: 'uint256'
}];
function buildOrderData$1(_ref) {
  var chainId = _ref.chainId,
    verifyingContract = _ref.verifyingContract,
    _ref$nonce = _ref.nonce,
    nonce = _ref$nonce === void 0 ? getRandomInt() : _ref$nonce,
    expiry = _ref.expiry,
    _makerAssetAddress = _ref.makerAsset,
    _takerAssetAddress = _ref.takerAsset,
    makerAmount = _ref.makerAmount,
    takerAmount = _ref.takerAmount,
    makerAssetId = _ref.makerAssetId,
    _ref$takerAssetId = _ref.takerAssetId,
    takerAssetId = _ref$takerAssetId === void 0 ? '0' : _ref$takerAssetId,
    makerAssetType = _ref.makerAssetType,
    takerAssetType = _ref.takerAssetType,
    maker = _ref.maker,
    AugustusAddress = _ref.AugustusAddress,
    _ref$taker = _ref.taker,
    takerInNonce = _ref$taker === void 0 ? ZERO_ADDRESS : _ref$taker;
  // first 160 bits is taker address (for p2p orders),
  // or 0 for limitOrders, so that anyone can be the taker of the Order
  var nonceAndMeta = (BigInt(takerInNonce) + (BigInt(nonce) << BigInt(160))).toString(10);
  var makerAsset = assetAddressToUint(_makerAssetAddress, makerAssetType);
  var takerAsset = assetAddressToUint(_takerAssetAddress, takerAssetType);
  var orderNFT = {
    nonceAndMeta: nonceAndMeta,
    expiry: expiry,
    makerAsset: makerAsset,
    takerAsset: takerAsset,
    maker: maker,
    taker: AugustusAddress,
    makerAmount: makerAmount,
    takerAmount: takerAmount,
    makerAssetId: makerAssetId,
    takerAssetId: takerAssetId
  };
  return {
    types: {
      OrderNFT: OrderNFT
    },
    domain: {
      name: name,
      version: version,
      chainId: chainId,
      verifyingContract: verifyingContract
    },
    data: orderNFT
  };
}
// create a packed number that contains assetAddress and AssetType
function assetAddressToUint(assetAddress, assetType) {
  return (BigInt(assetAddress) + (BigInt(assetType) << BigInt(160))).toString(10);
}

// any number can be assigned to AssetType enum
// https://github.com/Microsoft/TypeScript/issues/22311
// export enum AssetType {
//   ERC20 = 0,
//   ERC1155 = 1,
//   ERC721 = 2,
// }
var AssetType = {
  ERC20: 0,
  ERC1155: 1,
  ERC721: 2
};
function sanitizeOrderData(_ref) {
  var nonceAndMeta = _ref.nonceAndMeta,
    expiry = _ref.expiry,
    _makerAsset = _ref.makerAsset,
    _takerAsset = _ref.takerAsset,
    maker = _ref.maker,
    taker = _ref.taker,
    makerAmount = _ref.makerAmount,
    takerAmount = _ref.takerAmount,
    makerAssetId = _ref.makerAssetId,
    takerAssetId = _ref.takerAssetId,
    makerAssetType = _ref.makerAssetType,
    takerAssetType = _ref.takerAssetType;
  var makerAsset = makerAssetType !== undefined && _makerAsset.startsWith('0x') ? assetAddressToUint(_makerAsset, makerAssetType) : _makerAsset;
  var takerAsset = takerAssetType !== undefined && _takerAsset.startsWith('0x') ? assetAddressToUint(_takerAsset, takerAssetType) : _takerAsset;
  return {
    nonceAndMeta: nonceAndMeta,
    expiry: expiry,
    makerAsset: makerAsset,
    takerAsset: takerAsset,
    maker: maker,
    taker: taker,
    makerAmount: makerAmount,
    takerAmount: takerAmount,
    makerAssetId: makerAssetId,
    takerAssetId: takerAssetId
  };
}
var constructBaseFetchUrlGetter = /*#__PURE__*/baseFetchUrlGetterFactory('nft');

var constructBuildTx = function constructBuildTx(_ref) {
  var _ref$apiURL = _ref.apiURL,
    apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL,
    chainId = _ref.chainId,
    fetcher = _ref.fetcher;
  var transactionsURL = apiURL + "/transactions/" + chainId;
  var buildTx = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(params, options, requestParams) {
      var _params$takeSurplus;
      var priceRoute, side, AmountMismatchError, search, fetchURL, sanitizedParams, takeSurplus, fetchParams, builtTx;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (options === void 0) {
              options = {};
            }
            if ('priceRoute' in params && 'destAmount' in params &&
            // isn't provided together with `orders`
            !('orders' in params) // when present, destAmount becomes sum(orders[].makerAmount)
            ) {
              priceRoute = params.priceRoute, side = params.priceRoute.side;
              AmountMismatchError = side === core.SwapSide.SELL ? 'Source Amount Mismatch' : 'Destination Amount Mismatch'; // user provides srcAmount or slippage but not both. so we only validate accordingly.
              tsEssentials.assert(areAmountsCorrect({
                queryParams: params,
                side: side,
                priceRoute: priceRoute
              }), AmountMismatchError);
            }
            // always pass explicit type to make sure UrlSearchParams are correct
            search = constructSearchString(options);
            fetchURL = transactionsURL + "/" + search;
            sanitizedParams = 'orders' in params && params.orders.length > 0 ? _extends({}, params, {
              //  make sure we don't pass more with orders than API expects
              orders: params.orders.map(function (order) {
                var sanitizedOrderData = 'makerAssetId' in order ? sanitizeOrderData(order) // assetType is provided here, because Order.*Asset may be address
                :
                // if Order received from API by hash
                sanitizeOrderData$1(order);
                var sanitizedOrder = _extends({}, sanitizedOrderData, {
                  signature: order.signature
                });
                if (order.permitMakerAsset) {
                  sanitizedOrder.permitMakerAsset = order.permitMakerAsset;
                }
                return sanitizedOrder;
              })
            }) : params;
            takeSurplus = (_params$takeSurplus = params.takeSurplus) != null ? _params$takeSurplus : params.positiveSlippageToUser !== undefined ? !params.positiveSlippageToUser : undefined;
            if ('positiveSlippageToUser' in sanitizedParams) {
              // positiveSlippageToUser & takeSurplus together will Error in API
              delete sanitizedParams.positiveSlippageToUser;
            }
            if (takeSurplus !== undefined) {
              sanitizedParams.takeSurplus = takeSurplus;
            }
            fetchParams = {
              url: fetchURL,
              method: 'POST',
              data: sanitizedParams,
              requestParams: requestParams
            };
            _context.next = 11;
            return fetcher(fetchParams);
          case 11:
            builtTx = _context.sent;
            return _context.abrupt("return", builtTx);
          case 13:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function buildTx(_x, _x2, _x3) {
      return _ref2.apply(this, arguments);
    };
  }();
  return {
    buildTx: buildTx
  };
};
function areAmountsCorrect(_ref3) {
  var queryParams = _ref3.queryParams,
    side = _ref3.side,
    priceRoute = _ref3.priceRoute;
  // return early after a simpler check if the user was swapping before filling
  if (queryParams.slippage) {
    return side === core.SwapSide.BUY && queryParams.destAmount === priceRoute.destAmount || side === core.SwapSide.SELL && queryParams.srcAmount === priceRoute.srcAmount;
  }
  // provided amounts match the previously queried price route
  var _ref4 = side === core.SwapSide.SELL ? [queryParams.srcAmount, priceRoute.srcAmount] : [queryParams.destAmount, priceRoute.destAmount],
    inputAmount = _ref4[0],
    priceRouteAmount = _ref4[1];
  return inputAmount === priceRouteAmount;
}

var Order = [{
  name: 'nonceAndMeta',
  type: 'uint256'
}, {
  name: 'expiry',
  type: 'uint128'
}, {
  name: 'makerAsset',
  type: 'address'
}, {
  name: 'takerAsset',
  type: 'address'
}, {
  name: 'maker',
  type: 'address'
}, {
  name: 'taker',
  type: 'address'
}, {
  name: 'makerAmount',
  type: 'uint256'
}, {
  name: 'takerAmount',
  type: 'uint256'
}];
function buildOrderData(_ref) {
  var chainId = _ref.chainId,
    verifyingContract = _ref.verifyingContract,
    _ref$nonce = _ref.nonce,
    nonce = _ref$nonce === void 0 ? getRandomInt() : _ref$nonce,
    expiry = _ref.expiry,
    makerAsset = _ref.makerAsset,
    takerAsset = _ref.takerAsset,
    makerAmount = _ref.makerAmount,
    takerAmount = _ref.takerAmount,
    maker = _ref.maker,
    AugustusAddress = _ref.AugustusAddress,
    _ref$taker = _ref.taker,
    takerInNonce = _ref$taker === void 0 ? ZERO_ADDRESS : _ref$taker,
    contractTaker = _ref.contractTaker,
    AppVersion = _ref.AppVersion;
  // first 160 bits is taker address (for p2p orders),
  // or 0 for limitOrders, so that anyone can be the taker of the Order
  var nonceAndMeta = (BigInt(takerInNonce) + (BigInt(nonce) << BigInt(160))).toString(10);
  var taker;
  // contractTaker overrides always
  if (contractTaker) {
    taker = contractTaker;
  } else if (takerInNonce === ZERO_ADDRESS) {
    // no takerInNonce -> not p2p order -> allow anyone to fill (not only Augustus)
    taker = ZERO_ADDRESS;
  } else {
    // otherwise for p2p order ->
    if (AppVersion.startsWith('6.')) {
      //support 6.1+ versions
      // limit taker to EOA for v6 version (no Arbitrary Token Swaps + OTC Fill, or OTC Fill through AugustusSwapper)
      taker = takerInNonce;
    } else {
      // on v5
      // -> fill through Augustus only
      taker = AugustusAddress;
    }
  }
  var order = {
    nonceAndMeta: nonceAndMeta,
    expiry: expiry,
    makerAsset: makerAsset,
    takerAsset: takerAsset,
    maker: maker,
    taker: taker,
    makerAmount: makerAmount,
    takerAmount: takerAmount
  };
  return {
    types: {
      Order: Order
    },
    domain: {
      name: name,
      version: version,
      chainId: chainId,
      verifyingContract: verifyingContract
    },
    data: order
  };
}

var constructBuildLimitOrder = function constructBuildLimitOrder(options) {
  var chainId = options.chainId;
  // getContracts is cached internally for the same instance of SDK
  // so should persist across same apiUrl & network
  var _constructGetSpender = constructGetSpender(options),
    getContracts = _constructGetSpender.getContracts;
  var buildLimitOrder = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(buildLimitOrderParams, requestParams) {
      var _options$version;
      var _yield$getContracts, AugustusAddress, verifyingContract, AppVersion;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return getContracts(requestParams);
          case 2:
            _yield$getContracts = _context.sent;
            AugustusAddress = _yield$getContracts.AugustusSwapper;
            verifyingContract = _yield$getContracts.AugustusRFQ;
            AppVersion = (_options$version = options.version) != null ? _options$version : DEFAULT_VERSION;
            return _context.abrupt("return", buildOrderData(_extends({}, buildLimitOrderParams, {
              chainId: chainId,
              verifyingContract: verifyingContract,
              AugustusAddress: AugustusAddress,
              AppVersion: AppVersion
            })));
          case 7:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function buildLimitOrder(_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }();
  return {
    buildLimitOrder: buildLimitOrder
  };
};

// returns whatever `contractCaller` returns
// to allow for better versatility
var constructSignLimitOrder = function constructSignLimitOrder(options) {
  var signLimitOrder = function signLimitOrder(typedData) {
    // types allow to pass OrderData & extra_stuff, but tx will break like that
    var typedDataOnly = _extends({}, typedData, {
      data: sanitizeOrderData$1(typedData.data)
    });
    return options.contractCaller.signTypedDataCall(typedDataOnly);
  };
  return {
    signLimitOrder: signLimitOrder
  };
};

// much smaller than the whole AugustusRFQ_ABI
var MinAugustusRFQAbi$1 = [{
  inputs: [{
    internalType: 'bytes32',
    name: 'orderHash',
    type: 'bytes32'
  }],
  name: 'cancelOrder',
  outputs: [],
  stateMutability: 'nonpayable',
  type: 'function'
}, {
  inputs: [{
    internalType: 'bytes32[]',
    name: 'orderHashes',
    type: 'bytes32[]'
  }],
  name: 'cancelOrders',
  outputs: [],
  stateMutability: 'nonpayable',
  type: 'function'
}];
// returns whatever `contractCaller` returns
// to allow for better versatility
var constructCancelLimitOrder = function constructCancelLimitOrder(options) {
  // getAugustusRFQ is cached internally for the same instance of SDK
  // so should persist across same apiUrl & network
  var _constructGetSpender = constructGetSpender(options),
    getAugustusRFQ = _constructGetSpender.getAugustusRFQ;
  var cancelLimitOrder = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(orderHash, overrides, requestParams) {
      var verifyingContract, res;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (overrides === void 0) {
              overrides = {};
            }
            _context.next = 3;
            return getAugustusRFQ(requestParams);
          case 3:
            verifyingContract = _context.sent;
            _context.next = 6;
            return options.contractCaller.transactCall({
              // @CHECK if verifyingContract is the one we need to approve
              // maybe a Proxy in-between
              address: verifyingContract,
              abi: MinAugustusRFQAbi$1,
              contractMethod: 'cancelOrder',
              args: [orderHash],
              overrides: overrides
            });
          case 6:
            res = _context.sent;
            return _context.abrupt("return", res);
          case 8:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function cancelLimitOrder(_x, _x2, _x3) {
      return _ref.apply(this, arguments);
    };
  }();
  var cancelLimitOrderBulk = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(orderHashes, overrides, requestParams) {
      var verifyingContract, res;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            if (overrides === void 0) {
              overrides = {};
            }
            _context2.next = 3;
            return getAugustusRFQ(requestParams);
          case 3:
            verifyingContract = _context2.sent;
            _context2.next = 6;
            return options.contractCaller.transactCall({
              // @CHECK if verifyingContract is the one we need to approve
              // maybe a Proxy in-between
              address: verifyingContract,
              abi: MinAugustusRFQAbi$1,
              contractMethod: 'cancelOrders',
              args: [orderHashes],
              overrides: overrides
            });
          case 6:
            res = _context2.sent;
            return _context2.abrupt("return", res);
          case 8:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return function cancelLimitOrderBulk(_x4, _x5, _x6) {
      return _ref2.apply(this, arguments);
    };
  }();
  return {
    cancelLimitOrder: cancelLimitOrder,
    cancelLimitOrderBulk: cancelLimitOrderBulk
  };
};

function splitSignature(signature) {
  // Remove "0x" prefix if present
  if (signature.startsWith('0x')) {
    signature = signature.slice(2);
  }
  // Convert the hex string to a byte array
  var bytes = new Uint8Array(signature.length / 2);
  for (var i = 0; i < signature.length; i += 2) {
    bytes[i / 2] = parseInt(signature.slice(i, i + 2), 16);
  }
  // Validate the signature length (64 or 65 bytes)
  if (bytes.length !== 64 && bytes.length !== 65) {
    throw new Error('Invalid signature length: must be 64 or 65 bytes');
  }
  // Extract r and s components
  var r = "0x" + Array.from(bytes.slice(0, 32), function (b) {
    return b.toString(16).padStart(2, '0');
  }).join('');
  var s;
  var v;
  // Handle 64-byte (EIP-2098 compact) and 65-byte signatures
  if (bytes.length === 64) {
    // Extract v from the highest bit of s and clear the bit in s
    v = 27 + (bytes[32] >> 7);
    bytes[32] &= 0x7f; // Clear the highest bit
    s = "0x" + Array.from(bytes.slice(32, 64)).map(function (b) {
      return b.toString(16).padStart(2, '0');
    }).join('');
  } else {
    s = "0x" + Array.from(bytes.slice(32, 64)).map(function (b) {
      return b.toString(16).padStart(2, '0');
    }).join('');
    // Extract v directly for 65-byte signature
    v = bytes[64];
    // Normalize v to canonical form (27 or 28)
    if (v < 27) {
      v += 27;
    }
  }
  // Compute yParityAndS (_vs) for the compact signature
  var sBytes = Array.from(bytes.slice(32, 64));
  if (v === 28) {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    sBytes[0] |= 0x80; // Set the highest bit if v is 28
  }
  var yParityAndS = "0x" + sBytes.map(function (b) {
    return b.toString(16).padStart(2, '0');
  }).join('');
  // Construct the compact signature by concatenating r and yParityAndS
  var compactSignature = r + yParityAndS.slice(2);
  return {
    v: v,
    r: r,
    s: s,
    compact: compactSignature
  };
}

// encoding params for Token.permit() Permit1 function
function encodeEIP_2612PermitFunctionInput(_ref) {
  var owner = _ref.owner,
    spender = _ref.spender,
    value = _ref.value,
    deadline = _ref.deadline,
    permitSignature = _ref.permitSignature;
  var _splitSignature = splitSignature(permitSignature),
    v = _splitSignature.v,
    r = _splitSignature.r,
    s = _splitSignature.s;
  var encodedOwner = encodeAddress(owner);
  var encodedSpender = encodeAddress(spender);
  var encodedValue = encodeUint256(value);
  var encodedDeadline = encodeUint256(deadline.toString());
  var encodedV = encodeUint8(v);
  var encodedR = encodeBytes32(r);
  var encodedS = encodeBytes32(s);
  // Concatenate all encoded values, stripping the "0x" prefix from each (except the first one)
  return '0x' + [encodedOwner, encodedSpender, encodedValue, encodedDeadline, encodedV, encodedR, encodedS].map(function (val) {
    return val.slice(2);
  }) // Remove "0x" prefix from each encoded value
  .join('') // Concatenate the values
  ;
}
// encoding params for DAIlike.permit() function
function encodeDAIlikePermitFunctionInput(_ref2) {
  var permitSignature = _ref2.permitSignature,
    holder = _ref2.holder,
    spender = _ref2.spender,
    nonce = _ref2.nonce,
    expiry = _ref2.expiry;
  var _splitSignature2 = splitSignature(permitSignature),
    v = _splitSignature2.v,
    r = _splitSignature2.r,
    s = _splitSignature2.s;
  var encodedHolder = encodeAddress(holder);
  var encodedSpender = encodeAddress(spender);
  var encodedNonce = encodeUint256(nonce.toString());
  var encodedExpiry = encodeUint256(expiry.toString());
  var encodedV = encodeUint8(v);
  var encodedR = encodeBytes32(r);
  var encodedS = encodeBytes32(s);
  // Concatenate all encoded values, stripping the "0x" prefix from each (except the first one)
  return '0x' + [encodedHolder, encodedSpender, encodedNonce, encodedExpiry, encodeBool(true),
  //allowed=true
  encodedV, encodedR, encodedS].map(function (val) {
    return val.slice(2);
  }) // Remove "0x" prefix from each encoded value
  .join('') // Concatenate the values
  ;
}
// encode an address (20 bytes) into 32 bytes
function encodeAddress(address) {
  var strippedAddress = address.replace(/^0x/, ''); // Remove "0x" prefix
  return '0x' + strippedAddress.toLowerCase().padStart(64, '0');
}
// encode a uint256 value
function encodeUint256(value) {
  var bn = BigInt(value);
  return '0x' + bn.toString(16).padStart(64, '0');
}
// encode a uint8 value
function encodeUint8(value) {
  return '0x' + value.toString(16).padStart(64, '0');
}
// encode a bytes32 value
function encodeBytes32(value) {
  var strippedValue = value.replace(/^0x/, ''); // Remove "0x" prefix
  return '0x' + strippedValue.padStart(64, '0').toLowerCase();
}
//encode a boolean
function encodeBool(value) {
  var encodedValue = value ? '1' : '0';
  // padded to 32 bytes
  return '0x' + encodedValue.padStart(64, '0');
}
/*
const EIP_2612_PERMIT_ABI = [
  {
    constant: false,
    inputs: [
      {
        name: 'owner',
        type: 'address',
      },
      {
        name: 'spender',
        type: 'address',
      },
      {
        name: 'value',
        type: 'uint256',
      },
      {
        name: 'deadline',
        type: 'uint256',
      },
      {
        name: 'v',
        type: 'uint8',
      },
      {
        name: 'r',
        type: 'bytes32',
      },
      {
        name: 's',
        type: 'bytes32',
      },
    ],
    name: 'permit',
    outputs: [],
    payable: false,
    stateMutability: 'nonpayable',
    type: 'function',
  },
];
*/
/*
const DAI_EIP_2612_PERMIT_ABI = [
  {
    constant: false,
    inputs: [
      {
        internalType: 'address',
        name: 'holder',
        type: 'address',
      },
      {
        internalType: 'address',
        name: 'spender',
        type: 'address',
      },
      {
        internalType: 'uint256',
        name: 'nonce',
        type: 'uint256',
      },
      {
        internalType: 'uint256',
        name: 'expiry',
        type: 'uint256',
      },
      {
        internalType: 'bool',
        name: 'allowed',
        type: 'bool',
      },
      {
        internalType: 'uint8',
        name: 'v',
        type: 'uint8',
      },
      {
        internalType: 'bytes32',
        name: 'r',
        type: 'bytes32',
      },
      {
        internalType: 'bytes32',
        name: 's',
        type: 'bytes32',
      },
    ],
    name: 'permit',
    outputs: [],
    payable: false,
    stateMutability: 'nonpayable',
    type: 'function',
  },
];
 */

// much smaller than the whole AugustusRFQ_ABI
var MinAugustusRFQAbi = [{
  inputs: [{
    components: [{
      internalType: 'uint256',
      name: 'nonceAndMeta',
      type: 'uint256'
    }, {
      internalType: 'uint128',
      name: 'expiry',
      type: 'uint128'
    }, {
      internalType: 'address',
      name: 'makerAsset',
      type: 'address'
    }, {
      internalType: 'address',
      name: 'takerAsset',
      type: 'address'
    }, {
      internalType: 'address',
      name: 'maker',
      type: 'address'
    }, {
      internalType: 'address',
      name: 'taker',
      type: 'address'
    }, {
      internalType: 'uint256',
      name: 'makerAmount',
      type: 'uint256'
    }, {
      internalType: 'uint256',
      name: 'takerAmount',
      type: 'uint256'
    }],
    internalType: 'struct AugustusRFQ.Order',
    name: 'order',
    type: 'tuple'
  }, {
    internalType: 'bytes',
    name: 'signature',
    type: 'bytes'
  }],
  name: 'fillOrder',
  outputs: [],
  stateMutability: 'nonpayable',
  type: 'function'
}, {
  inputs: [{
    components: [{
      internalType: 'uint256',
      name: 'nonceAndMeta',
      type: 'uint256'
    }, {
      internalType: 'uint128',
      name: 'expiry',
      type: 'uint128'
    }, {
      internalType: 'address',
      name: 'makerAsset',
      type: 'address'
    }, {
      internalType: 'address',
      name: 'takerAsset',
      type: 'address'
    }, {
      internalType: 'address',
      name: 'maker',
      type: 'address'
    }, {
      internalType: 'address',
      name: 'taker',
      type: 'address'
    }, {
      internalType: 'uint256',
      name: 'makerAmount',
      type: 'uint256'
    }, {
      internalType: 'uint256',
      name: 'takerAmount',
      type: 'uint256'
    }],
    internalType: 'struct AugustusRFQ.Order',
    name: 'order',
    type: 'tuple'
  }, {
    internalType: 'bytes',
    name: 'signature',
    type: 'bytes'
  }, {
    internalType: 'uint256',
    name: 'takerTokenFillAmount',
    type: 'uint256'
  }, {
    internalType: 'address',
    name: 'target',
    type: 'address'
  }, {
    internalType: 'bytes',
    name: 'permitTakerAsset',
    type: 'bytes'
  }, {
    internalType: 'bytes',
    name: 'permitMakerAsset',
    type: 'bytes'
  }],
  name: 'partialFillOrderWithTargetPermit',
  outputs: [{
    internalType: 'uint256',
    name: 'makerTokenFilledAmount',
    type: 'uint256'
  }],
  stateMutability: 'nonpayable',
  type: 'function'
}];
// returns whatever `contractCaller` returns
// to allow for better versatility
function constructFillOrderDirectly(options) {
  // getAugustusRFQ is cached internally for the same instance of SDK
  // so should persist across same apiUrl & network
  var _constructGetSpender = constructGetSpender(options),
    getAugustusRFQ = _constructGetSpender.getAugustusRFQ;
  var fillOrderDirectly = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref, overrides, requestParams) {
      var order, signature, takerPermit, AugustusRFQ, sanitizedOrder, _res, permitTakerAsset, res;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            order = _ref.order, signature = _ref.signature, takerPermit = _ref.takerPermit;
            if (overrides === void 0) {
              overrides = {};
            }
            _context.next = 4;
            return getAugustusRFQ(requestParams);
          case 4:
            AugustusRFQ = _context.sent;
            sanitizedOrder = sanitizeOrderData$1(order);
            if (takerPermit) {
              _context.next = 11;
              break;
            }
            _context.next = 9;
            return options.contractCaller.transactCall({
              address: AugustusRFQ,
              abi: MinAugustusRFQAbi,
              contractMethod: 'fillOrder',
              args: [sanitizedOrder, signature],
              overrides: overrides
            });
          case 9:
            _res = _context.sent;
            return _context.abrupt("return", _res);
          case 11:
            if ('encodedPermitParams' in takerPermit) {
              permitTakerAsset = takerPermit.encodedPermitParams;
            } else if ('isDaiPermit' in takerPermit && takerPermit.isDaiPermit) {
              // encoded DAI.permit() function params by taker with AugustusRFQ as spender
              permitTakerAsset = encodeDAIlikePermitFunctionInput({
                holder: order.taker,
                spender: AugustusRFQ,
                expiry: takerPermit.expiry,
                nonce: takerPermit.nonce,
                permitSignature: takerPermit.signature
              });
            } else {
              // encoded TakerAsset.permit() function params by taker with AugustusRFQ as spender, Permit1 only
              permitTakerAsset = encodeEIP_2612PermitFunctionInput({
                owner: order.taker,
                spender: AugustusRFQ,
                value: takerPermit.amount || order.takerAmount,
                // can use permit with a bigger value, fallback to exact Order takerAmount
                deadline: takerPermit.deadline,
                permitSignature: takerPermit.signature
              });
            }
            _context.next = 14;
            return options.contractCaller.transactCall({
              address: AugustusRFQ,
              abi: MinAugustusRFQAbi,
              contractMethod: 'partialFillOrderWithTargetPermit',
              args: [sanitizedOrder,
              // order
              signature,
              // order.signature
              order.takerAmount,
              // takerTokenFillAmount, can even partially fill
              order.taker,
              // target
              permitTakerAsset, '0x' // permitMakerAsset, unused because hard to account for changing nonce for long running Orders
              ],
              overrides: overrides
            });
          case 14:
            res = _context.sent;
            return _context.abrupt("return", res);
          case 16:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function fillOrderDirectly(_x, _x2, _x3) {
      return _ref2.apply(this, arguments);
    };
  }();
  return {
    fillOrderDirectly: fillOrderDirectly
  };
}

var constructGetLimitOrders = function constructGetLimitOrders(_ref) {
  var _ref$apiURL = _ref.apiURL,
    apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL,
    chainId = _ref.chainId,
    fetcher = _ref.fetcher;
  var getBaseFetchURLByEntityType = constructBaseFetchUrlGetter$1({
    apiURL: apiURL,
    chainId: chainId
  });
  var getLimitOrders = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(userParams, requestParams) {
      var baseFetchURL, userURL, offset, limit, hideSmallBalances, orderBy, search, fetchURL, response;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            baseFetchURL = getBaseFetchURLByEntityType(userParams.type);
            userURL = 'maker' in userParams ? "maker/" + userParams.maker : "taker/" + userParams.taker;
            offset = userParams.offset, limit = userParams.limit, hideSmallBalances = userParams.hideSmallBalances, orderBy = userParams.orderBy;
            search = constructSearchString({
              offset: offset,
              limit: limit,
              hideSmallBalances: hideSmallBalances,
              orderBy: orderBy
            });
            fetchURL = baseFetchURL + "/" + userURL + search;
            _context.next = 7;
            return fetcher({
              url: fetchURL,
              method: 'GET',
              requestParams: requestParams
            });
          case 7:
            response = _context.sent;
            return _context.abrupt("return", response);
          case 9:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function getLimitOrders(_x, _x2) {
      return _ref2.apply(this, arguments);
    };
  }();
  var getRequiredBalance = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(userParams, requestParams) {
      var baseFetchURL, userURL, fetchURL, response;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            baseFetchURL = getBaseFetchURLByEntityType('fillablebalance');
            userURL = baseFetchURL + "/" + userParams.maker;
            fetchURL = userParams.token ? userURL + "/" + userParams.token : userURL;
            _context2.next = 5;
            return fetcher({
              url: fetchURL,
              method: 'GET',
              requestParams: requestParams
            });
          case 5:
            response = _context2.sent;
            return _context2.abrupt("return", response);
          case 7:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return function getRequiredBalance(_x3, _x4) {
      return _ref3.apply(this, arguments);
    };
  }();
  var getLimitOrderByHash = /*#__PURE__*/function () {
    var _ref4 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(orderHash, requestParams) {
      var baseFetchURL, fetchURL, order;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            baseFetchURL = getBaseFetchURLByEntityType();
            fetchURL = baseFetchURL + "/" + orderHash;
            _context3.next = 4;
            return fetcher({
              url: fetchURL,
              method: 'GET',
              requestParams: requestParams
            });
          case 4:
            order = _context3.sent;
            return _context3.abrupt("return", order);
          case 6:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    return function getLimitOrderByHash(_x5, _x6) {
      return _ref4.apply(this, arguments);
    };
  }();
  return {
    getLimitOrders: getLimitOrders,
    getLimitOrderByHash: getLimitOrderByHash,
    getRequiredBalance: getRequiredBalance
  };
};

var constructPostLimitOrder = function constructPostLimitOrder(_ref) {
  var _ref$apiURL = _ref.apiURL,
    apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL,
    chainId = _ref.chainId,
    fetcher = _ref.fetcher;
  var getBaseFetchURLByOrderType = constructBaseFetchUrlGetter$1({
    apiURL: apiURL,
    chainId: chainId
  });
  var postTypedOrder = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(limitOrderWithSignatureAndPermit, type, requestParams) {
      var fetchURL, _yield$fetcher, newOrder;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            fetchURL = getBaseFetchURLByOrderType(type);
            _context.next = 3;
            return fetcher({
              url: fetchURL,
              method: 'POST',
              data: limitOrderWithSignatureAndPermit,
              requestParams: requestParams
            });
          case 3:
            _yield$fetcher = _context.sent;
            newOrder = _yield$fetcher.order;
            return _context.abrupt("return", newOrder);
          case 6:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function postTypedOrder(_x, _x2, _x3) {
      return _ref2.apply(this, arguments);
    };
  }();
  var postLimitOrder = function postLimitOrder(limitOrderWithSignatureAndPermit, requestParams) {
    return postTypedOrder(limitOrderWithSignatureAndPermit, 'LIMIT', requestParams);
  };
  var postP2POrder = function postP2POrder(limitOrderWithSignatureAndPermit, requestParams) {
    return postTypedOrder(limitOrderWithSignatureAndPermit, 'P2P', requestParams);
  };
  return {
    postLimitOrder: postLimitOrder,
    postP2POrder: postP2POrder
  };
};

// returns whatever `contractCaller` returns
// to allow for better versatility
var constructApproveTokenForLimitOrder = function constructApproveTokenForLimitOrder(options) {
  // getAugustusRFQ is cached internally for the same instance of SDK
  // so should persist across same apiUrl & network
  var _constructGetSpender = constructGetSpender(options),
    getAugustusRFQ = _constructGetSpender.getAugustusRFQ;
  var approveMakerTokenForLimitOrder = approveTokenMethodFactory(options.contractCaller, getAugustusRFQ);
  // approving TokenTransaferProxy as for the swap
  var _constructApproveToke = constructApproveToken(options),
    approveTakerTokenForLimitOrder = _constructApproveToke.approveToken;
  return {
    approveMakerTokenForLimitOrder: approveMakerTokenForLimitOrder,
    approveTakerTokenForFillingP2POrderDirectly: approveMakerTokenForLimitOrder,
    approveTakerTokenForLimitOrder: approveTakerTokenForLimitOrder
  };
};

var constructGetLimitOrdersContract = function constructGetLimitOrdersContract(options) {
  // analogous to getSpender() but for Limit Orders Contract = AugustusRFQ
  var _constructGetSpender = constructGetSpender(options),
    getTokenTransferProxy = _constructGetSpender.getSpender,
    getLimitOrdersContract = _constructGetSpender.getAugustusRFQ;
  return {
    getLimitOrdersContract: getLimitOrdersContract,
    getTokenTransferProxy: getTokenTransferProxy
  };
};

var _excluded$6 = ["srcToken", "destToken", "amount", "options"];
var constructBuildLimitOrderTx = function constructBuildLimitOrderTx(_ref) {
  var _ref$apiURL = _ref.apiURL,
    apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL,
    _ref$version = _ref.version,
    version = _ref$version === void 0 ? DEFAULT_VERSION : _ref$version,
    chainId = _ref.chainId,
    fetcher = _ref.fetcher;
  var _constructBuildTx = constructBuildTx({
      apiURL: apiURL,
      chainId: chainId,
      fetcher: fetcher,
      version: version
    }),
    buildSwapTx = _constructBuildTx.buildTx;
  var _constructGetRate = constructGetRate({
      apiURL: apiURL,
      version: version,
      chainId: chainId,
      fetcher: fetcher
    }),
    getSwapAndLimitOrderRate = _constructGetRate.getRate;
  //  returns priceRoute that would allow to swap from srcToken to destToken(=order.takerAsset) followed by filling limit orders
  var getLimitOrdersRate = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref2, orders, requestParams) {
      var srcToken, destToken, amount, _ref2$options, _options, rest, _checkAndParseOrders, totalTakerAmount, takerAsset, takerAmountString, options, side, rateInput, optimalRate;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            srcToken = _ref2.srcToken, destToken = _ref2.destToken, amount = _ref2.amount, _ref2$options = _ref2.options, _options = _ref2$options === void 0 ? {} : _ref2$options, rest = _objectWithoutPropertiesLoose(_ref2, _excluded$6);
            tsEssentials.assert(orders.length > 0, 'must pass at least 1 order');
            _checkAndParseOrders = checkAndParseOrders$1(orders), totalTakerAmount = _checkAndParseOrders.totalTakerAmount, takerAsset = _checkAndParseOrders.takerAsset;
            tsEssentials.assert(takerAsset.toLowerCase() === destToken.toLowerCase(), 'All orders must have the same takerAsset as destToken');
            takerAmountString = totalTakerAmount.toString(10);
            if (amount) {
              tsEssentials.assert(amount === takerAmountString, "`amount` must equal the total of the orders' `takerAmounts`");
            }
            // The pricing must use includeContractMethods=simpleBuy and side=BUY
            options = _extends({}, _options, {
              includeContractMethods: [core.ContractMethod.simpleBuy]
            });
            side = core.SwapSide.BUY;
            rateInput = _extends({}, rest, {
              srcToken: srcToken,
              destToken: destToken,
              amount: takerAmountString,
              side: side,
              options: options
            }); // priceRoute
            _context.next = 11;
            return getSwapAndLimitOrderRate(rateInput, requestParams);
          case 11:
            optimalRate = _context.sent;
            return _context.abrupt("return", optimalRate);
          case 13:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function getLimitOrdersRate(_x, _x2, _x3) {
      return _ref3.apply(this, arguments);
    };
  }();
  // derive srcToken, destToken and srcAmount from orders[]
  var buildLimitOrderTx = function buildLimitOrderTx(params, options, requestParams) {
    var _checkAndParseOrders2 = checkAndParseOrders$1(params.orders),
      makerAsset = _checkAndParseOrders2.makerAsset,
      takerAsset = _checkAndParseOrders2.takerAsset,
      totalTakerAmount = _checkAndParseOrders2.totalTakerAmount;
    var fillParams = _extends({}, params, {
      // taker supplies takerAsset
      srcToken: takerAsset,
      // no `slippage` in `params`
      srcAmount: totalTakerAmount.toString(10),
      // taker gets makerAsset in the end
      destToken: makerAsset
    });
    return buildSwapTx(fillParams, options, requestParams);
  };
  var buildSwapAndLimitOrderTx = function buildSwapAndLimitOrderTx(params, options, requestParams) {
    var _checkAndParseOrders3 = checkAndParseOrders$1(params.orders),
      makerAsset = _checkAndParseOrders3.makerAsset;
    var fillParams = _extends({}, params, {
      // taker supplies srcToken
      srcToken: params.priceRoute.srcToken,
      // which is swapped for makerAsset, that would go towards filling the orders
      destToken: makerAsset,
      destDecimals: params.priceRoute.destDecimals
    }, params.slippage ? {
      slippage: params.slippage
    } :
    //                                        may sneak in as part of `params`
    {
      srcAmount: params.priceRoute.srcAmount,
      slippage: undefined
    });
    return buildSwapTx(fillParams, options, requestParams);
  };
  return {
    getLimitOrdersRate: getLimitOrdersRate,
    buildLimitOrderTx: buildLimitOrderTx,
    buildSwapAndLimitOrderTx: buildSwapAndLimitOrderTx
  };
};
function checkAndParseOrders$1(orders) {
  tsEssentials.assert(isFilledArray(orders), 'must pass at least 1 order');
  var _orders$reduce = orders.reduce(function (accum, order) {
      accum.takerAssetsSet.add(order.takerAsset.toLowerCase());
      accum.makerAssetsSet.add(order.makerAsset.toLowerCase());
      accum.totalTakerAmount = accum.totalTakerAmount + BigInt(order.takerAmount);
      return accum;
    }, {
      takerAssetsSet: new Set(),
      makerAssetsSet: new Set(),
      totalTakerAmount: BigInt(0)
    }),
    takerAssetsSet = _orders$reduce.takerAssetsSet,
    makerAssetsSet = _orders$reduce.makerAssetsSet,
    totalTakerAmount = _orders$reduce.totalTakerAmount;
  tsEssentials.assert(takerAssetsSet.size === 1, 'All orders must have the same takerAsset as destToken');
  tsEssentials.assert(makerAssetsSet.size === 1, 'All orders must have the same makerAsset');
  var _orders$ = orders[0],
    maker = _orders$.maker,
    taker = _orders$.taker,
    makerAsset = _orders$.makerAsset,
    takerAsset = _orders$.takerAsset;
  return {
    totalTakerAmount: totalTakerAmount,
    maker: maker,
    taker: taker,
    makerAsset: makerAsset,
    takerAsset: takerAsset
  };
}

var constructBuildNFTOrder = function constructBuildNFTOrder(options) {
  var chainId = options.chainId;
  // getContracts is cached internally for the same instance of SDK
  // so should persist across same apiUrl & network
  var _constructGetSpender = constructGetSpender(options),
    getContracts = _constructGetSpender.getContracts;
  var buildNFTOrder = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(buildNFTOrderParams, requestParams) {
      var _yield$getContracts, AugustusAddress, verifyingContract;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return getContracts(requestParams);
          case 2:
            _yield$getContracts = _context.sent;
            AugustusAddress = _yield$getContracts.AugustusSwapper;
            verifyingContract = _yield$getContracts.AugustusRFQ;
            return _context.abrupt("return", buildOrderData$1(_extends({}, buildNFTOrderParams, {
              chainId: chainId,
              verifyingContract: verifyingContract,
              AugustusAddress: AugustusAddress
            })));
          case 6:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function buildNFTOrder(_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }();
  return {
    buildNFTOrder: buildNFTOrder
  };
};

// returns whatever `contractCaller` returns
// to allow for better versatility
var constructSignNFTOrder = function constructSignNFTOrder(options) {
  var signNFTOrder = function signNFTOrder(typedData) {
    // types allow to pass OrderData & extra_stuff, but tx will break like that
    var typedDataOnly = _extends({}, typedData, {
      // here assetType isn't provided, SignableData must already have corrent BigIntAsString
      // @TODO consider using `template_${types}` for Address, likely bad idea when considering 3rd-party code
      data: sanitizeOrderData(typedData.data)
    });
    return options.contractCaller.signTypedDataCall(typedDataOnly);
  };
  return {
    signNFTOrder: signNFTOrder
  };
};

// should work the same as for LimitOrders
var constructCancelNFTOrder = function constructCancelNFTOrder(options) {
  var _constructCancelLimit = constructCancelLimitOrder(options),
    cancelLimitOrder = _constructCancelLimit.cancelLimitOrder,
    cancelLimitOrderBulk = _constructCancelLimit.cancelLimitOrderBulk;
  return {
    cancelNFTOrder: cancelLimitOrder,
    cancelNFTOrderBulk: cancelLimitOrderBulk
  };
};

var constructGetNFTOrders = function constructGetNFTOrders(_ref) {
  var _ref$apiURL = _ref.apiURL,
    apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL,
    chainId = _ref.chainId,
    fetcher = _ref.fetcher;
  var getBaseFetchURLByOrderType = constructBaseFetchUrlGetter({
    apiURL: apiURL,
    chainId: chainId
  });
  var getNFTOrders = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(userParams, requestParams) {
      var baseFetchURL, userURL, fetchURL, response;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            baseFetchURL = getBaseFetchURLByOrderType(userParams.type);
            userURL = 'maker' in userParams ? "maker/" + userParams.maker : "taker/" + userParams.taker;
            fetchURL = baseFetchURL + "/" + userURL;
            _context.next = 5;
            return fetcher({
              url: fetchURL,
              method: 'GET',
              requestParams: requestParams
            });
          case 5:
            response = _context.sent;
            return _context.abrupt("return", response);
          case 7:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function getNFTOrders(_x, _x2) {
      return _ref2.apply(this, arguments);
    };
  }();
  var getNFTOrderByHash = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(orderHash, requestParams) {
      var baseFetchURL, fetchURL, order;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            baseFetchURL = getBaseFetchURLByOrderType();
            fetchURL = baseFetchURL + "/" + orderHash;
            _context2.next = 4;
            return fetcher({
              url: fetchURL,
              method: 'GET',
              requestParams: requestParams
            });
          case 4:
            order = _context2.sent;
            return _context2.abrupt("return", order);
          case 6:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return function getNFTOrderByHash(_x3, _x4) {
      return _ref3.apply(this, arguments);
    };
  }();
  return {
    getNFTOrders: getNFTOrders,
    getNFTOrderByHash: getNFTOrderByHash
  };
};

var constructPostNFTOrder = function constructPostNFTOrder(_ref) {
  var _ref$apiURL = _ref.apiURL,
    apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL,
    chainId = _ref.chainId,
    fetcher = _ref.fetcher;
  var getBaseFetchURLByOrderType = constructBaseFetchUrlGetter({
    apiURL: apiURL,
    chainId: chainId
  });
  var postTypedOrder = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(NFTOrderWithSignatureAndPermit, type, requestParams) {
      var fetchURL, _yield$fetcher, newOrder;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            fetchURL = getBaseFetchURLByOrderType(type); // @TODO check API return matches
            _context.next = 3;
            return fetcher({
              url: fetchURL,
              method: 'POST',
              data: NFTOrderWithSignatureAndPermit,
              requestParams: requestParams
            });
          case 3:
            _yield$fetcher = _context.sent;
            newOrder = _yield$fetcher.order;
            return _context.abrupt("return", _extends({}, newOrder));
          case 6:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function postTypedOrder(_x, _x2, _x3) {
      return _ref2.apply(this, arguments);
    };
  }();
  var postNFTLimitOrder = function postNFTLimitOrder(NFTOrderWithSignatureAndPermit, requestParams) {
    return postTypedOrder(NFTOrderWithSignatureAndPermit, 'LIMIT', requestParams);
  };
  var postNFTP2POrder = function postNFTP2POrder(NFTOrderWithSignatureAndPermit, requestParams) {
    return postTypedOrder(NFTOrderWithSignatureAndPermit, 'P2P', requestParams);
  };
  return {
    postNFTLimitOrder: postNFTLimitOrder,
    postNFTP2POrder: postNFTP2POrder
  };
};

// should work the same as LimitOrders
var constructGetNFTOrdersContract = function constructGetNFTOrdersContract(options) {
  // analogous to getSpender() but for Limit Orders Contract = AugustusRFQ
  var _constructGetSpender = constructGetSpender(options),
    getTokenTransferProxy = _constructGetSpender.getSpender,
    getNFTOrdersContract = _constructGetSpender.getAugustusRFQ;
  return {
    getNFTOrdersContract: getNFTOrdersContract,
    getTokenTransferProxy: getTokenTransferProxy
  };
};

var MinNFTAbi = [{
  constant: false,
  inputs: [{
    name: '_operator',
    type: 'address'
  }, {
    name: '_approved',
    type: 'bool'
  }],
  name: 'setApprovalForAll',
  outputs: [],
  payable: false,
  stateMutability: 'nonpayable',
  type: 'function'
}];
// returns whatever `contractCaller` returns
// to allow for better versatility
var constructApproveTokenForNFTOrder = function constructApproveTokenForNFTOrder(options) {
  // approving TokenTransaferProxy as for the swap
  var _constructApproveToke = constructApproveToken(options),
    approveERC20ForNFTOrder = _constructApproveToke.approveToken;
  var _constructGetNFTOrder = constructGetNFTOrdersContract(options),
    getNFTOrdersContract = _constructGetNFTOrder.getNFTOrdersContract;
  var approveNFTForNFTOrder = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(tokenAddress, overrides, requestParams) {
      var AugustusRFQ, res;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (overrides === void 0) {
              overrides = {};
            }
            _context.next = 3;
            return getNFTOrdersContract(requestParams);
          case 3:
            AugustusRFQ = _context.sent;
            _context.next = 6;
            return options.contractCaller.transactCall({
              address: tokenAddress,
              abi: MinNFTAbi,
              contractMethod: 'setApprovalForAll',
              args: [AugustusRFQ, true],
              overrides: overrides
            });
          case 6:
            res = _context.sent;
            return _context.abrupt("return", res);
          case 8:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function approveNFTForNFTOrder(_x, _x2, _x3) {
      return _ref.apply(this, arguments);
    };
  }();
  return {
    approveERC20ForNFTOrder: approveERC20ForNFTOrder,
    approveNFTForNFTOrder: approveNFTForNFTOrder
  };
};

var _excluded$5 = ["srcToken", "destToken", "amount", "options"];
var constructBuildNFTOrderTx = function constructBuildNFTOrderTx(_ref) {
  var _ref$apiURL = _ref.apiURL,
    apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL,
    _ref$version = _ref.version,
    version = _ref$version === void 0 ? DEFAULT_VERSION : _ref$version,
    chainId = _ref.chainId,
    fetcher = _ref.fetcher;
  var _constructBuildTx = constructBuildTx({
      apiURL: apiURL,
      version: version,
      chainId: chainId,
      fetcher: fetcher
    }),
    buildSwapTx = _constructBuildTx.buildTx;
  var _constructGetRate = constructGetRate({
      apiURL: apiURL,
      version: version,
      chainId: chainId,
      fetcher: fetcher
    }),
    getSwapAndNFTOrderRate = _constructGetRate.getRate;
  //  returns priceRoute that would allow from swap from srcToken to destToken(=order.takerAsset) followed by filling NFT orders
  var getNFTOrdersRate = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref2, orders, requestParams) {
      var srcToken, destToken, amount, _ref2$options, _options, rest, _checkAndParseOrders, totalTakerAmount, takerAsset, takerAmountString, options, side, rateInput, optimalRate;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            srcToken = _ref2.srcToken, destToken = _ref2.destToken, amount = _ref2.amount, _ref2$options = _ref2.options, _options = _ref2$options === void 0 ? {} : _ref2$options, rest = _objectWithoutPropertiesLoose(_ref2, _excluded$5);
            tsEssentials.assert(orders.length > 0, 'must pass at least 1 order');
            _checkAndParseOrders = checkAndParseOrders(orders), totalTakerAmount = _checkAndParseOrders.totalTakerAmount, takerAsset = _checkAndParseOrders.takerAsset;
            tsEssentials.assert(takerAsset.toLowerCase() === destToken.toLowerCase(), 'All orders must have the same takerAsset as destToken');
            takerAmountString = totalTakerAmount.toString(10);
            if (amount) {
              tsEssentials.assert(amount === takerAmountString, "`amount` must equal the total of the orders' `takerAmounts`");
            }
            // The pricing must use includeContractMethods=simpleBuy and side=BUY
            options = _extends({}, _options, {
              includeContractMethods: [core.ContractMethod.simpleBuy]
            });
            side = core.SwapSide.BUY;
            rateInput = _extends({}, rest, {
              srcToken: srcToken,
              destToken: destToken,
              amount: takerAmountString,
              side: side,
              options: options
            }); // priceRoute
            _context.next = 11;
            return getSwapAndNFTOrderRate(rateInput, requestParams);
          case 11:
            optimalRate = _context.sent;
            return _context.abrupt("return", optimalRate);
          case 13:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function getNFTOrdersRate(_x, _x2, _x3) {
      return _ref3.apply(this, arguments);
    };
  }();
  // derive srcToken, destToken and srcAmount from orders[]
  var buildNFTOrderTx = function buildNFTOrderTx(params, options, requestParams) {
    var _checkAndParseOrders2 = checkAndParseOrders(params.orders),
      takerAsset = _checkAndParseOrders2.takerAsset,
      totalTakerAmount = _checkAndParseOrders2.totalTakerAmount;
    var fillParams = _extends({}, params, {
      // taker supplies takerAsset
      srcToken: takerAsset,
      srcAmount: totalTakerAmount.toString(10),
      // taker gets makerAsset in the end
      destToken: 'NFT' // support any NFT
    });
    return buildSwapTx(fillParams, options, requestParams);
  };
  var buildSwapAndNFTOrderTx = function buildSwapAndNFTOrderTx(params, options, requestParams) {
    checkAndParseOrders(params.orders);
    var fillParams = _extends({}, params, {
      // taker supplies srcToken
      srcToken: params.priceRoute.srcToken
    }, params.slippage ? {
      slippage: params.slippage
    } :
    //                                        may sneak in as part of `params`
    {
      srcAmount: params.priceRoute.srcAmount,
      slippage: undefined
    }, {
      destToken: 'NFT',
      // support any NFT,
      destDecimals: params.priceRoute.destDecimals
    });
    return buildSwapTx(fillParams, options, requestParams);
  };
  return {
    getNFTOrdersRate: getNFTOrdersRate,
    buildNFTOrderTx: buildNFTOrderTx,
    buildSwapAndNFTOrderTx: buildSwapAndNFTOrderTx
  };
};
function checkAndParseOrders(orders) {
  tsEssentials.assert(isFilledArray(orders), 'must pass at least 1 order');
  var _orders$reduce = orders.reduce(function (accum, order) {
      accum.takerAssetsSet.add(order.takerAsset.toLowerCase());
      accum.makerAssetsSet.add(order.makerAsset.toLowerCase());
      accum.totalTakerAmount = accum.totalTakerAmount + BigInt(order.takerAmount);
      return accum;
    }, {
      takerAssetsSet: new Set(),
      makerAssetsSet: new Set(),
      totalTakerAmount: BigInt(0)
    }),
    takerAssetsSet = _orders$reduce.takerAssetsSet,
    makerAssetsSet = _orders$reduce.makerAssetsSet,
    totalTakerAmount = _orders$reduce.totalTakerAmount;
  tsEssentials.assert(takerAssetsSet.size === 1, 'All orders must have the same takerAsset as destToken');
  tsEssentials.assert(makerAssetsSet.size === 1, 'All orders must have the same makerAsset');
  var _orders$ = orders[0],
    maker = _orders$.maker,
    taker = _orders$.taker,
    makerAsset = _orders$.makerAsset,
    takerAsset = _orders$.takerAsset;
  return {
    totalTakerAmount: totalTakerAmount,
    maker: maker,
    taker: taker,
    makerAsset: makerAsset.startsWith('0x') ? makerAsset : uintToAssetAddress(makerAsset),
    takerAsset: takerAsset.startsWith('0x') ? takerAsset : uintToAssetAddress(takerAsset)
  };
}
// extract asset address from makerAsset or takerAsset packed number encoded to contain AssetType
function uintToAssetAddress(assetUint) {
  return '0x' + (BigInt(assetUint) & (BigInt(1) << BigInt(160)) - BigInt(1)).toString(16);
}

var _excluded$4 = ["requestParams"];
var constructFetcher$2 = function constructFetcher(axios, extra) {
  return /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(params) {
      var requestParams, rest, headers, allParams, _yield$axios$request, data;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            requestParams = params.requestParams, rest = _objectWithoutPropertiesLoose(params, _excluded$4); // adding apiKey to headers if it's provided
            headers = extra != null && extra.apiKey ? _extends({
              'X-API-KEY': extra.apiKey
            }, rest.headers, requestParams == null ? void 0 : requestParams.headers) : _extends({}, rest.headers, requestParams == null ? void 0 : requestParams.headers);
            allParams = _extends({}, rest, requestParams, {
              headers: headers
            });
            _context.next = 6;
            return axios.request(allParams);
          case 6:
            _yield$axios$request = _context.sent;
            data = _yield$axios$request.data;
            return _context.abrupt("return", data);
          case 11:
            _context.prev = 11;
            _context.t0 = _context["catch"](0);
            if (!axios.isAxiosError(_context.t0)) {
              _context.next = 15;
              break;
            }
            throw new FetcherError(_context.t0);
          case 15:
            throw _context.t0;
          case 16:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[0, 11]]);
    }));
    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }();
};

var constructFetcher$1 = function constructFetcher(fetch, extra) {
  return /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(params) {
      var url, method, requestParams, body, POSTheaders, apiHeaders, headers, response, data;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            url = params.url, method = params.method, requestParams = params.requestParams;
            body = method === 'POST' ? JSON.stringify(params.data) : null; // Only JSON response for POST requests
            POSTheaders = method === 'POST' && body ? {
              'Content-Type': 'application/json'
            } : undefined; // adding apiKey to headers if it's provided
            apiHeaders = extra != null && extra.apiKey ? {
              'X-API-KEY': extra.apiKey
            } : undefined; // all headers combined
            headers = POSTheaders || apiHeaders || params.headers || requestParams != null && requestParams.headers ? _extends({}, apiHeaders, POSTheaders, params.headers, requestParams == null ? void 0 : requestParams.headers) : undefined;
            _context.next = 8;
            return fetch(url, _extends({
              method: method,
              body: body
            }, requestParams, {
              headers: headers
            }));
          case 8:
            response = _context.sent;
            _context.next = 11;
            return response.json();
          case 11:
            data = _context.sent;
            if (response.ok) {
              _context.next = 14;
              break;
            }
            throw new FetcherError({
              code: String(response.status),
              response: {
                data: data,
                status: response.status,
                statusText: response.statusText,
                headers: Object.fromEntries(response.headers.entries()),
                config: {
                  url: url,
                  method: method
                }
              },
              message: response.statusText,
              isAxiosError: false
            });
          case 14:
            return _context.abrupt("return", data);
          case 17:
            _context.prev = 17;
            _context.t0 = _context["catch"](0);
            if (!(_context.t0 instanceof FetcherError)) {
              _context.next = 21;
              break;
            }
            throw _context.t0;
          case 21:
            throw new FetcherError(_context.t0);
          case 22:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[0, 17]]);
    }));
    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }();
};

var _excluded$3 = ["block", "gas"],
  _excluded2$2 = ["gas", "from"];
var constructEthersV5ContractCaller = function constructEthersV5ContractCaller(_ref, account) {
  var providerOrSigner = _ref.ethersProviderOrSigner,
    Contract = _ref.EthersContract;
  var staticCall = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(params) {
      var _contract$callStatic;
      var address, abi, contractMethod, args, overrides, contract, block, gas, restOverrides, normalizedOverrides, callOverrides;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            address = params.address, abi = params.abi, contractMethod = params.contractMethod, args = params.args, overrides = params.overrides;
            contract = new Contract(address, abi, providerOrSigner);
            assertEthersContractHasMethodsV5(contract, contractMethod);
            // drop keys not in CallOverrides
            block = overrides.block, gas = overrides.gas, restOverrides = _objectWithoutPropertiesLoose(overrides, _excluded$3); // reassign values to keys in CallOverrides
            normalizedOverrides = _extends({}, restOverrides, {
              blockTag: block,
              gasLimit: gas
            }); // enforce overrides shape ethers accepts
            // TS will break if normalizedOverrides type has any keys not also present in CallOverrides
            callOverrides = normalizedOverrides; // returns whatever the Contract.method returns: BigNumber, string, boolean
            return _context.abrupt("return", (_contract$callStatic = contract.callStatic)[contractMethod].apply(_contract$callStatic, args.concat([callOverrides])));
          case 7:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function staticCall(_x) {
      return _ref2.apply(this, arguments);
    };
  }();
  var transactCall = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(params) {
      var address, abi, contractMethod, args, overrides, signer, contract, gas, restOverrides, normalizedOverrides, txOverrides, txResponse;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            tsEssentials.assert(account, 'account must be specified to create a signer');
            tsEssentials.assert(isEthersProviderWithSigner$1(providerOrSigner) || isEthersSigner$1(providerOrSigner), 'ethers must be an instance of Signer or JsonRpcProvider to create a signer');
            address = params.address, abi = params.abi, contractMethod = params.contractMethod, args = params.args, overrides = params.overrides;
            signer = 'getSigner' in providerOrSigner ? providerOrSigner.getSigner(account) : providerOrSigner;
            contract = new Contract(address, abi, signer);
            assertEthersContractHasMethodsV5(contract, contractMethod);
            // drop keys not in PayableOverrides
            gas = overrides.gas, restOverrides = _objectWithoutPropertiesLoose(overrides, _excluded2$2); // reassign values to keys in PayableOverrides
            normalizedOverrides = _extends({}, restOverrides, {
              gasLimit: gas
            }); // enforce overrides shape ethers accepts
            // TS will break if normalizedOverrides type has any keys not also present in PayableOverrides
            txOverrides = normalizedOverrides;
            _context2.next = 11;
            return contract[contractMethod].apply(contract, args.concat([txOverrides]));
          case 11:
            txResponse = _context2.sent;
            return _context2.abrupt("return", txResponse);
          case 13:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return function transactCall(_x2) {
      return _ref3.apply(this, arguments);
    };
  }();
  var signTypedDataCall = /*#__PURE__*/function () {
    var _ref4 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(typedData) {
      var signer, data, domain, types;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            tsEssentials.assert(account, 'account must be specified to create a signer');
            tsEssentials.assert(isEthersProviderWithSigner$1(providerOrSigner) || isEthersSigner$1(providerOrSigner), 'ethers must be an instance of Signer or JsonRpcProvider to create a signer');
            signer = 'getSigner' in providerOrSigner ? providerOrSigner.getSigner(account) : providerOrSigner;
            tsEssentials.assert(isTypedDataCapableSigner(signer), 'Signer can sign typed data');
            data = typedData.data, domain = typedData.domain, types = typedData.types;
            return _context3.abrupt("return", signer._signTypedData(domain, types, data));
          case 6:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    return function signTypedDataCall(_x3) {
      return _ref4.apply(this, arguments);
    };
  }();
  return {
    staticCall: staticCall,
    transactCall: transactCall,
    signTypedDataCall: signTypedDataCall
  };
};
function isEthersProvider(providerOrSigner) {
  return '_isProvider' in providerOrSigner && providerOrSigner._isProvider;
}
function isEthersProviderWithSigner$1(providerOrSigner) {
  return isEthersProvider(providerOrSigner) && 'getSigner' in providerOrSigner;
}
function isEthersSigner$1(providerOrSigner) {
  return '_isSigner' in providerOrSigner && providerOrSigner._isSigner;
}
function isTypedDataCapableSigner(signer) {
  return '_signTypedData' in signer;
}
function ethersContractHasMethodsV5(contract) {
  for (var _len = arguments.length, methods = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    methods[_key - 1] = arguments[_key];
  }
  return methods.every(function (method) {
    return typeof contract[method] === 'function';
  });
}
function assertEthersContractHasMethodsV5(contract) {
  for (var _len2 = arguments.length, methods = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    methods[_key2 - 1] = arguments[_key2];
  }
  tsEssentials.assert(ethersContractHasMethodsV5.apply(void 0, [contract].concat(methods)), "Contract must have methods: " + methods.join(', '));
}

var _excluded$2 = ["block", "gas"],
  _excluded2$1 = ["gas", "from"];
var constructContractCaller$2 = function constructContractCaller(_ref, account) {
  var providerOrSigner = _ref.ethersV6ProviderOrSigner,
    Contract = _ref.EthersV6Contract;
  var staticCall = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(params) {
      var address, abi, contractMethod, args, overrides, contract, block, gas, restOverrides, normalizedOverrides, callableContractFunction;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            address = params.address, abi = params.abi, contractMethod = params.contractMethod, args = params.args, overrides = params.overrides;
            contract = new Contract(address, abi, providerOrSigner); // drop keys not in CallOverrides
            block = overrides.block, gas = overrides.gas, restOverrides = _objectWithoutPropertiesLoose(overrides, _excluded$2); // reassign values to keys in CallOverrides
            normalizedOverrides = _extends({}, restOverrides, {
              blockTag: block,
              gasLimit: gas
            });
            callableContractFunction = contract.getFunction(contractMethod); // returns whatever the Contract["method"].staticCall returns: BigNumber, string, boolean
            return _context.abrupt("return", callableContractFunction.staticCall.apply(callableContractFunction, args.concat([normalizedOverrides])));
          case 6:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function staticCall(_x) {
      return _ref2.apply(this, arguments);
    };
  }();
  var transactCall = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(params) {
      var address, abi, contractMethod, args, overrides, signer, contract, gas, restOverrides, normalizedOverrides, callableContractFunction, txResponse;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            tsEssentials.assert(account, 'account must be specified to create a signer');
            tsEssentials.assert(isEthersProviderWithSigner(providerOrSigner) || isEthersSigner(providerOrSigner), 'ethers must be an instance of Signer or JsonRpcProvider to create a signer');
            address = params.address, abi = params.abi, contractMethod = params.contractMethod, args = params.args, overrides = params.overrides;
            if (!('getSigner' in providerOrSigner)) {
              _context2.next = 9;
              break;
            }
            _context2.next = 6;
            return providerOrSigner.getSigner(account);
          case 6:
            _context2.t0 = _context2.sent;
            _context2.next = 10;
            break;
          case 9:
            _context2.t0 = providerOrSigner;
          case 10:
            signer = _context2.t0;
            contract = new Contract(address, abi, signer); // drop keys not in PayableOverrides
            gas = overrides.gas, restOverrides = _objectWithoutPropertiesLoose(overrides, _excluded2$1); // reassign values to keys in PayableOverrides
            normalizedOverrides = _extends({}, restOverrides, {
              gasLimit: gas
            }); // if no method for contractMethod, ethers will throw
            callableContractFunction = contract.getFunction(contractMethod);
            _context2.next = 17;
            return callableContractFunction.send.apply(callableContractFunction, args.concat([normalizedOverrides]));
          case 17:
            txResponse = _context2.sent;
            return _context2.abrupt("return", txResponse);
          case 19:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return function transactCall(_x2) {
      return _ref3.apply(this, arguments);
    };
  }();
  var signTypedDataCall = /*#__PURE__*/function () {
    var _ref4 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(typedData) {
      var signer, data, domain, types;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            tsEssentials.assert(account, 'account must be specified to create a signer');
            tsEssentials.assert(isEthersProviderWithSigner(providerOrSigner) || isEthersSigner(providerOrSigner), 'ethers must be an instance of Signer or JsonRpcProvider to create a signer');
            if (!('getSigner' in providerOrSigner)) {
              _context3.next = 8;
              break;
            }
            _context3.next = 5;
            return providerOrSigner.getSigner(account);
          case 5:
            _context3.t0 = _context3.sent;
            _context3.next = 9;
            break;
          case 8:
            _context3.t0 = providerOrSigner;
          case 9:
            signer = _context3.t0;
            data = typedData.data, domain = typedData.domain, types = typedData.types;
            return _context3.abrupt("return", signer.signTypedData(domain, types, data));
          case 12:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    return function signTypedDataCall(_x3) {
      return _ref4.apply(this, arguments);
    };
  }();
  return {
    staticCall: staticCall,
    transactCall: transactCall,
    signTypedDataCall: signTypedDataCall
  };
};
function isEthersProviderWithSigner(providerOrSigner) {
  return 'getSigner' in providerOrSigner;
}
function isEthersSigner(providerOrSigner) {
  return 'getAddress' in providerOrSigner;
}

// regex from @ethersproject/hash TypedDataEncoder.constructor
// may be overly strict, but reliable
var baseTypeRegex = /^([^\x5b]*)(\x5b|$)/;
function findPrimaryType(types) {
  var candidates = Object.keys(types);
  var candidatesSet = new Set(candidates);
  candidates.forEach(function (candidate) {
    var typedDataFields = types[candidate];
    if (!typedDataFields) return;
    typedDataFields.forEach(function (_ref) {
      var _type$match;
      var type = _ref.type;
      // Get the base type (drop any array specifiers)
      var baseType = (_type$match = type.match(baseTypeRegex)) == null ? void 0 : _type$match[1];
      if (!baseType) return;
      // if type was referred to as a child of another type, it can't be the primaryType
      candidatesSet["delete"](baseType);
    });
  });
  var _Array$from = Array.from(candidatesSet),
    primaryType = _Array$from[0];
  tsEssentials.assert(primaryType, "No primary type found in SignableTypedData types, " + JSON.stringify(types));
  return primaryType;
}

var _excluded$1 = ["block", "gas", "value"],
  _excluded2 = ["gas", "from", "value", "nonce"];
var constructContractCaller$1 = function constructContractCaller(web3, account) {
  var staticCall = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(params) {
      var _contract$methods;
      var address, abi, contractMethod, args, overrides, contract, gas, value, restOverrides, normalizedOverrides;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            tsEssentials.assert(web3.currentProvider, 'web3.currentProvider is not set');
            address = params.address, abi = params.abi, contractMethod = params.contractMethod, args = params.args, overrides = params.overrides;
            contract = new web3.eth.Contract(abi,
            // FIXME abi types ethers dependant
            address);
            assertWeb3ContractHasMethods(contract, contractMethod);
            gas = overrides.gas, value = overrides.value, restOverrides = _objectWithoutPropertiesLoose(overrides, _excluded$1);
            normalizedOverrides = _extends({}, restOverrides, {
              gas: gas == null ? void 0 : gas.toString(10),
              value: value == null ? void 0 : value.toString(10)
            });
            return _context.abrupt("return", (_contract$methods = contract.methods)[contractMethod].apply(_contract$methods, args).call(normalizedOverrides));
          case 7:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function staticCall(_x) {
      return _ref.apply(this, arguments);
    };
  }();
  var transactCall = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(params) {
      var _contract$methods2;
      var address, abi, contractMethod, args, overrides, contract, gas, from, value, nonce, restOverrides, _from, normalizedOverrides, preparedCall, promiEvent, unpromiEvent;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            tsEssentials.assert(web3.currentProvider, 'web3.currentProvider is not set');
            tsEssentials.assert(account, 'account must be specified to send transactions');
            address = params.address, abi = params.abi, contractMethod = params.contractMethod, args = params.args, overrides = params.overrides;
            contract = new web3.eth.Contract(abi,
            // FIXME
            address);
            assertWeb3ContractHasMethods(contract, contractMethod);
            gas = overrides.gas, from = overrides.from, value = overrides.value, nonce = overrides.nonce, restOverrides = _objectWithoutPropertiesLoose(overrides, _excluded2);
            _from = from || account;
            tsEssentials.assert(_from, 'from is required');
            normalizedOverrides = _extends({}, restOverrides, {
              from: _from,
              gas: gas == null ? void 0 : gas.toString(10),
              value: value == null ? void 0 : value.toString(10),
              nonce: nonce == null ? void 0 : nonce.toString(10)
            });
            preparedCall = (_contract$methods2 = contract.methods)[contractMethod].apply(_contract$methods2, args);
            promiEvent = preparedCall.send(normalizedOverrides); // can't just return promiEvent, because async function returns a Promise<PromiEvent>
            // and await Promise<PromiEvent> automatically awaits the value of PromiEvent,
            // that is await Promise<PromiEvent> = Awaited<PromiEvent> that doesn't have .on|once
            // so that functionality becomes lost
            // transactCall can be made sync, but approve has to be async to await getSpender()
            unpromiEvent = {
              on: promiEvent.on.bind(promiEvent),
              once: promiEvent.once.bind(promiEvent)
            };
            return _context2.abrupt("return", unpromiEvent);
          case 13:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return function transactCall(_x2) {
      return _ref2.apply(this, arguments);
    };
  }();
  var signTypedDataCall = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(typedData) {
      var data, domain, types, _typedData, signature;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            tsEssentials.assert(web3.currentProvider, 'web3.currentProvider is not set');
            tsEssentials.assert(account, 'account must be specified to sign data');
            data = typedData.data, domain = typedData.domain, types = typedData.types;
            _typedData = {
              types: _extends({
                EIP712Domain: [{
                  name: 'name',
                  type: 'string'
                }, {
                  name: 'version',
                  type: 'string'
                }, {
                  name: 'chainId',
                  type: 'uint256'
                }, {
                  name: 'verifyingContract',
                  type: 'address'
                }]
              }, types),
              primaryType: findPrimaryType(types),
              domain: domain,
              message: data
            }; // account must be among unlocked accounts
            _context3.next = 6;
            return web3.eth.signTypedData(account, _typedData);
          case 6:
            signature = _context3.sent;
            return _context3.abrupt("return", signature);
          case 8:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    return function signTypedDataCall(_x3) {
      return _ref3.apply(this, arguments);
    };
  }();
  return {
    staticCall: staticCall,
    transactCall: transactCall,
    signTypedDataCall: signTypedDataCall
  };
};
function web3ContractHasMethods(contract) {
  for (var _len = arguments.length, methods = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    methods[_key - 1] = arguments[_key];
  }
  return methods.every(function (method) {
    return typeof contract.methods[method] === 'function';
  });
}
function assertWeb3ContractHasMethods(contract) {
  for (var _len2 = arguments.length, methods = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    methods[_key2 - 1] = arguments[_key2];
  }
  tsEssentials.assert(web3ContractHasMethods.apply(void 0, [contract].concat(methods)), "Contract must have methods: " + methods.join(', '));
}

var constructContractCaller = function constructContractCaller(viemClient, account) {
  var staticCall = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(params) {
      var address, abi, contractMethod, args, overrides, block, _ref2, blockNumber, blockTag, result;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            tsEssentials.assert(viemClient.readContract, 'Viem client must have readContract Public Action');
            address = params.address, abi = params.abi, contractMethod = params.contractMethod, args = params.args, overrides = params.overrides;
            block = overrides.block;
            _ref2 = typeof block === 'number' ? {
              blockNumber: BigInt(block)
            } : {
              blockTag: block
            }, blockNumber = _ref2.blockNumber, blockTag = _ref2.blockTag;
            result = viemClient.readContract({
              account: viemClient.account || account,
              address: address,
              abi: abi,
              functionName: contractMethod,
              args: args,
              blockTag: blockTag,
              blockNumber: blockNumber
            });
            return _context.abrupt("return", result);
          case 6:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function staticCall(_x) {
      return _ref.apply(this, arguments);
    };
  }();
  var transactCall = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(params) {
      var _overrides$gas, _overrides$value;
      var address, abi, contractMethod, args, overrides, viemTxParams, gasPriceParams, txHash;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            tsEssentials.assert(account, 'account must be specified sign transactions');
            tsEssentials.assert(viemClient.writeContract, 'Viem client must have writeContract Wallet Action');
            address = params.address, abi = params.abi, contractMethod = params.contractMethod, args = params.args, overrides = params.overrides;
            viemTxParams = txParamsToViemTxParams(_extends({}, overrides, {
              to: address,
              gas: (_overrides$gas = overrides.gas) == null ? void 0 : _overrides$gas.toString(10),
              value: (_overrides$value = overrides.value) == null ? void 0 : _overrides$value.toString(10)
            }));
            gasPriceParams = 'maxFeePerGas' in viemTxParams ? {
              maxFeePerGas: viemTxParams.maxFeePerGas,
              maxPriorityFeePerGas: viemTxParams.maxPriorityFeePerGas
            } : 'gasPrice' in viemTxParams ? {
              gasPrice: viemTxParams.gasPrice
            } : {};
            _context2.next = 7;
            return viemClient.writeContract(_extends({
              // either `viemClient` has account assigned to it,
              // or the provider `viemClient` was created with must control `account` (viemClient.getAddresses()[0]===account);
              // otherwise breaks with ` ProviderError: Unknown account 0x...`
              account: viemClient.account || account,
              address: address,
              abi: abi,
              functionName: contractMethod,
              args: argsToViemArgs(args),
              value: viemTxParams.value,
              gas: viemTxParams.gas,
              // ...viemTxParams,
              // account: (overrides.from || account) as Hex,
              nonce: overrides.nonce
            }, gasPriceParams));
          case 7:
            txHash = _context2.sent;
            return _context2.abrupt("return", txHash);
          case 9:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return function transactCall(_x2) {
      return _ref3.apply(this, arguments);
    };
  }();
  var signTypedDataCall = /*#__PURE__*/function () {
    var _ref4 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(typedData) {
      var data, domain, types, primaryType, chainId, viemDomain, signature;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            tsEssentials.assert(account, 'account must be specified to create a signer');
            tsEssentials.assert(viemClient.signTypedData, 'Viem client must have signTypedData Wallet Action');
            data = typedData.data, domain = typedData.domain, types = typedData.types;
            primaryType = findPrimaryType(types);
            chainId = domain.chainId === undefined ? undefined : Number(domain.chainId);
            viemDomain = {
              chainId: chainId,
              name: domain.name,
              version: domain.version,
              verifyingContract: domain.verifyingContract,
              salt: domain.salt
            };
            _context3.next = 8;
            return viemClient.signTypedData({
              // either `viemClient` has account assigned to it,
              // or the provider `viemClient` was created with must control `account` (viemClient.getAddresses()[0]===account)
              account: viemClient.account || account,
              domain: viemDomain,
              types: types,
              primaryType: primaryType,
              message: data
            });
          case 8:
            signature = _context3.sent;
            return _context3.abrupt("return", signature);
          case 10:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    return function signTypedDataCall(_x3) {
      return _ref4.apply(this, arguments);
    };
  }();
  return {
    staticCall: staticCall,
    transactCall: transactCall,
    signTypedDataCall: signTypedDataCall
  };
};
function txParamsToViemTxParams(txParams) {
  var gas = txParams.gas !== undefined ? BigInt(txParams.gas) : undefined;
  var gasPrice = txParams.gasPrice !== undefined ? BigInt(txParams.gasPrice) : undefined;
  var maxFeePerGas = txParams.maxFeePerGas !== undefined ? BigInt(txParams.maxFeePerGas) : undefined;
  var maxPriorityFeePerGas = txParams.maxPriorityFeePerGas !== undefined ? BigInt(txParams.maxPriorityFeePerGas) : undefined;
  var viemTxParams = _extends({
    to: txParams.to,
    data: txParams.data,
    value: txParams.value !== undefined ? BigInt(txParams.value) : undefined,
    gas: gas
  }, txParams.maxFeePerGas !== undefined ? {
    maxFeePerGas: maxFeePerGas,
    maxPriorityFeePerGas: maxPriorityFeePerGas
  } : {
    gasPrice: gasPrice
  });
  return viemTxParams;
}
function argsToViemArgs(args) {
  return args.map(function (arg) {
    if (typeof arg === 'string') {
      if (arg.startsWith('0x')) {
        return arg;
      }
      var asNumber = Number(arg);
      if (Number.isNaN(asNumber)) {
        return arg;
      }
      return BigInt(asNumber);
    }
    return arg;
  });
}

var constructGetDeltaContract = function constructGetDeltaContract(options) {
  // analogous to getSpender() but for Delta Orders Contract = ParaswapDelta
  var _constructGetSpender = constructGetSpender(options),
    getContracts = _constructGetSpender.getContracts;
  var getDeltaContract = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(requestParams) {
      var _yield$getContracts, ParaswapDelta;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return getContracts(requestParams);
          case 2:
            _yield$getContracts = _context.sent;
            ParaswapDelta = _yield$getContracts.ParaswapDelta;
            return _context.abrupt("return", ParaswapDelta || null);
          case 5:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function getDeltaContract(_x) {
      return _ref.apply(this, arguments);
    };
  }();
  return {
    getDeltaContract: getDeltaContract
  };
};

var constructGetPartnerFee = function constructGetPartnerFee(_ref) {
  var _ref$apiURL = _ref.apiURL,
    apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL,
    chainId = _ref.chainId,
    fetcher = _ref.fetcher;
  var partnerFeeUrl = apiURL + "/prices/partnerfee/" + chainId;
  // going on the assumption that one `partner` will correspond to one `partnerFee` during the lifetime of SDK instance,
  // to avoid unnecessary network requests
  var cachedPartnerFee = new Map();
  var getPartnerFee = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(options, requestParams) {
      var search, fetchURL, data;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (!cachedPartnerFee.has(options.partner)) {
              _context.next = 2;
              break;
            }
            return _context.abrupt("return", cachedPartnerFee.get(options.partner));
          case 2:
            search = constructSearchString(options);
            fetchURL = partnerFeeUrl + "/" + search;
            _context.next = 6;
            return fetcher({
              url: fetchURL,
              method: 'GET',
              requestParams: requestParams
            });
          case 6:
            data = _context.sent;
            cachedPartnerFee.set(options.partner, data);
            return _context.abrupt("return", data);
          case 9:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function getPartnerFee(_x, _x2) {
      return _ref2.apply(this, arguments);
    };
  }();
  return {
    getPartnerFee: getPartnerFee
  };
};

// Order(address owner,address beneficiary,address srcToken,address destToken,uint256 srcAmount,uint256 destAmount,uint256 deadline,uint256 nonce,bytes permit, bridge Bridge)";
var SWAP_ORDER_EIP_712_TYPES = {
  Order: [{
    name: 'owner',
    type: 'address'
  }, {
    name: 'beneficiary',
    type: 'address'
  }, {
    name: 'srcToken',
    type: 'address'
  }, {
    name: 'destToken',
    type: 'address'
  }, {
    name: 'srcAmount',
    type: 'uint256'
  }, {
    name: 'destAmount',
    type: 'uint256'
  }, {
    name: 'expectedAmount',
    type: 'uint256'
  }, {
    name: 'deadline',
    type: 'uint256'
  }, {
    name: 'kind',
    type: 'uint8'
  }, {
    name: 'nonce',
    type: 'uint256'
  }, {
    name: 'partnerAndFee',
    type: 'uint256'
  }, {
    name: 'permit',
    type: 'bytes'
  }, {
    name: 'metadata',
    type: 'bytes'
  }, {
    name: 'bridge',
    type: 'Bridge'
  }],
  Bridge: [{
    name: 'protocolSelector',
    type: 'bytes4'
  }, {
    name: 'destinationChainId',
    type: 'uint256'
  }, {
    name: 'outputToken',
    type: 'address'
  }, {
    name: 'scalingFactor',
    type: 'int8'
  }, {
    name: 'protocolData',
    type: 'bytes'
  }]
};
function produceDeltaOrderTypedData(_ref) {
  var orderInput = _ref.orderInput,
    chainId = _ref.chainId,
    paraswapDeltaAddress = _ref.paraswapDeltaAddress;
  var typedData = {
    types: {
      Order: SWAP_ORDER_EIP_712_TYPES.Order,
      Bridge: SWAP_ORDER_EIP_712_TYPES.Bridge
    },
    domain: {
      name: 'Portikus',
      version: '2.0.0',
      chainId: chainId,
      verifyingContract: paraswapDeltaAddress
    },
    data: orderInput
  };
  return typedData;
}
// default deadline = 1 hour for now (may be changed later)
var DELTA_DEFAULT_EXPIRY = 60 * 60; // seconds
function buildDeltaSignableOrderData(_ref2) {
  var owner = _ref2.owner,
    _ref2$beneficiary = _ref2.beneficiary,
    beneficiary = _ref2$beneficiary === void 0 ? owner : _ref2$beneficiary,
    srcToken = _ref2.srcToken,
    destToken = _ref2.destToken,
    srcAmount = _ref2.srcAmount,
    destAmount = _ref2.destAmount,
    expectedAmount = _ref2.expectedAmount,
    _ref2$deadline = _ref2.deadline,
    deadline = _ref2$deadline === void 0 ? Math.floor(Date.now() / 1000 + DELTA_DEFAULT_EXPIRY) : _ref2$deadline,
    _ref2$nonce = _ref2.nonce,
    nonce = _ref2$nonce === void 0 ? Date.now().toString(10) : _ref2$nonce,
    _ref2$permit = _ref2.permit,
    permit = _ref2$permit === void 0 ? '0x' : _ref2$permit,
    kind = _ref2.kind,
    _ref2$metadata = _ref2.metadata,
    metadata = _ref2$metadata === void 0 ? '0x' : _ref2$metadata,
    partnerAddress = _ref2.partnerAddress,
    partnerFeeBps = _ref2.partnerFeeBps,
    _ref2$partnerTakesSur = _ref2.partnerTakesSurplus,
    partnerTakesSurplus = _ref2$partnerTakesSur === void 0 ? false : _ref2$partnerTakesSur,
    chainId = _ref2.chainId,
    paraswapDeltaAddress = _ref2.paraswapDeltaAddress,
    bridge = _ref2.bridge;
  var orderInput = {
    owner: owner,
    beneficiary: beneficiary,
    srcToken: srcToken,
    destToken: destToken,
    srcAmount: srcAmount,
    destAmount: destAmount,
    expectedAmount: expectedAmount,
    deadline: deadline,
    nonce: nonce,
    permit: permit,
    partnerAndFee: producePartnerAndFee({
      partnerFeeBps: partnerFeeBps,
      partnerAddress: partnerAddress,
      partnerTakesSurplus: partnerTakesSurplus
    }),
    bridge: bridge,
    kind: kind,
    metadata: metadata
  };
  return produceDeltaOrderTypedData({
    orderInput: orderInput,
    chainId: chainId,
    paraswapDeltaAddress: paraswapDeltaAddress
  });
}
// fee and address are encoded together
function producePartnerAndFee(_ref3) {
  var partnerFeeBps = _ref3.partnerFeeBps,
    partnerAddress = _ref3.partnerAddress,
    partnerTakesSurplus = _ref3.partnerTakesSurplus;
  if (partnerAddress === ZERO_ADDRESS) return '0';
  var partnerAndFee = BigInt(partnerAddress) << BigInt(96) | BigInt(partnerFeeBps.toFixed(0)) | BigInt(partnerTakesSurplus) << BigInt(8);
  return partnerAndFee.toString(10);
}

var _SwapSideToOrderKind;
var OrderKind;
(function (OrderKind) {
  OrderKind[OrderKind["Sell"] = 0] = "Sell";
  OrderKind[OrderKind["Buy"] = 1] = "Buy";
})(OrderKind || (OrderKind = {}));
var SwapSideToOrderKind = (_SwapSideToOrderKind = {}, _SwapSideToOrderKind[core.SwapSide.SELL] = OrderKind.Sell, _SwapSideToOrderKind[core.SwapSide.BUY] = OrderKind.Buy, _SwapSideToOrderKind);

var constructBuildDeltaOrder = function constructBuildDeltaOrder(options) {
  var chainId = options.chainId;
  // cached internally
  var _constructGetDeltaCon = constructGetDeltaContract(options),
    getDeltaContract = _constructGetDeltaCon.getDeltaContract;
  // cached internally for `partner`
  var _constructGetPartnerF = constructGetPartnerFee(options),
    getPartnerFee = _constructGetPartnerF.getPartnerFee;
  var buildDeltaOrder = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(options, requestParams) {
      var _options$partnerFeeBp, _options$side, _options$nonce;
      var ParaswapDelta, partnerAddress, partnerFeeBps, partnerTakesSurplus, feeOrTakeSurplusSupplied, _partnerAddress, _partnerFeeBps, _partnerTakesSurplus, partner, partnerFeeResponse, swapSide, expectedAmount, input;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return getDeltaContract(requestParams);
          case 2:
            ParaswapDelta = _context.sent;
            if (ParaswapDelta) {
              _context.next = 5;
              break;
            }
            throw new Error("Delta is not available on chain " + chainId);
          case 5:
            ////// Partner logic //////
            // externally supplied partner fee data takes precedence
            partnerAddress = options.partnerAddress;
            partnerFeeBps = (_options$partnerFeeBp = options.partnerFeeBps) != null ? _options$partnerFeeBp : options.deltaPrice.partnerFee * 100;
            partnerTakesSurplus = options.partnerTakesSurplus; // if fee given, takeSurplus is ignored
            feeOrTakeSurplusSupplied = partnerFeeBps !== undefined || partnerTakesSurplus !== undefined;
            if (!(partnerAddress === undefined || feeOrTakeSurplusSupplied)) {
              _context.next = 17;
              break;
            }
            partner = options.partner || options.deltaPrice.partner;
            _context.next = 13;
            return getPartnerFee({
              partner: partner
            }, requestParams);
          case 13:
            partnerFeeResponse = _context.sent;
            partnerAddress = (_partnerAddress = partnerAddress) != null ? _partnerAddress : partnerFeeResponse.partnerAddress;
            // deltaPrice.partnerFee and partnerFeeResponse.partnerFee should be the same, but give priority to externally provided
            partnerFeeBps = (_partnerFeeBps = partnerFeeBps) != null ? _partnerFeeBps : partnerFeeResponse.partnerFee;
            partnerTakesSurplus = (_partnerTakesSurplus = partnerTakesSurplus) != null ? _partnerTakesSurplus : partnerFeeResponse.takeSurplus;
          case 17:
            swapSide = (_options$side = options.side) != null ? _options$side : core.SwapSide.SELL;
            expectedAmount = swapSide === core.SwapSide.SELL ? options.deltaPrice.destAmount : options.deltaPrice.srcAmount;
            input = {
              owner: options.owner,
              beneficiary: options.beneficiary,
              srcToken: options.srcToken,
              // for some cases of WETH->ETH crosschain swaps, the destToken is changed to WETH or ETH,
              // this is already reflected in deltaPrice
              destToken: options.deltaPrice.destToken,
              srcAmount: options.srcAmount,
              destAmount: options.destAmount,
              expectedAmount: expectedAmount,
              deadline: options.deadline,
              nonce: (_options$nonce = options.nonce) == null ? void 0 : _options$nonce.toString(10),
              permit: options.permit,
              kind: SwapSideToOrderKind[swapSide],
              metadata: options.metadata,
              chainId: chainId,
              paraswapDeltaAddress: ParaswapDelta,
              partnerAddress: partnerAddress,
              partnerTakesSurplus: partnerTakesSurplus,
              partnerFeeBps: partnerFeeBps,
              bridge: options.deltaPrice.bridge // ZERO_BRIDGE for same-chain Orders
            };
            return _context.abrupt("return", buildDeltaSignableOrderData(input));
          case 21:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function buildDeltaOrder(_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }();
  return {
    buildDeltaOrder: buildDeltaOrder
  };
};

var constructBuildCrosschainOrderBridge = function constructBuildCrosschainOrderBridge(options) {
  var chainId = options.chainId;
  // cached internally for `multicall` contracts
  // const { getMulticallHandlers } = constructGetMulticallHandlers(options);
  var buildCrosschainOrderBridge = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref, requestParams) {
      var destChainId, deltaPrice, bridge;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            destChainId = _ref.destChainId, deltaPrice = _ref.deltaPrice;
            tsEssentials.assert(chainId !== deltaPrice.bridge.destinationChainId, '`deltaPrice.bridge.destinationChainId` must be different from `chainId` for crosschain Order.bridge');
            tsEssentials.assert(destChainId === deltaPrice.bridge.destinationChainId, '`destChainId` must match `deltaPrice.bridge.destinationChainId` for crosschain Order.bridge');
            /* const getMulticallHandler = async (chainId: number) => {
              const multicallHandlersMap = await getMulticallHandlers(requestParams);
              const multicallHandler = multicallHandlersMap[chainId];
                   assert(
                multicallHandler,
                `Multicall handler not found for chain ${chainId}`
              );
                   return multicallHandler;
            };
                 const { bridge } = await getDeltaBridge({
              destTokenDestChain: destToken,
              destChainId,
              bridgeFee: deltaPrice.bridgeFee,
              bridgeOutputToken: deltaPrice.bridge.outputToken,
              beneficiaryType,
              getMulticallHandler,
            }); */
            // @TODO remove the whole buildCrosschainOrderBridge() when API provides BridgePrice.bridge = whole Bridge object
            bridge = {
              protocolSelector: '0x00000000',
              scalingFactor: 0,
              protocolData: '0x',
              destinationChainId: deltaPrice.bridge.destinationChainId,
              outputToken: deltaPrice.bridge.outputToken
            };
            return _context.abrupt("return", {
              bridge: bridge
            });
          case 5:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function buildCrosschainOrderBridge(_x, _x2) {
      return _ref2.apply(this, arguments);
    };
  }();
  return {
    buildCrosschainOrderBridge: buildCrosschainOrderBridge
  };
};

var constructPostDeltaOrder = function constructPostDeltaOrder(_ref) {
  var _ref$apiURL = _ref.apiURL,
    apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL,
    chainId = _ref.chainId,
    fetcher = _ref.fetcher;
  var postOrderUrl = apiURL + "/delta/orders";
  var postDeltaOrder = function postDeltaOrder(postData, requestParams) {
    var deltaOrderToPost = _extends({}, postData, {
      chainId: chainId
    });
    return fetcher({
      url: postOrderUrl,
      method: 'POST',
      data: deltaOrderToPost,
      requestParams: requestParams
    });
  };
  return {
    postDeltaOrder: postDeltaOrder
  };
};

function sanitizeDeltaOrderData(_ref) {
  var owner = _ref.owner,
    beneficiary = _ref.beneficiary,
    srcToken = _ref.srcToken,
    destToken = _ref.destToken,
    srcAmount = _ref.srcAmount,
    destAmount = _ref.destAmount,
    expectedAmount = _ref.expectedAmount,
    deadline = _ref.deadline,
    nonce = _ref.nonce,
    permit = _ref.permit,
    partnerAndFee = _ref.partnerAndFee,
    bridge = _ref.bridge,
    kind = _ref.kind,
    metadata = _ref.metadata;
  return {
    owner: owner,
    beneficiary: beneficiary,
    srcToken: srcToken,
    destToken: destToken,
    srcAmount: srcAmount,
    destAmount: destAmount,
    expectedAmount: expectedAmount,
    deadline: deadline,
    nonce: nonce,
    permit: permit,
    partnerAndFee: partnerAndFee,
    bridge: bridge,
    kind: kind,
    metadata: metadata
  };
}

// returns whatever `contractCaller` returns
// to allow for better versatility
var constructSignDeltaOrder = function constructSignDeltaOrder(options) {
  var signDeltaOrder = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(typedData) {
      var typedDataOnly, signature;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            // types allow to pass OrderData & extra_stuff, but tx will break like that
            typedDataOnly = _extends({}, typedData, {
              data: sanitizeDeltaOrderData(typedData.data)
            });
            _context.next = 3;
            return options.contractCaller.signTypedDataCall(typedDataOnly);
          case 3:
            signature = _context.sent;
            return _context.abrupt("return", signature);
          case 5:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function signDeltaOrder(_x) {
      return _ref.apply(this, arguments);
    };
  }();
  return {
    signDeltaOrder: signDeltaOrder
  };
};

var _excluded = ["includeAgents", "excludeAgents"];
var constructGetDeltaPrice = function constructGetDeltaPrice(_ref) {
  var _ref$apiURL = _ref.apiURL,
    apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL,
    chainId = _ref.chainId,
    fetcher = _ref.fetcher;
  var pricesUrl = apiURL + "/delta/prices";
  function getDeltaPrice(_x, _x2) {
    return _getDeltaPrice.apply(this, arguments);
  }
  function _getDeltaPrice() {
    _getDeltaPrice = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(options, requestParams) {
      var _options$side;
      var includeAgents, excludeAgents, rest, includeAgentsString, excludeAgentsString, search, fetchURL, data;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            includeAgents = options.includeAgents, excludeAgents = options.excludeAgents, rest = _objectWithoutPropertiesLoose(options, _excluded);
            includeAgentsString = includeAgents ? includeAgents.join(',') : undefined;
            excludeAgentsString = excludeAgents ? excludeAgents.join(',') : undefined;
            search = constructSearchString(_extends({}, rest, {
              chainId: chainId,
              side: (_options$side = options.side) != null ? _options$side : core.SwapSide.SELL,
              includeAgents: includeAgentsString,
              excludeAgents: excludeAgentsString
            }));
            fetchURL = pricesUrl + "/" + search;
            _context.next = 7;
            return fetcher({
              url: fetchURL,
              method: 'GET',
              requestParams: requestParams
            });
          case 7:
            data = _context.sent;
            return _context.abrupt("return", data.price);
          case 9:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return _getDeltaPrice.apply(this, arguments);
  }
  return {
    getDeltaPrice: getDeltaPrice
  };
};

var constructGetDeltaOrders = function constructGetDeltaOrders(_ref) {
  var _ref$apiURL = _ref.apiURL,
    apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL,
    fetcher = _ref.fetcher,
    chainId = _ref.chainId;
  var baseUrl = apiURL + "/delta/orders";
  var getDeltaOrderById = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(orderId, requestParams) {
      var fetchURL, order;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            fetchURL = baseUrl + "/" + orderId;
            _context.next = 3;
            return fetcher({
              url: fetchURL,
              method: 'GET',
              requestParams: requestParams
            });
          case 3:
            order = _context.sent;
            return _context.abrupt("return", order);
          case 5:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function getDeltaOrderById(_x, _x2) {
      return _ref2.apply(this, arguments);
    };
  }();
  var getDeltaOrderByHash = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(orderHash, requestParams) {
      var fetchURL, order;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            fetchURL = baseUrl + "/hash/" + orderHash;
            _context2.next = 3;
            return fetcher({
              url: fetchURL,
              method: 'GET',
              requestParams: requestParams
            });
          case 3:
            order = _context2.sent;
            return _context2.abrupt("return", order);
          case 5:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return function getDeltaOrderByHash(_x3, _x4) {
      return _ref3.apply(this, arguments);
    };
  }();
  var getDeltaOrders = /*#__PURE__*/function () {
    var _ref4 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(options, requestParams) {
      var search, fetchURL, orders;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            search = constructSearchString({
              userAddress: options.userAddress,
              page: options.page,
              limit: options.limit,
              chainId: options.chainId,
              type: options.type
            });
            fetchURL = "" + baseUrl + search;
            _context3.next = 4;
            return fetcher({
              url: fetchURL,
              method: 'GET',
              requestParams: requestParams
            });
          case 4:
            orders = _context3.sent;
            return _context3.abrupt("return", orders);
          case 6:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    return function getDeltaOrders(_x5, _x6) {
      return _ref4.apply(this, arguments);
    };
  }();
  var getRequiredBalanceForDeltaLimitOrders = /*#__PURE__*/function () {
    var _ref5 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(userParams, requestParams) {
      var userURL, fetchURL, response;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            userURL = baseUrl + "/fillablebalance/" + chainId + "/" + userParams.userAddress;
            fetchURL = userParams.tokenAddress ? userURL + "/" + userParams.tokenAddress : userURL;
            _context4.next = 4;
            return fetcher({
              url: fetchURL,
              method: 'GET',
              requestParams: requestParams
            });
          case 4:
            response = _context4.sent;
            return _context4.abrupt("return", response);
          case 6:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }));
    return function getRequiredBalanceForDeltaLimitOrders(_x7, _x8) {
      return _ref5.apply(this, arguments);
    };
  }();
  return {
    getDeltaOrderById: getDeltaOrderById,
    getDeltaOrderByHash: getDeltaOrderByHash,
    getDeltaOrders: getDeltaOrders,
    getRequiredBalanceForDeltaLimitOrders: getRequiredBalanceForDeltaLimitOrders
  };
};

// returns whatever `contractCaller` returns
// to allow for better versatility
var constructApproveTokenForDelta = function constructApproveTokenForDelta(options) {
  // getDeltaContract is cached internally for the same instance of SDK
  // so should persist across same apiUrl & network
  var _constructGetDeltaCon = constructGetDeltaContract(options),
    getDeltaContract = _constructGetDeltaCon.getDeltaContract;
  var getParaswapDeltaAddress = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(requestParams) {
      var deltaContract;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return getDeltaContract(requestParams);
          case 2:
            deltaContract = _context.sent;
            if (deltaContract) {
              _context.next = 5;
              break;
            }
            throw new Error("Delta is not available on chain " + options.chainId);
          case 5:
            return _context.abrupt("return", deltaContract);
          case 6:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function getParaswapDeltaAddress(_x) {
      return _ref.apply(this, arguments);
    };
  }();
  var approveTokenForDelta = approveTokenMethodFactory(options.contractCaller, getParaswapDeltaAddress);
  return {
    approveTokenForDelta: approveTokenForDelta
  };
};

var constructGetBridgeInfo = function constructGetBridgeInfo(_ref) {
  var _ref$apiURL = _ref.apiURL,
    apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL,
    fetcher = _ref.fetcher;
  var bridgeInfoUrl = apiURL + "/delta/prices/bridge-info";
  var getBridgeInfo = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(requestParams) {
      var data;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return fetcher({
              url: bridgeInfoUrl,
              method: 'GET',
              requestParams: requestParams
            });
          case 2:
            data = _context.sent;
            return _context.abrupt("return", data.supportedTokens);
          case 4:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function getBridgeInfo(_x) {
      return _ref2.apply(this, arguments);
    };
  }();
  return {
    getBridgeInfo: getBridgeInfo
  };
};

var constructGetMulticallHandlers = function constructGetMulticallHandlers(_ref) {
  var _ref$apiURL = _ref.apiURL,
    apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL,
    fetcher = _ref.fetcher;
  var multicallHandlersUrl = apiURL + "/delta/prices/multicall-handlers";
  var _getMulticallHandlers = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(requestParams) {
      var data;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return fetcher({
              url: multicallHandlersUrl,
              method: 'GET',
              requestParams: requestParams
            });
          case 2:
            data = _context.sent;
            return _context.abrupt("return", data);
          case 4:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function _getMulticallHandlers(_x) {
      return _ref2.apply(this, arguments);
    };
  }();
  // cached for the same instance of `{getMulticallHandlers} = constructGetMulticallHandlers()`
  // so should persist across same apiUrl & network (and response is even network agnostic)
  var getMulticallHandlers = runOnceAndCache(_getMulticallHandlers);
  return {
    getMulticallHandlers: getMulticallHandlers
  };
};

var constructIsTokenSupportedInDelta = function constructIsTokenSupportedInDelta(_ref) {
  var _ref$apiURL = _ref.apiURL,
    apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL,
    chainId = _ref.chainId,
    fetcher = _ref.fetcher;
  var bridgeInfoUrl = apiURL + "/delta/prices/is-token-supported";
  var isTokenSupportedInDelta = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(token, requestParams) {
      var search, fetchURL, data;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            search = constructSearchString({
              token: token,
              chainId: chainId
            });
            fetchURL = bridgeInfoUrl + "/" + search;
            _context.next = 4;
            return fetcher({
              url: fetchURL,
              method: 'GET',
              requestParams: requestParams
            });
          case 4:
            data = _context.sent;
            return _context.abrupt("return", data.supported);
          case 6:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function isTokenSupportedInDelta(_x, _x2) {
      return _ref2.apply(this, arguments);
    };
  }();
  return {
    isTokenSupportedInDelta: isTokenSupportedInDelta
  };
};

var constructGetQuote = function constructGetQuote(_ref) {
  var _ref$apiURL = _ref.apiURL,
    apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL,
    chainId = _ref.chainId,
    fetcher = _ref.fetcher;
  var pricesUrl = apiURL + "/quote";
  function getQuote(_x, _x2) {
    return _getQuote.apply(this, arguments);
  }
  function _getQuote() {
    _getQuote = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(options, requestParams) {
      var _options$side;
      var search, fetchURL, data;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            search = constructSearchString(_extends({}, options, {
              chainId: chainId,
              side: (_options$side = options.side) != null ? _options$side : core.SwapSide.SELL
            }));
            fetchURL = pricesUrl + "/" + search;
            _context.next = 4;
            return fetcher({
              url: fetchURL,
              method: 'GET',
              requestParams: requestParams
            });
          case 4:
            data = _context.sent;
            return _context.abrupt("return", data);
          case 6:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return _getQuote.apply(this, arguments);
  }
  return {
    getQuote: getQuote
  };
};

var ORDER_CANCELLATIONS_EIP_712_TYPES = {
  OrderCancellations: [{
    name: 'orderIds',
    type: 'string[]'
  }]
};
function buildCancelDeltaOrderSignableData(_ref) {
  var orderInput = _ref.orderInput,
    chainId = _ref.chainId,
    paraswapDeltaAddress = _ref.paraswapDeltaAddress;
  var typedData = {
    types: {
      OrderCancellations: ORDER_CANCELLATIONS_EIP_712_TYPES.OrderCancellations
    },
    domain: {
      name: 'Portikus',
      version: '2.0.0',
      chainId: chainId,
      verifyingContract: paraswapDeltaAddress
    },
    data: {
      // explicityly pick only the necessary fields,
      // otherwise signing will break if more is present
      orderIds: orderInput.orderIds
    }
  };
  return typedData;
}

var constructCancelDeltaOrder = function constructCancelDeltaOrder(options) {
  // cached internally
  var _constructGetDeltaCon = constructGetDeltaContract(options),
    getDeltaContract = _constructGetDeltaCon.getDeltaContract;
  var signCancelLimitDeltaOrderRequest = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(params, requestParams) {
      var ParaswapDelta, typedData, signature;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return getDeltaContract(requestParams);
          case 2:
            ParaswapDelta = _context.sent;
            if (ParaswapDelta) {
              _context.next = 5;
              break;
            }
            throw new Error("Delta is not available on chain " + options.chainId);
          case 5:
            typedData = buildCancelDeltaOrderSignableData({
              orderInput: params,
              paraswapDeltaAddress: ParaswapDelta,
              chainId: options.chainId
            });
            _context.next = 8;
            return options.contractCaller.signTypedDataCall(typedData);
          case 8:
            signature = _context.sent;
            return _context.abrupt("return", signature);
          case 10:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function signCancelLimitDeltaOrderRequest(_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }();
  var postCancelLimitDeltaOrderRequest = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(params, requestParams) {
      var cancelUrl, res;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            cancelUrl = options.apiURL + "/delta/orders/cancel";
            _context2.next = 3;
            return options.fetcher({
              url: cancelUrl,
              method: 'POST',
              data: params,
              requestParams: requestParams
            });
          case 3:
            res = _context2.sent;
            return _context2.abrupt("return", res);
          case 5:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return function postCancelLimitDeltaOrderRequest(_x3, _x4) {
      return _ref2.apply(this, arguments);
    };
  }();
  var cancelLimitDeltaOrders = /*#__PURE__*/function () {
    var _ref4 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_ref3, requestParams) {
      var orderIds, signature, res;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            orderIds = _ref3.orderIds;
            _context3.next = 3;
            return signCancelLimitDeltaOrderRequest({
              orderIds: orderIds
            }, requestParams);
          case 3:
            signature = _context3.sent;
            _context3.next = 6;
            return postCancelLimitDeltaOrderRequest({
              orderIds: orderIds,
              signature: signature
            }, requestParams);
          case 6:
            res = _context3.sent;
            return _context3.abrupt("return", res);
          case 8:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    return function cancelLimitDeltaOrders(_x5, _x6) {
      return _ref4.apply(this, arguments);
    };
  }();
  return {
    signCancelLimitDeltaOrderRequest: signCancelLimitDeltaOrderRequest,
    postCancelLimitDeltaOrderRequest: postCancelLimitDeltaOrderRequest,
    cancelLimitDeltaOrders: cancelLimitDeltaOrders
  };
};

/** @description construct composable SDK with methods you choose yourself */
var constructPartialSDK = function constructPartialSDK(config) {
  var _config$apiURL, _config$version;
  for (var _len = arguments.length, funcs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    funcs[_key - 1] = arguments[_key];
  }
  var sdkFuncs = funcs.reduce(function (accum, func) {
    var sdkSlice = func(config);
    return Object.assign(accum, sdkSlice);
  }, {});
  var sdk = _extends({}, sdkFuncs, {
    apiURL: (_config$apiURL = config.apiURL) != null ? _config$apiURL : API_URL,
    version: (_config$version = config.version) != null ? _config$version : DEFAULT_VERSION,
    chainId: config.chainId
  });
  return sdk;
};

/** @description construct SDK with every Swap-related method, fetching from API and token approval */
var constructSwapSDK = function constructSwapSDK(config) {
  var constructApproveTokenWithTxResponse = constructApproveToken;
  // include all available Swap methods
  return constructPartialSDK(config, constructGetBalances, constructGetTokens, constructGetSpender, constructApproveTokenWithTxResponse, constructBuildTx, constructGetAdapters, constructGetRate, constructSwapTx);
};

var constructSubmitLimitOrder = function constructSubmitLimitOrder(options) {
  var _constructBuildLimitO = constructBuildLimitOrder(options),
    buildLimitOrder = _constructBuildLimitO.buildLimitOrder;
  var _constructSignLimitOr = constructSignLimitOrder(options),
    signLimitOrder = _constructSignLimitOr.signLimitOrder;
  var _constructPostLimitOr = constructPostLimitOrder(options),
    postLimitOrder = _constructPostLimitOr.postLimitOrder,
    postP2POrder = _constructPostLimitOr.postP2POrder;
  var prepareLimitOrder = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(buildLimitOrderParams, extra) {
      var orderData, signature, orderWithSignature;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return buildLimitOrder(buildLimitOrderParams);
          case 2:
            orderData = _context.sent;
            _context.next = 5;
            return signLimitOrder(orderData);
          case 5:
            signature = _context.sent;
            orderWithSignature = _extends({}, orderData.data, extra, {
              signature: signature
            });
            return _context.abrupt("return", orderWithSignature);
          case 8:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function prepareLimitOrder(_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }();
  var submitLimitOrder = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(buildLimitOrderParams, extra, requestParams) {
      var orderWithSignature, newOrder;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            if (extra === void 0) {
              extra = {};
            }
            _context2.next = 3;
            return prepareLimitOrder(buildLimitOrderParams, extra);
          case 3:
            orderWithSignature = _context2.sent;
            _context2.next = 6;
            return postLimitOrder(orderWithSignature, requestParams);
          case 6:
            newOrder = _context2.sent;
            return _context2.abrupt("return", newOrder);
          case 8:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return function submitLimitOrder(_x3, _x4, _x5) {
      return _ref2.apply(this, arguments);
    };
  }();
  var submitP2POrder = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(buildLimitOrderParams, extra, requestParams) {
      var orderWithSignature, newOrder;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            if (extra === void 0) {
              extra = {};
            }
            _context3.next = 3;
            return prepareLimitOrder(buildLimitOrderParams, extra);
          case 3:
            orderWithSignature = _context3.sent;
            _context3.next = 6;
            return postP2POrder(orderWithSignature, requestParams);
          case 6:
            newOrder = _context3.sent;
            return _context3.abrupt("return", newOrder);
          case 8:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    return function submitP2POrder(_x6, _x7, _x8) {
      return _ref3.apply(this, arguments);
    };
  }();
  return {
    submitLimitOrder: submitLimitOrder,
    submitP2POrder: submitP2POrder
  };
};
/** @description construct SDK with every LimitOrders-related method, fetching from API and contract calls */
var constructAllLimitOrdersHandlers = function constructAllLimitOrdersHandlers(options) {
  var limitOrdersGetters = constructGetLimitOrders(options);
  var limitOrdersContractGetter = constructGetLimitOrdersContract(options);
  var limitOrdersSubmit = constructSubmitLimitOrder(options);
  var limitOrdersBuild = constructBuildLimitOrder(options);
  var limitOrdersSign = constructSignLimitOrder(options);
  var limitOrdersPost = constructPostLimitOrder(options);
  var limitOrdersCancel = constructCancelLimitOrder(options);
  var limitOrdersApproveToken = constructApproveTokenForLimitOrder(options);
  var limitOrdersFillOrderDirectly = constructFillOrderDirectly(options);
  var limitOrdersBuildTx = constructBuildLimitOrderTx(options);
  return _extends({}, limitOrdersGetters, limitOrdersContractGetter, limitOrdersSubmit, limitOrdersBuild, limitOrdersSign, limitOrdersPost, limitOrdersCancel, limitOrdersApproveToken, limitOrdersFillOrderDirectly, limitOrdersBuildTx);
};

var constructSubmitDeltaOrder = function constructSubmitDeltaOrder(options) {
  var _constructBuildDeltaO = constructBuildDeltaOrder(options),
    buildDeltaOrder = _constructBuildDeltaO.buildDeltaOrder;
  var _constructSignDeltaOr = constructSignDeltaOrder(options),
    signDeltaOrder = _constructSignDeltaOr.signDeltaOrder;
  var _constructPostDeltaOr = constructPostDeltaOrder(options),
    postDeltaOrder = _constructPostDeltaOr.postDeltaOrder;
  var submitDeltaOrder = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(orderParams) {
      var orderData, signature, response;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return buildDeltaOrder(orderParams);
          case 2:
            orderData = _context.sent;
            _context.next = 5;
            return signDeltaOrder(orderData);
          case 5:
            signature = _context.sent;
            _context.next = 8;
            return postDeltaOrder({
              signature: signature,
              partner: orderParams.partner,
              order: orderData.data,
              partiallyFillable: orderParams.partiallyFillable,
              referrerAddress: orderParams.referrerAddress,
              type: orderParams.type,
              includeAgents: orderParams.includeAgents,
              excludeAgents: orderParams.excludeAgents
            });
          case 8:
            response = _context.sent;
            return _context.abrupt("return", response);
          case 10:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function submitDeltaOrder(_x) {
      return _ref.apply(this, arguments);
    };
  }();
  return {
    submitDeltaOrder: submitDeltaOrder
  };
};
/** @description construct SDK with every Delta Order-related method, fetching from API and Order signing */
var constructAllDeltaOrdersHandlers = function constructAllDeltaOrdersHandlers(options) {
  var deltaOrdersGetters = constructGetDeltaOrders(options);
  var deltaOrdersContractGetter = constructGetDeltaContract(options);
  var deltaPrice = constructGetDeltaPrice(options);
  var partnerFee = constructGetPartnerFee(options);
  var bridgeInfo = constructGetBridgeInfo(options);
  var isTokenSupportedInDelta = constructIsTokenSupportedInDelta(options);
  var multicallHandlers = constructGetMulticallHandlers(options);
  var approveTokenForDelta = constructApproveTokenForDelta(options);
  var deltaOrdersSubmit = constructSubmitDeltaOrder(options);
  var buildCrosschainOrderBridge = constructBuildCrosschainOrderBridge(options);
  var deltaOrdersBuild = constructBuildDeltaOrder(options);
  var deltaOrdersSign = constructSignDeltaOrder(options);
  var deltaOrdersPost = constructPostDeltaOrder(options);
  var deltaOrdersCancel = constructCancelDeltaOrder(options);
  return _extends({}, deltaOrdersGetters, deltaOrdersContractGetter, deltaPrice, partnerFee, bridgeInfo, isTokenSupportedInDelta, multicallHandlers, approveTokenForDelta, deltaOrdersSubmit, deltaOrdersBuild, deltaOrdersSign, deltaOrdersPost, deltaOrdersCancel, buildCrosschainOrderBridge);
};

var constructSubmitNFTOrder = function constructSubmitNFTOrder(options) {
  var _constructBuildNFTOrd = constructBuildNFTOrder(options),
    buildNFTOrder = _constructBuildNFTOrd.buildNFTOrder;
  var _constructSignNFTOrde = constructSignNFTOrder(options),
    signNFTOrder = _constructSignNFTOrde.signNFTOrder;
  var _constructPostNFTOrde = constructPostNFTOrder(options),
    postNFTLimitOrder = _constructPostNFTOrde.postNFTLimitOrder,
    postNFTP2POrder = _constructPostNFTOrde.postNFTP2POrder;
  var prepareNFTOrder = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(buildNFTOrderParams, extra) {
      var orderData, signature, orderWithSignature;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return buildNFTOrder(buildNFTOrderParams);
          case 2:
            orderData = _context.sent;
            _context.next = 5;
            return signNFTOrder(orderData);
          case 5:
            signature = _context.sent;
            orderWithSignature = _extends({}, orderData.data, extra, {
              signature: signature
            });
            return _context.abrupt("return", orderWithSignature);
          case 8:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function prepareNFTOrder(_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }();
  var submitNFTOrder = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(buildNFTOrderParams, extra, requestParams) {
      var orderWithSignature, newOrder;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            if (extra === void 0) {
              extra = {};
            }
            _context2.next = 3;
            return prepareNFTOrder(buildNFTOrderParams, extra);
          case 3:
            orderWithSignature = _context2.sent;
            _context2.next = 6;
            return postNFTLimitOrder(orderWithSignature, requestParams);
          case 6:
            newOrder = _context2.sent;
            return _context2.abrupt("return", newOrder);
          case 8:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return function submitNFTOrder(_x3, _x4, _x5) {
      return _ref2.apply(this, arguments);
    };
  }();
  var submitP2POrder = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(buildNFTOrderParams, extra, requestParams) {
      var orderWithSignature, newOrder;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            if (extra === void 0) {
              extra = {};
            }
            _context3.next = 3;
            return prepareNFTOrder(buildNFTOrderParams, extra);
          case 3:
            orderWithSignature = _context3.sent;
            _context3.next = 6;
            return postNFTP2POrder(orderWithSignature, requestParams);
          case 6:
            newOrder = _context3.sent;
            return _context3.abrupt("return", newOrder);
          case 8:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    return function submitP2POrder(_x6, _x7, _x8) {
      return _ref3.apply(this, arguments);
    };
  }();
  return {
    submitNFTOrder: submitNFTOrder,
    submitP2POrder: submitP2POrder
  };
};
/** @description construct SDK with every NFTOrders-related method, fetching from API and contract calls */
var constructAllNFTOrdersHandlers = function constructAllNFTOrdersHandlers(options) {
  var NFTOrdersGetters = constructGetNFTOrders(options);
  var NFTOrdersContractGetter = constructGetNFTOrdersContract(options);
  var NFTOrdersSubmit = constructSubmitNFTOrder(options);
  var NFTOrdersBuild = constructBuildNFTOrder(options);
  var NFTOrdersSign = constructSignNFTOrder(options);
  var NFTOrdersPost = constructPostNFTOrder(options);
  var NFTOrdersCancel = constructCancelNFTOrder(options);
  var NFTOrdersApproveToken = constructApproveTokenForNFTOrder(options);
  var NFTOrdersBuildTx = constructBuildNFTOrderTx(options);
  return _extends({}, NFTOrdersGetters, NFTOrdersContractGetter, NFTOrdersSubmit, NFTOrdersBuild, NFTOrdersSign, NFTOrdersPost, NFTOrdersCancel, NFTOrdersApproveToken, NFTOrdersBuildTx);
};

/** @description construct SDK with every method, for swap and limitOrders */
var constructFullSDK = function constructFullSDK(config) {
  var _config$apiURL, _config$version;
  // include all available functions
  var swap = constructSwapSDK(config);
  var limitOrders = constructAllLimitOrdersHandlers(config);
  var nftOrders = constructAllNFTOrdersHandlers(config);
  var delta = constructAllDeltaOrdersHandlers(config);
  var quote = constructGetQuote(config);
  return {
    swap: swap,
    limitOrders: limitOrders,
    nftOrders: nftOrders,
    delta: delta,
    quote: quote,
    apiURL: (_config$apiURL = config.apiURL) != null ? _config$apiURL : API_URL,
    chainId: config.chainId,
    version: (_config$version = config.version) != null ? _config$version : DEFAULT_VERSION
  };
};

var constructFetcher = function constructFetcher(options) {
  if ('axios' in options) {
    return constructFetcher$2(options.axios, options);
  }
  if ('fetch' in options) {
    return constructFetcher$1(options.fetch, options);
  }
  return function (params) {
    var _params$requestParams;
    // adding apiKey to headers if it's provided
    var headers = options != null && options.apiKey ? _extends({
      'X-API-KEY': options.apiKey
    }, params.headers, (_params$requestParams = params.requestParams) == null ? void 0 : _params$requestParams.headers) : params.headers;
    return options.fetcher(_extends({}, params, {
      headers: headers
    }));
  };
};
function constructSimpleSDK(options, providerOptions) {
  var _options$apiURL2, _options$version2;
  var fetcher = constructFetcher(options);
  if (!providerOptions) {
    var _options$apiURL, _options$version;
    var _config = {
      apiURL: options.apiURL,
      chainId: options.chainId,
      version: options.version,
      fetcher: fetcher
    };
    // include all available functions that don't need `contractCaller`
    var _swap = constructPartialSDK(_config, constructGetBalances, constructGetTokens, constructGetSpender, constructBuildTx, constructGetAdapters, constructGetRate, constructSwapTx);
    var _limitOrders = constructPartialSDK(_config, constructBuildLimitOrder, constructPostLimitOrder, constructGetLimitOrders, constructGetLimitOrdersContract, constructBuildLimitOrderTx);
    var _nftOrders = constructPartialSDK(_config, constructBuildNFTOrder, constructPostNFTOrder, constructGetNFTOrders, constructGetNFTOrdersContract, constructBuildNFTOrderTx);
    var _delta = constructPartialSDK(_config, constructBuildDeltaOrder, constructBuildCrosschainOrderBridge, constructPostDeltaOrder, constructGetDeltaOrders, constructGetDeltaPrice, constructGetDeltaContract, constructGetPartnerFee, constructGetMulticallHandlers, constructGetBridgeInfo, constructIsTokenSupportedInDelta);
    var _quote = constructPartialSDK(_config, constructGetQuote);
    return {
      swap: _swap,
      limitOrders: _limitOrders,
      nftOrders: _nftOrders,
      delta: _delta,
      quote: _quote,
      apiURL: (_options$apiURL = options.apiURL) != null ? _options$apiURL : API_URL,
      chainId: options.chainId,
      version: (_options$version = options.version) != null ? _options$version : DEFAULT_VERSION
    };
  }
  var contractCaller = constructSimpleContractCaller(providerOptions);
  var config = {
    apiURL: options.apiURL,
    version: options.version,
    chainId: options.chainId,
    fetcher: fetcher,
    contractCaller: contractCaller
  };
  var swap = constructSwapSDK(config);
  var limitOrders = constructAllLimitOrdersHandlers(config);
  var nftOrders = constructAllNFTOrdersHandlers(config);
  var delta = constructAllDeltaOrdersHandlers(config);
  var quote = constructGetQuote(config);
  return {
    swap: swap,
    limitOrders: limitOrders,
    nftOrders: nftOrders,
    delta: delta,
    quote: quote,
    apiURL: (_options$apiURL2 = options.apiURL) != null ? _options$apiURL2 : API_URL,
    chainId: options.chainId,
    version: (_options$version2 = options.version) != null ? _options$version2 : DEFAULT_VERSION
  };
}
function constructSimpleContractCaller(providerOptions) {
  if ('ethersProviderOrSigner' in providerOptions) {
    var _constructEthersV5Con = constructEthersV5ContractCaller(providerOptions, providerOptions.account),
      _staticCall = _constructEthersV5Con.staticCall,
      _transactCall2 = _constructEthersV5Con.transactCall,
      _signTypedDataCall = _constructEthersV5Con.signTypedDataCall;
    var _transactCall3 = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(params) {
        var contractTx;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return _transactCall2(params);
            case 2:
              contractTx = _context.sent;
              return _context.abrupt("return", contractTx.hash);
            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return function _transactCall3(_x) {
        return _ref.apply(this, arguments);
      };
    }();
    return {
      staticCall: _staticCall,
      transactCall: _transactCall3,
      signTypedDataCall: _signTypedDataCall
    };
  }
  if ('ethersV6ProviderOrSigner' in providerOptions) {
    var _constructEthersV6Con = constructContractCaller$2(providerOptions, providerOptions.account),
      _staticCall2 = _constructEthersV6Con.staticCall,
      _transactCall4 = _constructEthersV6Con.transactCall,
      _signTypedDataCall2 = _constructEthersV6Con.signTypedDataCall;
    var _transactCall5 = /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(params) {
        var contractTx;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return _transactCall4(params);
            case 2:
              contractTx = _context2.sent;
              return _context2.abrupt("return", contractTx.hash);
            case 4:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      return function _transactCall5(_x2) {
        return _ref2.apply(this, arguments);
      };
    }();
    return {
      staticCall: _staticCall2,
      transactCall: _transactCall5,
      signTypedDataCall: _signTypedDataCall2
    };
  }
  if ('viemClient' in providerOptions) {
    var contractCaller = constructContractCaller(providerOptions.viemClient, providerOptions.account);
    return contractCaller;
  }
  var _constructWeb3Contrac = constructContractCaller$1(providerOptions.web3, providerOptions.account),
    staticCall = _constructWeb3Contrac.staticCall,
    _transactCall = _constructWeb3Contrac.transactCall,
    signTypedDataCall = _constructWeb3Contrac.signTypedDataCall;
  var transactCall = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(params) {
      var unpromiEvent;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return _transactCall(params);
          case 2:
            unpromiEvent = _context3.sent;
            return _context3.abrupt("return", new Promise(function (resolve, reject) {
              unpromiEvent.once('transactionHash', function (hash) {
                return resolve(hash);
              });
              unpromiEvent.once('error', reject);
            }));
          case 4:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    return function transactCall(_x3) {
      return _ref3.apply(this, arguments);
    };
  }();
  return {
    staticCall: staticCall,
    transactCall: transactCall,
    signTypedDataCall: signTypedDataCall
  };
}

Object.defineProperty(exports, 'ContractMethod', {
  enumerable: true,
  get: function () { return core.ContractMethod; }
});
Object.defineProperty(exports, 'ContractMethodV5', {
  enumerable: true,
  get: function () { return core.ContractMethodV5; }
});
Object.defineProperty(exports, 'ContractMethodV6', {
  enumerable: true,
  get: function () { return core.ContractMethodV6; }
});
Object.defineProperty(exports, 'SwapSide', {
  enumerable: true,
  get: function () { return core.SwapSide; }
});
exports.API_URL = API_URL;
exports.AssetType = AssetType;
exports.DEFAULT_VERSION = DEFAULT_VERSION;
exports.constructAllDeltaOrdersHandlers = constructAllDeltaOrdersHandlers;
exports.constructAllLimitOrdersHandlers = constructAllLimitOrdersHandlers;
exports.constructAllNFTOrdersHandlers = constructAllNFTOrdersHandlers;
exports.constructApproveToken = constructApproveToken;
exports.constructApproveTokenForDelta = constructApproveTokenForDelta;
exports.constructApproveTokenForLimitOrder = constructApproveTokenForLimitOrder;
exports.constructApproveTokenForNFTOrder = constructApproveTokenForNFTOrder;
exports.constructAxiosFetcher = constructFetcher$2;
exports.constructBuildCrosschainOrderBridge = constructBuildCrosschainOrderBridge;
exports.constructBuildDeltaOrder = constructBuildDeltaOrder;
exports.constructBuildLimitOrder = constructBuildLimitOrder;
exports.constructBuildLimitOrderTx = constructBuildLimitOrderTx;
exports.constructBuildNFTOrder = constructBuildNFTOrder;
exports.constructBuildNFTOrderTx = constructBuildNFTOrderTx;
exports.constructBuildTx = constructBuildTx;
exports.constructCancelDeltaOrder = constructCancelDeltaOrder;
exports.constructCancelLimitOrder = constructCancelLimitOrder;
exports.constructCancelNFTOrder = constructCancelNFTOrder;
exports.constructEthersContractCaller = constructEthersV5ContractCaller;
exports.constructEthersV5ContractCaller = constructEthersV5ContractCaller;
exports.constructEthersV6ContractCaller = constructContractCaller$2;
exports.constructFetchFetcher = constructFetcher$1;
exports.constructFillOrderDirectly = constructFillOrderDirectly;
exports.constructFullSDK = constructFullSDK;
exports.constructGetAdapters = constructGetAdapters;
exports.constructGetBalances = constructGetBalances;
exports.constructGetBridgeInfo = constructGetBridgeInfo;
exports.constructGetDeltaContract = constructGetDeltaContract;
exports.constructGetDeltaOrders = constructGetDeltaOrders;
exports.constructGetDeltaPrice = constructGetDeltaPrice;
exports.constructGetLimitOrders = constructGetLimitOrders;
exports.constructGetLimitOrdersContract = constructGetLimitOrdersContract;
exports.constructGetMulticallHandlers = constructGetMulticallHandlers;
exports.constructGetNFTOrders = constructGetNFTOrders;
exports.constructGetNFTOrdersContract = constructGetNFTOrdersContract;
exports.constructGetPartnerFee = constructGetPartnerFee;
exports.constructGetQuote = constructGetQuote;
exports.constructGetRate = constructGetRate;
exports.constructGetSpender = constructGetSpender;
exports.constructGetTokens = constructGetTokens;
exports.constructIsTokenSupportedInDelta = constructIsTokenSupportedInDelta;
exports.constructPartialSDK = constructPartialSDK;
exports.constructPostDeltaOrder = constructPostDeltaOrder;
exports.constructPostLimitOrder = constructPostLimitOrder;
exports.constructPostNFTOrder = constructPostNFTOrder;
exports.constructSignDeltaOrder = constructSignDeltaOrder;
exports.constructSignLimitOrder = constructSignLimitOrder;
exports.constructSignNFTOrder = constructSignNFTOrder;
exports.constructSimpleSDK = constructSimpleSDK;
exports.constructSubmitDeltaOrder = constructSubmitDeltaOrder;
exports.constructSubmitLimitOrder = constructSubmitLimitOrder;
exports.constructSubmitNFTOrder = constructSubmitNFTOrder;
exports.constructSwapSDK = constructSwapSDK;
exports.constructSwapTx = constructSwapTx;
exports.constructToken = constructToken;
exports.constructViemContractCaller = constructContractCaller;
exports.constructWeb3ContractCaller = constructContractCaller$1;
exports.isAllowance = isAllowance;
exports.isFetcherError = isFetcherError;
exports.txParamsToViemTxParams = txParamsToViemTxParams;
//# sourceMappingURL=sdk.cjs.development.js.map
