import {
  __commonJS,
  __toESM
} from "./chunk-QY3AG7D4.js";

// node_modules/@paraswap/core/build/types.js
var require_types = __commonJS({
  "node_modules/@paraswap/core/build/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParaSwapVersion = void 0;
    var ParaSwapVersion;
    (function(ParaSwapVersion2) {
      ParaSwapVersion2["V5"] = "5";
      ParaSwapVersion2["V6"] = "6.2";
    })(ParaSwapVersion = exports.ParaSwapVersion || (exports.ParaSwapVersion = {}));
  }
});

// node_modules/@paraswap/core/build/constants.js
var require_constants = __commonJS({
  "node_modules/@paraswap/core/build/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DirectContractMethods = exports.DirectContractMethodsWithFeeModel = exports.ContractMethod = exports.ContractMethodV6 = exports.ContractMethodV5 = exports.SwapSide = void 0;
    var SwapSide3;
    (function(SwapSide4) {
      SwapSide4["BUY"] = "BUY";
      SwapSide4["SELL"] = "SELL";
    })(SwapSide3 = exports.SwapSide || (exports.SwapSide = {}));
    var ContractMethodV52;
    (function(ContractMethodV53) {
      ContractMethodV53["swapOnUniswap"] = "swapOnUniswap";
      ContractMethodV53["buyOnUniswap"] = "buyOnUniswap";
      ContractMethodV53["swapOnUniswapFork"] = "swapOnUniswapFork";
      ContractMethodV53["buyOnUniswapFork"] = "buyOnUniswapFork";
      ContractMethodV53["swapOnUniswapV2Fork"] = "swapOnUniswapV2Fork";
      ContractMethodV53["buyOnUniswapV2Fork"] = "buyOnUniswapV2Fork";
      ContractMethodV53["simpleBuy"] = "simpleBuy";
      ContractMethodV53["simpleSwap"] = "simpleSwap";
      ContractMethodV53["multiSwap"] = "multiSwap";
      ContractMethodV53["megaSwap"] = "megaSwap";
      ContractMethodV53["protectedMultiSwap"] = "protectedMultiSwap";
      ContractMethodV53["protectedMegaSwap"] = "protectedMegaSwap";
      ContractMethodV53["protectedSimpleSwap"] = "protectedSimpleSwap";
      ContractMethodV53["protectedSimpleBuy"] = "protectedSimpleBuy";
      ContractMethodV53["swapOnZeroXv2"] = "swapOnZeroXv2";
      ContractMethodV53["swapOnZeroXv4"] = "swapOnZeroXv4";
      ContractMethodV53["buy"] = "buy";
      ContractMethodV53["directUniV3Swap"] = "directUniV3Swap";
      ContractMethodV53["directUniV3Buy"] = "directUniV3Buy";
      ContractMethodV53["directCurveV1Swap"] = "directCurveV1Swap";
      ContractMethodV53["directCurveV2Swap"] = "directCurveV2Swap";
      ContractMethodV53["directBalancerV2GivenInSwap"] = "directBalancerV2GivenInSwap";
      ContractMethodV53["directBalancerV2GivenOutSwap"] = "directBalancerV2GivenOutSwap";
    })(ContractMethodV52 = exports.ContractMethodV5 || (exports.ContractMethodV5 = {}));
    var ContractMethodV62;
    (function(ContractMethodV63) {
      ContractMethodV63["swapExactAmountIn"] = "swapExactAmountIn";
      ContractMethodV63["swapExactAmountOut"] = "swapExactAmountOut";
      ContractMethodV63["swapExactAmountInOnUniswapV2"] = "swapExactAmountInOnUniswapV2";
      ContractMethodV63["swapExactAmountOutOnUniswapV2"] = "swapExactAmountOutOnUniswapV2";
      ContractMethodV63["swapExactAmountInOnUniswapV3"] = "swapExactAmountInOnUniswapV3";
      ContractMethodV63["swapExactAmountOutOnUniswapV3"] = "swapExactAmountOutOnUniswapV3";
      ContractMethodV63["swapExactAmountInOnBalancerV2"] = "swapExactAmountInOnBalancerV2";
      ContractMethodV63["swapExactAmountOutOnBalancerV2"] = "swapExactAmountOutOnBalancerV2";
      ContractMethodV63["swapExactAmountInOnCurveV1"] = "swapExactAmountInOnCurveV1";
      ContractMethodV63["swapExactAmountInOnCurveV2"] = "swapExactAmountInOnCurveV2";
      ContractMethodV63["swapOnAugustusRFQTryBatchFill"] = "swapOnAugustusRFQTryBatchFill";
      ContractMethodV63["swapExactAmountInOutOnMakerPSM"] = "swapExactAmountInOutOnMakerPSM";
    })(ContractMethodV62 = exports.ContractMethodV6 || (exports.ContractMethodV6 = {}));
    exports.ContractMethod = { ...ContractMethodV52, ...ContractMethodV62 };
    exports.DirectContractMethodsWithFeeModel = [
      ContractMethodV52.directUniV3Swap,
      ContractMethodV52.directUniV3Buy,
      ContractMethodV52.directCurveV1Swap,
      ContractMethodV52.directCurveV2Swap,
      ContractMethodV52.directBalancerV2GivenInSwap,
      ContractMethodV52.directBalancerV2GivenOutSwap,
      ContractMethodV62.swapExactAmountInOnUniswapV2,
      ContractMethodV62.swapExactAmountOutOnUniswapV2,
      ContractMethodV62.swapExactAmountInOnUniswapV3,
      ContractMethodV62.swapExactAmountOutOnUniswapV3,
      ContractMethodV62.swapExactAmountInOnBalancerV2,
      ContractMethodV62.swapExactAmountOutOnBalancerV2,
      ContractMethodV62.swapExactAmountInOnCurveV1,
      ContractMethodV62.swapExactAmountInOnCurveV2
    ];
    exports.DirectContractMethods = [
      ContractMethodV52.swapOnUniswap,
      ContractMethodV52.buyOnUniswap,
      ContractMethodV52.swapOnUniswapFork,
      ContractMethodV52.buyOnUniswapFork,
      ContractMethodV52.swapOnUniswapV2Fork,
      ContractMethodV52.buyOnUniswapV2Fork,
      ContractMethodV52.swapOnZeroXv2,
      ContractMethodV52.swapOnZeroXv4,
      ContractMethodV62.swapOnAugustusRFQTryBatchFill,
      ContractMethodV62.swapExactAmountInOutOnMakerPSM
    ].concat(exports.DirectContractMethodsWithFeeModel);
  }
});

// node_modules/@paraswap/core/build/index.js
var require_build = __commonJS({
  "node_modules/@paraswap/core/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DirectContractMethods = exports.ContractMethodV6 = exports.ContractMethodV5 = exports.ContractMethod = exports.SwapSide = exports.ParaSwapVersion = void 0;
    var types_1 = require_types();
    Object.defineProperty(exports, "ParaSwapVersion", { enumerable: true, get: function() {
      return types_1.ParaSwapVersion;
    } });
    var constants_1 = require_constants();
    Object.defineProperty(exports, "SwapSide", { enumerable: true, get: function() {
      return constants_1.SwapSide;
    } });
    Object.defineProperty(exports, "ContractMethod", { enumerable: true, get: function() {
      return constants_1.ContractMethod;
    } });
    Object.defineProperty(exports, "ContractMethodV5", { enumerable: true, get: function() {
      return constants_1.ContractMethodV5;
    } });
    Object.defineProperty(exports, "ContractMethodV6", { enumerable: true, get: function() {
      return constants_1.ContractMethodV6;
    } });
    Object.defineProperty(exports, "DirectContractMethods", { enumerable: true, get: function() {
      return constants_1.DirectContractMethods;
    } });
  }
});

// node_modules/ts-essentials/dist/primitive/index.js
var require_primitive = __commonJS({
  "node_modules/ts-essentials/dist/primitive/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/built-in/index.js
var require_built_in = __commonJS({
  "node_modules/ts-essentials/dist/built-in/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/key-of-base/index.js
var require_key_of_base = __commonJS({
  "node_modules/ts-essentials/dist/key-of-base/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/strict-exclude/index.js
var require_strict_exclude = __commonJS({
  "node_modules/ts-essentials/dist/strict-exclude/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/strict-extract/index.js
var require_strict_extract = __commonJS({
  "node_modules/ts-essentials/dist/strict-extract/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/strict-omit/index.js
var require_strict_omit = __commonJS({
  "node_modules/ts-essentials/dist/strict-omit/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/writable/index.js
var require_writable = __commonJS({
  "node_modules/ts-essentials/dist/writable/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/async-or-sync/index.js
var require_async_or_sync = __commonJS({
  "node_modules/ts-essentials/dist/async-or-sync/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/async-or-sync-type/index.js
var require_async_or_sync_type = __commonJS({
  "node_modules/ts-essentials/dist/async-or-sync-type/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/dictionary/index.js
var require_dictionary = __commonJS({
  "node_modules/ts-essentials/dist/dictionary/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/dictionary-values/index.js
var require_dictionary_values = __commonJS({
  "node_modules/ts-essentials/dist/dictionary-values/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/merge/index.js
var require_merge = __commonJS({
  "node_modules/ts-essentials/dist/merge/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/merge-n/index.js
var require_merge_n = __commonJS({
  "node_modules/ts-essentials/dist/merge-n/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/newable/index.js
var require_newable = __commonJS({
  "node_modules/ts-essentials/dist/newable/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/non-never/index.js
var require_non_never = __commonJS({
  "node_modules/ts-essentials/dist/non-never/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/omit-properties/index.js
var require_omit_properties = __commonJS({
  "node_modules/ts-essentials/dist/omit-properties/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/opaque/index.js
var require_opaque = __commonJS({
  "node_modules/ts-essentials/dist/opaque/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/path-value/index.js
var require_path_value = __commonJS({
  "node_modules/ts-essentials/dist/path-value/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/paths/index.js
var require_paths = __commonJS({
  "node_modules/ts-essentials/dist/paths/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/pick-properties/index.js
var require_pick_properties = __commonJS({
  "node_modules/ts-essentials/dist/pick-properties/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/prettify/index.js
var require_prettify = __commonJS({
  "node_modules/ts-essentials/dist/prettify/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/safe-dictionary/index.js
var require_safe_dictionary = __commonJS({
  "node_modules/ts-essentials/dist/safe-dictionary/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/union-to-intersection/index.js
var require_union_to_intersection = __commonJS({
  "node_modules/ts-essentials/dist/union-to-intersection/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/value-of/index.js
var require_value_of = __commonJS({
  "node_modules/ts-essentials/dist/value-of/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/xor/index.js
var require_xor = __commonJS({
  "node_modules/ts-essentials/dist/xor/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/mark-optional/index.js
var require_mark_optional = __commonJS({
  "node_modules/ts-essentials/dist/mark-optional/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/mark-readonly/index.js
var require_mark_readonly = __commonJS({
  "node_modules/ts-essentials/dist/mark-readonly/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/mark-required/index.js
var require_mark_required = __commonJS({
  "node_modules/ts-essentials/dist/mark-required/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/mark-writable/index.js
var require_mark_writable = __commonJS({
  "node_modules/ts-essentials/dist/mark-writable/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/buildable/index.js
var require_buildable = __commonJS({
  "node_modules/ts-essentials/dist/buildable/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/deep-mark-optional/index.js
var require_deep_mark_optional = __commonJS({
  "node_modules/ts-essentials/dist/deep-mark-optional/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/deep-mark-required/index.js
var require_deep_mark_required = __commonJS({
  "node_modules/ts-essentials/dist/deep-mark-required/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/deep-non-nullable/index.js
var require_deep_non_nullable = __commonJS({
  "node_modules/ts-essentials/dist/deep-non-nullable/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/deep-nullable/index.js
var require_deep_nullable = __commonJS({
  "node_modules/ts-essentials/dist/deep-nullable/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/deep-omit/index.js
var require_deep_omit = __commonJS({
  "node_modules/ts-essentials/dist/deep-omit/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/deep-partial/index.js
var require_deep_partial = __commonJS({
  "node_modules/ts-essentials/dist/deep-partial/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/deep-pick/index.js
var require_deep_pick = __commonJS({
  "node_modules/ts-essentials/dist/deep-pick/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/deep-readonly/index.js
var require_deep_readonly = __commonJS({
  "node_modules/ts-essentials/dist/deep-readonly/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/deep-required/index.js
var require_deep_required = __commonJS({
  "node_modules/ts-essentials/dist/deep-required/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/deep-undefinable/index.js
var require_deep_undefinable = __commonJS({
  "node_modules/ts-essentials/dist/deep-undefinable/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/deep-writable/index.js
var require_deep_writable = __commonJS({
  "node_modules/ts-essentials/dist/deep-writable/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/strict-deep-omit/index.js
var require_strict_deep_omit = __commonJS({
  "node_modules/ts-essentials/dist/strict-deep-omit/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/strict-deep-pick/index.js
var require_strict_deep_pick = __commonJS({
  "node_modules/ts-essentials/dist/strict-deep-pick/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/optional-keys/index.js
var require_optional_keys = __commonJS({
  "node_modules/ts-essentials/dist/optional-keys/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/pick-keys/index.js
var require_pick_keys = __commonJS({
  "node_modules/ts-essentials/dist/pick-keys/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/readonly-keys/index.js
var require_readonly_keys = __commonJS({
  "node_modules/ts-essentials/dist/readonly-keys/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/required-keys/index.js
var require_required_keys = __commonJS({
  "node_modules/ts-essentials/dist/required-keys/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/writable-keys/index.js
var require_writable_keys = __commonJS({
  "node_modules/ts-essentials/dist/writable-keys/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/exact/index.js
var require_exact = __commonJS({
  "node_modules/ts-essentials/dist/exact/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/is-any/index.js
var require_is_any = __commonJS({
  "node_modules/ts-essentials/dist/is-any/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/is-never/index.js
var require_is_never = __commonJS({
  "node_modules/ts-essentials/dist/is-never/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/is-unknown/index.js
var require_is_unknown = __commonJS({
  "node_modules/ts-essentials/dist/is-unknown/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/is-tuple/index.js
var require_is_tuple = __commonJS({
  "node_modules/ts-essentials/dist/is-tuple/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/non-empty-object/index.js
var require_non_empty_object = __commonJS({
  "node_modules/ts-essentials/dist/non-empty-object/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/any-array/index.js
var require_any_array = __commonJS({
  "node_modules/ts-essentials/dist/any-array/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/array-or-single/index.js
var require_array_or_single = __commonJS({
  "node_modules/ts-essentials/dist/array-or-single/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/element-of/index.js
var require_element_of = __commonJS({
  "node_modules/ts-essentials/dist/element-of/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/head/index.js
var require_head = __commonJS({
  "node_modules/ts-essentials/dist/head/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/non-empty-array/index.js
var require_non_empty_array = __commonJS({
  "node_modules/ts-essentials/dist/non-empty-array/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/readonly-array-or-single/index.js
var require_readonly_array_or_single = __commonJS({
  "node_modules/ts-essentials/dist/readonly-array-or-single/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/tail/index.js
var require_tail = __commonJS({
  "node_modules/ts-essentials/dist/tail/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/tuple/index.js
var require_tuple = __commonJS({
  "node_modules/ts-essentials/dist/tuple/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/camel-case/index.js
var require_camel_case = __commonJS({
  "node_modules/ts-essentials/dist/camel-case/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/deep-camel-case-properties/index.js
var require_deep_camel_case_properties = __commonJS({
  "node_modules/ts-essentials/dist/deep-camel-case-properties/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/any-function/index.js
var require_any_function = __commonJS({
  "node_modules/ts-essentials/dist/any-function/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/predicate-function/index.js
var require_predicate_function = __commonJS({
  "node_modules/ts-essentials/dist/predicate-function/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/predicate-type/index.js
var require_predicate_type = __commonJS({
  "node_modules/ts-essentials/dist/predicate-type/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/functions/unreachable-case-error/index.js
var require_unreachable_case_error = __commonJS({
  "node_modules/ts-essentials/dist/functions/unreachable-case-error/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnreachableCaseError = void 0;
    var UnreachableCaseError = class extends Error {
      constructor(value) {
        super(`Unreachable case: ${value}`);
      }
    };
    exports.UnreachableCaseError = UnreachableCaseError;
  }
});

// node_modules/ts-essentials/dist/functions/assert/index.js
var require_assert = __commonJS({
  "node_modules/ts-essentials/dist/functions/assert/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assert = void 0;
    function assert2(condition, message = "no additional info provided") {
      if (!condition) {
        throw new Error("Assertion Error: " + message);
      }
    }
    exports.assert = assert2;
  }
});

// node_modules/ts-essentials/dist/functions/create-factory-with-constraint/index.js
var require_create_factory_with_constraint = __commonJS({
  "node_modules/ts-essentials/dist/functions/create-factory-with-constraint/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFactoryWithConstraint = void 0;
    var createFactoryWithConstraint = () => (value) => value;
    exports.createFactoryWithConstraint = createFactoryWithConstraint;
  }
});

// node_modules/ts-essentials/dist/functions/is-exact/index.js
var require_is_exact = __commonJS({
  "node_modules/ts-essentials/dist/functions/is-exact/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isExact = void 0;
    var isExact = () => (x) => x;
    exports.isExact = isExact;
  }
});

// node_modules/ts-essentials/dist/functions/noop/index.js
var require_noop = __commonJS({
  "node_modules/ts-essentials/dist/functions/noop/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.noop = void 0;
    function noop(..._args) {
    }
    exports.noop = noop;
  }
});

// node_modules/ts-essentials/dist/awaited/index.js
var require_awaited = __commonJS({
  "node_modules/ts-essentials/dist/awaited/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ts-essentials/dist/index.js
var require_dist = __commonJS({
  "node_modules/ts-essentials/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_primitive(), exports);
    __exportStar(require_built_in(), exports);
    __exportStar(require_key_of_base(), exports);
    __exportStar(require_strict_exclude(), exports);
    __exportStar(require_strict_extract(), exports);
    __exportStar(require_strict_omit(), exports);
    __exportStar(require_writable(), exports);
    __exportStar(require_async_or_sync(), exports);
    __exportStar(require_async_or_sync_type(), exports);
    __exportStar(require_dictionary(), exports);
    __exportStar(require_dictionary_values(), exports);
    __exportStar(require_merge(), exports);
    __exportStar(require_merge_n(), exports);
    __exportStar(require_newable(), exports);
    __exportStar(require_non_never(), exports);
    __exportStar(require_omit_properties(), exports);
    __exportStar(require_opaque(), exports);
    __exportStar(require_path_value(), exports);
    __exportStar(require_paths(), exports);
    __exportStar(require_pick_properties(), exports);
    __exportStar(require_prettify(), exports);
    __exportStar(require_safe_dictionary(), exports);
    __exportStar(require_union_to_intersection(), exports);
    __exportStar(require_value_of(), exports);
    __exportStar(require_xor(), exports);
    __exportStar(require_mark_optional(), exports);
    __exportStar(require_mark_readonly(), exports);
    __exportStar(require_mark_required(), exports);
    __exportStar(require_mark_writable(), exports);
    __exportStar(require_buildable(), exports);
    __exportStar(require_deep_mark_optional(), exports);
    __exportStar(require_deep_mark_required(), exports);
    __exportStar(require_deep_non_nullable(), exports);
    __exportStar(require_deep_nullable(), exports);
    __exportStar(require_deep_omit(), exports);
    __exportStar(require_deep_partial(), exports);
    __exportStar(require_deep_pick(), exports);
    __exportStar(require_deep_readonly(), exports);
    __exportStar(require_deep_required(), exports);
    __exportStar(require_deep_undefinable(), exports);
    __exportStar(require_deep_writable(), exports);
    __exportStar(require_strict_deep_omit(), exports);
    __exportStar(require_strict_deep_pick(), exports);
    __exportStar(require_optional_keys(), exports);
    __exportStar(require_pick_keys(), exports);
    __exportStar(require_readonly_keys(), exports);
    __exportStar(require_required_keys(), exports);
    __exportStar(require_writable_keys(), exports);
    __exportStar(require_exact(), exports);
    __exportStar(require_is_any(), exports);
    __exportStar(require_is_never(), exports);
    __exportStar(require_is_unknown(), exports);
    __exportStar(require_is_tuple(), exports);
    __exportStar(require_non_empty_object(), exports);
    __exportStar(require_any_array(), exports);
    __exportStar(require_array_or_single(), exports);
    __exportStar(require_element_of(), exports);
    __exportStar(require_head(), exports);
    __exportStar(require_non_empty_array(), exports);
    __exportStar(require_readonly_array_or_single(), exports);
    __exportStar(require_tail(), exports);
    __exportStar(require_tuple(), exports);
    __exportStar(require_camel_case(), exports);
    __exportStar(require_deep_camel_case_properties(), exports);
    __exportStar(require_any_function(), exports);
    __exportStar(require_predicate_function(), exports);
    __exportStar(require_predicate_type(), exports);
    __exportStar(require_unreachable_case_error(), exports);
    __exportStar(require_assert(), exports);
    __exportStar(require_create_factory_with_constraint(), exports);
    __exportStar(require_is_exact(), exports);
    __exportStar(require_noop(), exports);
    __exportStar(require_awaited(), exports);
  }
});

// node_modules/@velora-dex/sdk/dist/sdk.esm.js
var import_core = __toESM(require_build());
var import_core2 = __toESM(require_build());
var import_ts_essentials = __toESM(require_dist());
function _assertThisInitialized(e) {
  if (void 0 === e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function asyncGeneratorStep(n, t, e, r, o, a, c) {
  try {
    var i = n[a](c), u = i.value;
  } catch (n2) {
    return void e(n2);
  }
  i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
  return function() {
    var t = this, e = arguments;
    return new Promise(function(r, o) {
      var a = n.apply(t, e);
      function _next(n2) {
        asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
      }
      function _throw(n2) {
        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
      }
      _next(void 0);
    });
  };
}
function _construct(t, e, r) {
  if (_isNativeReflectConstruct())
    return Reflect.construct.apply(null, arguments);
  var o = [null];
  o.push.apply(o, e);
  var p = new (t.bind.apply(t, o))();
  return r && _setPrototypeOf(p, r.prototype), p;
}
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}
function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
    return t2.__proto__ || Object.getPrototypeOf(t2);
  }, _getPrototypeOf(t);
}
function _inheritsLoose(t, o) {
  t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o);
}
function _isNativeFunction(t) {
  try {
    return -1 !== Function.toString.call(t).indexOf("[native code]");
  } catch (n) {
    return "function" == typeof t;
  }
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct = function() {
    return !!t;
  })();
}
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r)
    return {};
  var t = {};
  for (var n in r)
    if ({}.hasOwnProperty.call(r, n)) {
      if (e.includes(n))
        continue;
      t[n] = r[n];
    }
  return t;
}
function _regeneratorRuntime() {
  _regeneratorRuntime = function() {
    return e;
  };
  var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
    t2[e2] = r2.value;
  }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
  function define(t2, e2, r2) {
    return Object.defineProperty(t2, e2, {
      value: r2,
      enumerable: true,
      configurable: true,
      writable: true
    }), t2[e2];
  }
  try {
    define({}, "");
  } catch (t2) {
    define = function(t3, e2, r2) {
      return t3[e2] = r2;
    };
  }
  function wrap(t2, e2, r2, n2) {
    var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
    return o(a2, "_invoke", {
      value: makeInvokeMethod(t2, r2, c2)
    }), a2;
  }
  function tryCatch(t2, e2, r2) {
    try {
      return {
        type: "normal",
        arg: t2.call(e2, r2)
      };
    } catch (t3) {
      return {
        type: "throw",
        arg: t3
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
  function Generator() {
  }
  function GeneratorFunction() {
  }
  function GeneratorFunctionPrototype() {
  }
  var p = {};
  define(p, a, function() {
    return this;
  });
  var d = Object.getPrototypeOf, v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t2) {
    ["next", "throw", "return"].forEach(function(e2) {
      define(t2, e2, function(t3) {
        return this._invoke(e2, t3);
      });
    });
  }
  function AsyncIterator(t2, e2) {
    function invoke(r3, o2, i2, a2) {
      var c2 = tryCatch(t2[r3], t2, o2);
      if ("throw" !== c2.type) {
        var u2 = c2.arg, h2 = u2.value;
        return h2 && "object" == typeof h2 && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
          invoke("next", t3, i2, a2);
        }, function(t3) {
          invoke("throw", t3, i2, a2);
        }) : e2.resolve(h2).then(function(t3) {
          u2.value = t3, i2(u2);
        }, function(t3) {
          return invoke("throw", t3, i2, a2);
        });
      }
      a2(c2.arg);
    }
    var r2;
    o(this, "_invoke", {
      value: function(t3, n2) {
        function callInvokeWithMethodAndArg() {
          return new e2(function(e3, r3) {
            invoke(t3, n2, e3, r3);
          });
        }
        return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e2, r2, n2) {
    var o2 = h;
    return function(i2, a2) {
      if (o2 === f)
        throw Error("Generator is already running");
      if (o2 === s) {
        if ("throw" === i2)
          throw a2;
        return {
          value: t,
          done: true
        };
      }
      for (n2.method = i2, n2.arg = a2; ; ) {
        var c2 = n2.delegate;
        if (c2) {
          var u2 = maybeInvokeDelegate(c2, n2);
          if (u2) {
            if (u2 === y)
              continue;
            return u2;
          }
        }
        if ("next" === n2.method)
          n2.sent = n2._sent = n2.arg;
        else if ("throw" === n2.method) {
          if (o2 === h)
            throw o2 = s, n2.arg;
          n2.dispatchException(n2.arg);
        } else
          "return" === n2.method && n2.abrupt("return", n2.arg);
        o2 = f;
        var p2 = tryCatch(e2, r2, n2);
        if ("normal" === p2.type) {
          if (o2 = n2.done ? s : l, p2.arg === y)
            continue;
          return {
            value: p2.arg,
            done: n2.done
          };
        }
        "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
      }
    };
  }
  function maybeInvokeDelegate(e2, r2) {
    var n2 = r2.method, o2 = e2.iterator[n2];
    if (o2 === t)
      return r2.delegate = null, "throw" === n2 && e2.iterator.return && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
    var i2 = tryCatch(o2, e2.iterator, r2.arg);
    if ("throw" === i2.type)
      return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
    var a2 = i2.arg;
    return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
  }
  function pushTryEntry(t2) {
    var e2 = {
      tryLoc: t2[0]
    };
    1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
  }
  function resetTryEntry(t2) {
    var e2 = t2.completion || {};
    e2.type = "normal", delete e2.arg, t2.completion = e2;
  }
  function Context(t2) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t2.forEach(pushTryEntry, this), this.reset(true);
  }
  function values(e2) {
    if (e2 || "" === e2) {
      var r2 = e2[a];
      if (r2)
        return r2.call(e2);
      if ("function" == typeof e2.next)
        return e2;
      if (!isNaN(e2.length)) {
        var o2 = -1, i2 = function next() {
          for (; ++o2 < e2.length; )
            if (n.call(e2, o2))
              return next.value = e2[o2], next.done = false, next;
          return next.value = t, next.done = true, next;
        };
        return i2.next = i2;
      }
    }
    throw new TypeError(typeof e2 + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: true
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: true
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
    var e2 = "function" == typeof t2 && t2.constructor;
    return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
  }, e.mark = function(t2) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
  }, e.awrap = function(t2) {
    return {
      __await: t2
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function() {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
    void 0 === i2 && (i2 = Promise);
    var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
    return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
      return t3.done ? t3.value : a2.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function() {
    return this;
  }), define(g, "toString", function() {
    return "[object Generator]";
  }), e.keys = function(t2) {
    var e2 = Object(t2), r2 = [];
    for (var n2 in e2)
      r2.push(n2);
    return r2.reverse(), function next() {
      for (; r2.length; ) {
        var t3 = r2.pop();
        if (t3 in e2)
          return next.value = t3, next.done = false, next;
      }
      return next.done = true, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function(e2) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2)
        for (var r2 in this)
          "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
    },
    stop: function() {
      this.done = true;
      var t2 = this.tryEntries[0].completion;
      if ("throw" === t2.type)
        throw t2.arg;
      return this.rval;
    },
    dispatchException: function(e2) {
      if (this.done)
        throw e2;
      var r2 = this;
      function handle(n2, o3) {
        return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
      }
      for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
        var i2 = this.tryEntries[o2], a2 = i2.completion;
        if ("root" === i2.tryLoc)
          return handle("end");
        if (i2.tryLoc <= this.prev) {
          var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
          if (c2 && u2) {
            if (this.prev < i2.catchLoc)
              return handle(i2.catchLoc, true);
            if (this.prev < i2.finallyLoc)
              return handle(i2.finallyLoc);
          } else if (c2) {
            if (this.prev < i2.catchLoc)
              return handle(i2.catchLoc, true);
          } else {
            if (!u2)
              throw Error("try statement without catch or finally");
            if (this.prev < i2.finallyLoc)
              return handle(i2.finallyLoc);
          }
        }
      }
    },
    abrupt: function(t2, e2) {
      for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
        var o2 = this.tryEntries[r2];
        if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
          var i2 = o2;
          break;
        }
      }
      i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
      var a2 = i2 ? i2.completion : {};
      return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
    },
    complete: function(t2, e2) {
      if ("throw" === t2.type)
        throw t2.arg;
      return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
    },
    finish: function(t2) {
      for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
        var r2 = this.tryEntries[e2];
        if (r2.finallyLoc === t2)
          return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
      }
    },
    catch: function(t2) {
      for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
        var r2 = this.tryEntries[e2];
        if (r2.tryLoc === t2) {
          var n2 = r2.completion;
          if ("throw" === n2.type) {
            var o2 = n2.arg;
            resetTryEntry(r2);
          }
          return o2;
        }
      }
      throw Error("illegal catch attempt");
    },
    delegateYield: function(e2, r2, n2) {
      return this.delegate = {
        iterator: values(e2),
        resultName: r2,
        nextLoc: n2
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
    return t2.__proto__ = e2, t2;
  }, _setPrototypeOf(t, e);
}
function _wrapNativeSuper(t) {
  var r = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
  return _wrapNativeSuper = function(t2) {
    if (null === t2 || !_isNativeFunction(t2))
      return t2;
    if ("function" != typeof t2)
      throw new TypeError("Super expression must either be null or a function");
    if (void 0 !== r) {
      if (r.has(t2))
        return r.get(t2);
      r.set(t2, Wrapper);
    }
    function Wrapper() {
      return _construct(t2, arguments, _getPrototypeOf(this).constructor);
    }
    return Wrapper.prototype = Object.create(t2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    }), _setPrototypeOf(Wrapper, t2);
  }, _wrapNativeSuper(t);
}
var API_URL = "https://api.paraswap.io";
var DEFAULT_VERSION = "6.2";
var objectToFilledEntries = function objectToFilledEntries2(object) {
  return Object.entries(object).filter(function(_ref) {
    var value = _ref[1];
    return value !== void 0;
  }).map(function(_ref2) {
    var key = _ref2[0], value = _ref2[1];
    return [key, String(value)];
  });
};
var constructSearchString = function constructSearchString2(queryOptions) {
  var queryEntries = objectToFilledEntries(queryOptions);
  var queryString = new URLSearchParams(queryEntries).toString();
  return queryString && "?" + queryString;
};
var isFetcherError = function isFetcherError2(error) {
  return error instanceof FetcherError;
};
var FetcherError = function(_Error) {
  function FetcherError2(_ref3) {
    var _this;
    var code = _ref3.code, request = _ref3.request, response = _ref3.response, isAxiosError = _ref3.isAxiosError, message = _ref3.message;
    _this = _Error.call(this) || this;
    _this.code = void 0;
    _this.status = void 0;
    _this.request = void 0;
    _this.response = void 0;
    _this.isAxiosError = false;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(_this, FetcherError2);
    }
    _this.name = _this.constructor.name;
    _this.code = code;
    _this.request = request;
    _this.isAxiosError = isAxiosError;
    if (!response) {
      _this.message = message;
      return _assertThisInitialized(_this);
    }
    _this.response = response;
    var data = response.data, status = response.status;
    _this.status = status;
    _this.message = isDataWithError(data) ? data.error : message;
    _this.message = isDataWithError2(data) ? "" + data.errorType + (data.description ? ": " + data.description : "") : _this.message;
    return _this;
  }
  _inheritsLoose(FetcherError2, _Error);
  return FetcherError2;
}(_wrapNativeSuper(Error));
function isObject(obj) {
  return !!obj && typeof obj === "object";
}
function isDataWithError(data) {
  return isObject(data) && typeof data["error"] === "string";
}
function isDataWithError2(data) {
  return isObject(data) && typeof data["errorType"] === "string";
}
var isFilledArray = function isFilledArray2(array) {
  return array.length > 0;
};
function getRandomInt() {
  return Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
}
function runOnceAndCache(func) {
  var result;
  return function() {
    var _result;
    return (_result = result) != null ? _result : result = func.apply(void 0, arguments);
  };
}
var constructGetSpender = function constructGetSpender2(_ref) {
  var _ref$apiURL = _ref.apiURL, apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL, _ref$version = _ref.version, version2 = _ref$version === void 0 ? DEFAULT_VERSION : _ref$version, chainId = _ref.chainId, fetcher = _ref.fetcher;
  var search = constructSearchString({
    network: chainId,
    version: version2
  });
  var fetchURL = apiURL + "/adapters/contracts" + search;
  var _getContracts = function() {
    var _ref2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(requestParams) {
      var data;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return fetcher({
                url: fetchURL,
                method: "GET",
                requestParams
              });
            case 2:
              data = _context.sent;
              return _context.abrupt("return", data);
            case 4:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function _getContracts2(_x) {
      return _ref2.apply(this, arguments);
    };
  }();
  var getContracts = runOnceAndCache(_getContracts);
  var getSpender = function() {
    var _ref3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(requestParams) {
      var _yield$getContracts, TokenTransferProxy;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1)
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return getContracts(requestParams);
            case 2:
              _yield$getContracts = _context2.sent;
              TokenTransferProxy = _yield$getContracts.TokenTransferProxy;
              return _context2.abrupt("return", TokenTransferProxy);
            case 5:
            case "end":
              return _context2.stop();
          }
      }, _callee2);
    }));
    return function getSpender2(_x2) {
      return _ref3.apply(this, arguments);
    };
  }();
  var getAugustusSwapper = function() {
    var _ref4 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee3(requestParams) {
      var _yield$getContracts2, AugustusSwapper;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1)
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return getContracts(requestParams);
            case 2:
              _yield$getContracts2 = _context3.sent;
              AugustusSwapper = _yield$getContracts2.AugustusSwapper;
              return _context3.abrupt("return", AugustusSwapper);
            case 5:
            case "end":
              return _context3.stop();
          }
      }, _callee3);
    }));
    return function getAugustusSwapper2(_x3) {
      return _ref4.apply(this, arguments);
    };
  }();
  var getAugustusRFQ = function() {
    var _ref5 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee4(requestParams) {
      var _yield$getContracts3, AugustusRFQ;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1)
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return getContracts(requestParams);
            case 2:
              _yield$getContracts3 = _context4.sent;
              AugustusRFQ = _yield$getContracts3.AugustusRFQ;
              return _context4.abrupt("return", AugustusRFQ);
            case 5:
            case "end":
              return _context4.stop();
          }
      }, _callee4);
    }));
    return function getAugustusRFQ2(_x4) {
      return _ref5.apply(this, arguments);
    };
  }();
  return {
    getContracts,
    getSpender,
    getAugustusSwapper,
    getAugustusRFQ
  };
};
var MinERC20Abi = [{
  constant: false,
  inputs: [{
    name: "_spender",
    type: "address"
  }, {
    name: "_value",
    type: "uint256"
  }],
  name: "approve",
  outputs: [{
    name: "",
    type: "bool"
  }],
  payable: false,
  stateMutability: "nonpayable",
  type: "function"
}];
function approveTokenMethodFactory(contractCaller, getSpender) {
  return function() {
    var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(amount, tokenAddress, overrides, requestParams) {
      var spender, res;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }
              _context.next = 3;
              return getSpender(requestParams);
            case 3:
              spender = _context.sent;
              _context.next = 6;
              return contractCaller.transactCall({
                address: tokenAddress,
                abi: MinERC20Abi,
                contractMethod: "approve",
                args: [spender, amount],
                overrides
              });
            case 6:
              res = _context.sent;
              return _context.abrupt("return", res);
            case 8:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function(_x, _x2, _x3, _x4) {
      return _ref.apply(this, arguments);
    };
  }();
}
var constructApproveToken = function constructApproveToken2(options) {
  var _constructGetSpender = constructGetSpender(options), getSpender = _constructGetSpender.getSpender;
  var approveToken = approveTokenMethodFactory(options.contractCaller, getSpender);
  var approveTokenBulk = function() {
    var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(amount, tokenAddresses, overrides, requestParams) {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", Promise.all(tokenAddresses.map(function(tokenAddress) {
                return approveToken(amount, tokenAddress, overrides, requestParams);
              })));
            case 1:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function approveTokenBulk2(_x, _x2, _x3, _x4) {
      return _ref.apply(this, arguments);
    };
  }();
  return {
    approveToken,
    approveTokenBulk
  };
};
var _excluded$a = ["tokenType", "mainConnector", "connectors", "network"];
var constructToken = function constructToken2(tokenProps) {
  var _tokenProps$tokenType = tokenProps.tokenType, tokenType = _tokenProps$tokenType === void 0 ? "ERC20" : _tokenProps$tokenType, _tokenProps$mainConne = tokenProps.mainConnector, mainConnector = _tokenProps$mainConne === void 0 ? "ETH" : _tokenProps$mainConne, _tokenProps$connector = tokenProps.connectors, connectorsInput = _tokenProps$connector === void 0 ? [] : _tokenProps$connector, _tokenProps$network = tokenProps.network, network = _tokenProps$network === void 0 ? 1 : _tokenProps$network, rest = _objectWithoutPropertiesLoose(tokenProps, _excluded$a);
  var connectors = connectorsInput.length > 0 ? connectorsInput : [mainConnector];
  return _extends({
    tokenType,
    connectors,
    mainConnector,
    network
  }, rest);
};
var isAllowance = function isAllowance2(arg) {
  return "allowance" in arg;
};
var NOT_FOUND_RESPONSE = {
  message: "Not Found"
};
var constructGetBalances = function constructGetBalances2(_ref) {
  var _ref$apiURL = _ref.apiURL, apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL, chainId = _ref.chainId, fetcher = _ref.fetcher;
  var tokensUrl = apiURL + "/users/tokens/" + chainId;
  var getBalances = function() {
    var _ref2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(userAddress, requestParams) {
      var fetchURL, data, tokens;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              fetchURL = tokensUrl + "/" + userAddress;
              _context.next = 3;
              return fetcher({
                url: fetchURL,
                method: "GET",
                requestParams
              });
            case 3:
              data = _context.sent;
              tokens = data.tokens.map(constructToken);
              return _context.abrupt("return", tokens);
            case 6:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function getBalances2(_x, _x2) {
      return _ref2.apply(this, arguments);
    };
  }();
  var getBalance = function() {
    var _ref3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(userAddress, tokenAddressOrSymbol, requestParams) {
      var fetchURL, data;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1)
          switch (_context2.prev = _context2.next) {
            case 0:
              fetchURL = tokensUrl + "/" + userAddress + "/" + tokenAddressOrSymbol;
              _context2.next = 3;
              return fetcher({
                url: fetchURL,
                method: "GET",
                requestParams
              });
            case 3:
              data = _context2.sent;
              if (data.token) {
                _context2.next = 6;
                break;
              }
              return _context2.abrupt("return", NOT_FOUND_RESPONSE);
            case 6:
              return _context2.abrupt("return", constructToken(data.token));
            case 7:
            case "end":
              return _context2.stop();
          }
      }, _callee2);
    }));
    return function getBalance2(_x3, _x4, _x5) {
      return _ref3.apply(this, arguments);
    };
  }();
  var getAllowances = function() {
    var _ref4 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee3(userAddress, tokenAddresses, requestParams) {
      var tokenAddressesLowercaseSet, balances, allowances;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1)
          switch (_context3.prev = _context3.next) {
            case 0:
              tokenAddressesLowercaseSet = new Set(tokenAddresses.map(function(address) {
                return address.toLowerCase();
              }));
              _context3.next = 3;
              return getBalances(userAddress, requestParams);
            case 3:
              balances = _context3.sent;
              allowances = balances.filter(function(token) {
                return tokenAddressesLowercaseSet.has(token.address.toLowerCase());
              }).map(function(_ref5) {
                var address = _ref5.address, _ref5$allowance = _ref5.allowance, allowance = _ref5$allowance === void 0 ? "0" : _ref5$allowance;
                return {
                  tokenAddress: address,
                  allowance
                };
              });
              return _context3.abrupt("return", allowances);
            case 6:
            case "end":
              return _context3.stop();
          }
      }, _callee3);
    }));
    return function getAllowances2(_x6, _x7, _x8) {
      return _ref4.apply(this, arguments);
    };
  }();
  var getAllowance = function() {
    var _ref6 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee4(userAddress, tokenAddress, requestParams) {
      var balanceOrNotFound, address, _balanceOrNotFound$al, allowance;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1)
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return getBalance(userAddress, tokenAddress, requestParams);
            case 2:
              balanceOrNotFound = _context4.sent;
              if (!("message" in balanceOrNotFound)) {
                _context4.next = 5;
                break;
              }
              return _context4.abrupt("return", balanceOrNotFound);
            case 5:
              address = balanceOrNotFound.address, _balanceOrNotFound$al = balanceOrNotFound.allowance, allowance = _balanceOrNotFound$al === void 0 ? "0" : _balanceOrNotFound$al;
              return _context4.abrupt("return", {
                tokenAddress: address,
                allowance
              });
            case 7:
            case "end":
              return _context4.stop();
          }
      }, _callee4);
    }));
    return function getAllowance2(_x9, _x10, _x11) {
      return _ref6.apply(this, arguments);
    };
  }();
  return {
    getBalance,
    getBalances,
    getAllowance,
    getAllowances
  };
};
var constructGetAdapters = function constructGetAdapters2(_ref) {
  var _ref$apiURL = _ref.apiURL, apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL, _ref$version = _ref.version, version2 = _ref$version === void 0 ? DEFAULT_VERSION : _ref$version, chainId = _ref.chainId, fetcher = _ref.fetcher;
  var getAdapters = function() {
    var _ref2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(requestParams) {
      var query, fetchURL, data;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              query = constructSearchString({
                network: chainId,
                version: version2
              });
              fetchURL = apiURL + "/adapters/list" + query;
              _context.next = 4;
              return fetcher({
                url: fetchURL,
                method: "GET",
                requestParams
              });
            case 4:
              data = _context.sent;
              return _context.abrupt("return", data);
            case 6:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function getAdapters2(_x) {
      return _ref2.apply(this, arguments);
    };
  }();
  return {
    getAdapters
  };
};
var _excluded$9 = ["options"];
var _excluded2$4 = ["excludeContractMethods", "includeContractMethods", "partner", "includeDEXS", "excludeDEXS", "excludePools"];
function normalizeRateOptions(_ref) {
  var _ref$options = _ref.options, options = _ref$options === void 0 ? {} : _ref$options, restInput = _objectWithoutPropertiesLoose(_ref, _excluded$9);
  var excludeContractMethods = options.excludeContractMethods, includeContractMethods = options.includeContractMethods, partner = options.partner, includeDEXS = options.includeDEXS, excludeDEXS = options.excludeDEXS, excludePools = options.excludePools, restOptions = _objectWithoutPropertiesLoose(options, _excluded2$4);
  var _map = [
    includeDEXS,
    excludeDEXS,
    excludePools,
    excludeContractMethods,
    includeContractMethods
    //                                                                                              no "" empty string
  ].map(function(array) {
    return (array == null ? void 0 : array.join(",")) || void 0;
  }), _includeDEXS = _map[0], _excludeDEXS = _map[1], _excludePools = _map[2], _excludeContractMethods = _map[3], _includeContractMethods = _map[4];
  var transformed = {
    excludeContractMethods: _excludeContractMethods,
    includeContractMethods: _includeContractMethods,
    partner,
    includeDEXS: _includeDEXS,
    excludeDEXS: _excludeDEXS,
    excludePools: _excludePools
  };
  return _extends({}, transformed, restOptions, restInput);
}
var _excluded$8 = ["srcToken", "destToken"];
var _excluded2$3 = ["route"];
var INVALID_ROUTE = "Invalid Route";
var constructGetRate = function constructGetRate2(_ref) {
  var _ref$apiURL = _ref.apiURL, apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL, _ref$version = _ref.version, version2 = _ref$version === void 0 ? DEFAULT_VERSION : _ref$version, chainId = _ref.chainId, fetcher = _ref.fetcher;
  var pricesUrl = apiURL + "/prices";
  var getRate = function() {
    var _ref3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(_ref2, requestParams) {
      var srcToken, destToken, rest, parsedOptions, search, fetchURL, data;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              srcToken = _ref2.srcToken, destToken = _ref2.destToken, rest = _objectWithoutPropertiesLoose(_ref2, _excluded$8);
              parsedOptions = normalizeRateOptions(rest);
              search = constructSearchString(_extends({
                srcToken,
                destToken,
                network: chainId,
                version: version2
              }, parsedOptions));
              fetchURL = pricesUrl + "/" + search;
              _context.next = 6;
              return fetcher({
                url: fetchURL,
                method: "GET",
                requestParams
              });
            case 6:
              data = _context.sent;
              return _context.abrupt("return", data.priceRoute);
            case 8:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function getRate2(_x, _x2) {
      return _ref3.apply(this, arguments);
    };
  }();
  var getRateByRoute = function() {
    var _ref5 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(_ref4, requestParams) {
      var route, rest, parsedOptions, _route, search, fetchURL, data;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1)
          switch (_context2.prev = _context2.next) {
            case 0:
              route = _ref4.route, rest = _objectWithoutPropertiesLoose(_ref4, _excluded2$3);
              if (!(route.length < 2)) {
                _context2.next = 3;
                break;
              }
              throw new Error(INVALID_ROUTE);
            case 3:
              parsedOptions = normalizeRateOptions(rest);
              _route = route.join("-");
              search = constructSearchString(_extends({
                route: _route,
                // route can be used in place of srcToken+destToken
                network: chainId,
                version: version2
              }, parsedOptions));
              fetchURL = pricesUrl + "/" + search;
              _context2.next = 9;
              return fetcher({
                url: fetchURL,
                method: "GET",
                requestParams
              });
            case 9:
              data = _context2.sent;
              return _context2.abrupt("return", data.priceRoute);
            case 11:
            case "end":
              return _context2.stop();
          }
      }, _callee2);
    }));
    return function getRateByRoute2(_x3, _x4) {
      return _ref5.apply(this, arguments);
    };
  }();
  return {
    getRate,
    getRateByRoute
  };
};
var _excluded$7 = ["srcToken", "destToken", "amount", "route"];
var constructSwapTx = function constructSwapTx2(_ref) {
  var _ref$apiURL = _ref.apiURL, apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL, _ref$version = _ref.version, version2 = _ref$version === void 0 ? DEFAULT_VERSION : _ref$version, chainId = _ref.chainId, fetcher = _ref.fetcher;
  var pricesUrl = apiURL + "/swap";
  var getSwapTxData = function() {
    var _ref3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(_ref2, requestParams) {
      var srcToken, destToken, amount, route, rest, parsedOptions, _route, search, fetchURL, data;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              srcToken = _ref2.srcToken, destToken = _ref2.destToken, amount = _ref2.amount, route = _ref2.route, rest = _objectWithoutPropertiesLoose(_ref2, _excluded$7);
              parsedOptions = normalizeRateOptions(rest);
              _route = route == null ? void 0 : route.join("-");
              search = constructSearchString(_extends({
                amount,
                srcToken,
                destToken,
                route: _route,
                network: chainId,
                version: version2
              }, parsedOptions));
              fetchURL = pricesUrl + "/" + search;
              _context.next = 7;
              return fetcher({
                url: fetchURL,
                method: "GET",
                requestParams
              });
            case 7:
              data = _context.sent;
              return _context.abrupt("return", data);
            case 9:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function getSwapTxData2(_x, _x2) {
      return _ref3.apply(this, arguments);
    };
  }();
  return {
    getSwapTxData
  };
};
var constructGetTokens = function constructGetTokens2(_ref) {
  var _ref$apiURL = _ref.apiURL, apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL, chainId = _ref.chainId, fetcher = _ref.fetcher;
  var fetchURL = apiURL + "/tokens/" + chainId;
  var getTokens = function() {
    var _ref2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(requestParams) {
      var data, tokens;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return fetcher({
                url: fetchURL,
                method: "GET",
                requestParams
              });
            case 2:
              data = _context.sent;
              tokens = data.tokens.map(constructToken);
              return _context.abrupt("return", tokens);
            case 5:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function getTokens2(_x) {
      return _ref2.apply(this, arguments);
    };
  }();
  return {
    getTokens
  };
};
var name = "AUGUSTUS RFQ";
var version = "1";
var ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
function baseFetchUrlGetterFactory(orderKind) {
  return function constructBaseFetchUrlGetter2(_ref) {
    var chainId = _ref.chainId, apiURL = _ref.apiURL;
    function urlGetter(type) {
      if (!type)
        return apiURL + "/" + orderKind + "/order";
      if (type === "fillablebalance")
        return apiURL + "/" + orderKind + "/fillablebalance/" + chainId;
      var orderURLpart = type === "LIMIT" ? "orders" : "p2p";
      return apiURL + "/" + orderKind + "/" + orderURLpart + "/" + chainId;
    }
    return urlGetter;
  };
}
function sanitizeOrderData$1(_ref) {
  var nonceAndMeta = _ref.nonceAndMeta, expiry = _ref.expiry, makerAsset = _ref.makerAsset, takerAsset = _ref.takerAsset, maker = _ref.maker, taker = _ref.taker, makerAmount = _ref.makerAmount, takerAmount = _ref.takerAmount;
  return {
    nonceAndMeta,
    expiry,
    makerAsset,
    takerAsset,
    maker,
    taker,
    makerAmount,
    takerAmount
  };
}
var constructBaseFetchUrlGetter$1 = baseFetchUrlGetterFactory("ft");
var OrderNFT = [{
  name: "nonceAndMeta",
  type: "uint256"
}, {
  name: "expiry",
  type: "uint128"
}, {
  name: "makerAsset",
  type: "uint256"
}, {
  name: "makerAssetId",
  type: "uint256"
}, {
  name: "takerAsset",
  type: "uint256"
}, {
  name: "takerAssetId",
  type: "uint256"
}, {
  name: "maker",
  type: "address"
}, {
  name: "taker",
  type: "address"
}, {
  name: "makerAmount",
  type: "uint256"
}, {
  name: "takerAmount",
  type: "uint256"
}];
function buildOrderData$1(_ref) {
  var chainId = _ref.chainId, verifyingContract = _ref.verifyingContract, _ref$nonce = _ref.nonce, nonce = _ref$nonce === void 0 ? getRandomInt() : _ref$nonce, expiry = _ref.expiry, _makerAssetAddress = _ref.makerAsset, _takerAssetAddress = _ref.takerAsset, makerAmount = _ref.makerAmount, takerAmount = _ref.takerAmount, makerAssetId = _ref.makerAssetId, _ref$takerAssetId = _ref.takerAssetId, takerAssetId = _ref$takerAssetId === void 0 ? "0" : _ref$takerAssetId, makerAssetType = _ref.makerAssetType, takerAssetType = _ref.takerAssetType, maker = _ref.maker, AugustusAddress = _ref.AugustusAddress, _ref$taker = _ref.taker, takerInNonce = _ref$taker === void 0 ? ZERO_ADDRESS : _ref$taker;
  var nonceAndMeta = (BigInt(takerInNonce) + (BigInt(nonce) << BigInt(160))).toString(10);
  var makerAsset = assetAddressToUint(_makerAssetAddress, makerAssetType);
  var takerAsset = assetAddressToUint(_takerAssetAddress, takerAssetType);
  var orderNFT = {
    nonceAndMeta,
    expiry,
    makerAsset,
    takerAsset,
    maker,
    taker: AugustusAddress,
    makerAmount,
    takerAmount,
    makerAssetId,
    takerAssetId
  };
  return {
    types: {
      OrderNFT
    },
    domain: {
      name,
      version,
      chainId,
      verifyingContract
    },
    data: orderNFT
  };
}
function assetAddressToUint(assetAddress, assetType) {
  return (BigInt(assetAddress) + (BigInt(assetType) << BigInt(160))).toString(10);
}
var AssetType = {
  ERC20: 0,
  ERC1155: 1,
  ERC721: 2
};
function sanitizeOrderData(_ref) {
  var nonceAndMeta = _ref.nonceAndMeta, expiry = _ref.expiry, _makerAsset = _ref.makerAsset, _takerAsset = _ref.takerAsset, maker = _ref.maker, taker = _ref.taker, makerAmount = _ref.makerAmount, takerAmount = _ref.takerAmount, makerAssetId = _ref.makerAssetId, takerAssetId = _ref.takerAssetId, makerAssetType = _ref.makerAssetType, takerAssetType = _ref.takerAssetType;
  var makerAsset = makerAssetType !== void 0 && _makerAsset.startsWith("0x") ? assetAddressToUint(_makerAsset, makerAssetType) : _makerAsset;
  var takerAsset = takerAssetType !== void 0 && _takerAsset.startsWith("0x") ? assetAddressToUint(_takerAsset, takerAssetType) : _takerAsset;
  return {
    nonceAndMeta,
    expiry,
    makerAsset,
    takerAsset,
    maker,
    taker,
    makerAmount,
    takerAmount,
    makerAssetId,
    takerAssetId
  };
}
var constructBaseFetchUrlGetter = baseFetchUrlGetterFactory("nft");
var constructBuildTx = function constructBuildTx2(_ref) {
  var _ref$apiURL = _ref.apiURL, apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL, chainId = _ref.chainId, fetcher = _ref.fetcher;
  var transactionsURL = apiURL + "/transactions/" + chainId;
  var buildTx = function() {
    var _ref2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(params, options, requestParams) {
      var _params$takeSurplus;
      var priceRoute, side, AmountMismatchError, search, fetchURL, sanitizedParams, takeSurplus, fetchParams, builtTx;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              if (options === void 0) {
                options = {};
              }
              if ("priceRoute" in params && "destAmount" in params && // isn't provided together with `orders`
              !("orders" in params)) {
                priceRoute = params.priceRoute, side = params.priceRoute.side;
                AmountMismatchError = side === import_core.SwapSide.SELL ? "Source Amount Mismatch" : "Destination Amount Mismatch";
                (0, import_ts_essentials.assert)(areAmountsCorrect({
                  queryParams: params,
                  side,
                  priceRoute
                }), AmountMismatchError);
              }
              search = constructSearchString(options);
              fetchURL = transactionsURL + "/" + search;
              sanitizedParams = "orders" in params && params.orders.length > 0 ? _extends({}, params, {
                //  make sure we don't pass more with orders than API expects
                orders: params.orders.map(function(order) {
                  var sanitizedOrderData = "makerAssetId" in order ? sanitizeOrderData(order) : (
                    // if Order received from API by hash
                    sanitizeOrderData$1(order)
                  );
                  var sanitizedOrder = _extends({}, sanitizedOrderData, {
                    signature: order.signature
                  });
                  if (order.permitMakerAsset) {
                    sanitizedOrder.permitMakerAsset = order.permitMakerAsset;
                  }
                  return sanitizedOrder;
                })
              }) : params;
              takeSurplus = (_params$takeSurplus = params.takeSurplus) != null ? _params$takeSurplus : params.positiveSlippageToUser !== void 0 ? !params.positiveSlippageToUser : void 0;
              if ("positiveSlippageToUser" in sanitizedParams) {
                delete sanitizedParams.positiveSlippageToUser;
              }
              if (takeSurplus !== void 0) {
                sanitizedParams.takeSurplus = takeSurplus;
              }
              fetchParams = {
                url: fetchURL,
                method: "POST",
                data: sanitizedParams,
                requestParams
              };
              _context.next = 11;
              return fetcher(fetchParams);
            case 11:
              builtTx = _context.sent;
              return _context.abrupt("return", builtTx);
            case 13:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function buildTx2(_x, _x2, _x3) {
      return _ref2.apply(this, arguments);
    };
  }();
  return {
    buildTx
  };
};
function areAmountsCorrect(_ref3) {
  var queryParams = _ref3.queryParams, side = _ref3.side, priceRoute = _ref3.priceRoute;
  if (queryParams.slippage) {
    return side === import_core.SwapSide.BUY && queryParams.destAmount === priceRoute.destAmount || side === import_core.SwapSide.SELL && queryParams.srcAmount === priceRoute.srcAmount;
  }
  var _ref4 = side === import_core.SwapSide.SELL ? [queryParams.srcAmount, priceRoute.srcAmount] : [queryParams.destAmount, priceRoute.destAmount], inputAmount = _ref4[0], priceRouteAmount = _ref4[1];
  return inputAmount === priceRouteAmount;
}
var Order = [{
  name: "nonceAndMeta",
  type: "uint256"
}, {
  name: "expiry",
  type: "uint128"
}, {
  name: "makerAsset",
  type: "address"
}, {
  name: "takerAsset",
  type: "address"
}, {
  name: "maker",
  type: "address"
}, {
  name: "taker",
  type: "address"
}, {
  name: "makerAmount",
  type: "uint256"
}, {
  name: "takerAmount",
  type: "uint256"
}];
function buildOrderData(_ref) {
  var chainId = _ref.chainId, verifyingContract = _ref.verifyingContract, _ref$nonce = _ref.nonce, nonce = _ref$nonce === void 0 ? getRandomInt() : _ref$nonce, expiry = _ref.expiry, makerAsset = _ref.makerAsset, takerAsset = _ref.takerAsset, makerAmount = _ref.makerAmount, takerAmount = _ref.takerAmount, maker = _ref.maker, AugustusAddress = _ref.AugustusAddress, _ref$taker = _ref.taker, takerInNonce = _ref$taker === void 0 ? ZERO_ADDRESS : _ref$taker, contractTaker = _ref.contractTaker, AppVersion = _ref.AppVersion;
  var nonceAndMeta = (BigInt(takerInNonce) + (BigInt(nonce) << BigInt(160))).toString(10);
  var taker;
  if (contractTaker) {
    taker = contractTaker;
  } else if (takerInNonce === ZERO_ADDRESS) {
    taker = ZERO_ADDRESS;
  } else {
    if (AppVersion.startsWith("6.")) {
      taker = takerInNonce;
    } else {
      taker = AugustusAddress;
    }
  }
  var order = {
    nonceAndMeta,
    expiry,
    makerAsset,
    takerAsset,
    maker,
    taker,
    makerAmount,
    takerAmount
  };
  return {
    types: {
      Order
    },
    domain: {
      name,
      version,
      chainId,
      verifyingContract
    },
    data: order
  };
}
var constructBuildLimitOrder = function constructBuildLimitOrder2(options) {
  var chainId = options.chainId;
  var _constructGetSpender = constructGetSpender(options), getContracts = _constructGetSpender.getContracts;
  var buildLimitOrder = function() {
    var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(buildLimitOrderParams, requestParams) {
      var _options$version;
      var _yield$getContracts, AugustusAddress, verifyingContract, AppVersion;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return getContracts(requestParams);
            case 2:
              _yield$getContracts = _context.sent;
              AugustusAddress = _yield$getContracts.AugustusSwapper;
              verifyingContract = _yield$getContracts.AugustusRFQ;
              AppVersion = (_options$version = options.version) != null ? _options$version : DEFAULT_VERSION;
              return _context.abrupt("return", buildOrderData(_extends({}, buildLimitOrderParams, {
                chainId,
                verifyingContract,
                AugustusAddress,
                AppVersion
              })));
            case 7:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function buildLimitOrder2(_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }();
  return {
    buildLimitOrder
  };
};
var constructSignLimitOrder = function constructSignLimitOrder2(options) {
  var signLimitOrder = function signLimitOrder2(typedData) {
    var typedDataOnly = _extends({}, typedData, {
      data: sanitizeOrderData$1(typedData.data)
    });
    return options.contractCaller.signTypedDataCall(typedDataOnly);
  };
  return {
    signLimitOrder
  };
};
var MinAugustusRFQAbi$1 = [{
  inputs: [{
    internalType: "bytes32",
    name: "orderHash",
    type: "bytes32"
  }],
  name: "cancelOrder",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "bytes32[]",
    name: "orderHashes",
    type: "bytes32[]"
  }],
  name: "cancelOrders",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}];
var constructCancelLimitOrder = function constructCancelLimitOrder2(options) {
  var _constructGetSpender = constructGetSpender(options), getAugustusRFQ = _constructGetSpender.getAugustusRFQ;
  var cancelLimitOrder = function() {
    var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(orderHash, overrides, requestParams) {
      var verifyingContract, res;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }
              _context.next = 3;
              return getAugustusRFQ(requestParams);
            case 3:
              verifyingContract = _context.sent;
              _context.next = 6;
              return options.contractCaller.transactCall({
                // @CHECK if verifyingContract is the one we need to approve
                // maybe a Proxy in-between
                address: verifyingContract,
                abi: MinAugustusRFQAbi$1,
                contractMethod: "cancelOrder",
                args: [orderHash],
                overrides
              });
            case 6:
              res = _context.sent;
              return _context.abrupt("return", res);
            case 8:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function cancelLimitOrder2(_x, _x2, _x3) {
      return _ref.apply(this, arguments);
    };
  }();
  var cancelLimitOrderBulk = function() {
    var _ref2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(orderHashes, overrides, requestParams) {
      var verifyingContract, res;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1)
          switch (_context2.prev = _context2.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }
              _context2.next = 3;
              return getAugustusRFQ(requestParams);
            case 3:
              verifyingContract = _context2.sent;
              _context2.next = 6;
              return options.contractCaller.transactCall({
                // @CHECK if verifyingContract is the one we need to approve
                // maybe a Proxy in-between
                address: verifyingContract,
                abi: MinAugustusRFQAbi$1,
                contractMethod: "cancelOrders",
                args: [orderHashes],
                overrides
              });
            case 6:
              res = _context2.sent;
              return _context2.abrupt("return", res);
            case 8:
            case "end":
              return _context2.stop();
          }
      }, _callee2);
    }));
    return function cancelLimitOrderBulk2(_x4, _x5, _x6) {
      return _ref2.apply(this, arguments);
    };
  }();
  return {
    cancelLimitOrder,
    cancelLimitOrderBulk
  };
};
function splitSignature(signature) {
  if (signature.startsWith("0x")) {
    signature = signature.slice(2);
  }
  var bytes = new Uint8Array(signature.length / 2);
  for (var i = 0; i < signature.length; i += 2) {
    bytes[i / 2] = parseInt(signature.slice(i, i + 2), 16);
  }
  if (bytes.length !== 64 && bytes.length !== 65) {
    throw new Error("Invalid signature length: must be 64 or 65 bytes");
  }
  var r = "0x" + Array.from(bytes.slice(0, 32), function(b) {
    return b.toString(16).padStart(2, "0");
  }).join("");
  var s;
  var v;
  if (bytes.length === 64) {
    v = 27 + (bytes[32] >> 7);
    bytes[32] &= 127;
    s = "0x" + Array.from(bytes.slice(32, 64)).map(function(b) {
      return b.toString(16).padStart(2, "0");
    }).join("");
  } else {
    s = "0x" + Array.from(bytes.slice(32, 64)).map(function(b) {
      return b.toString(16).padStart(2, "0");
    }).join("");
    v = bytes[64];
    if (v < 27) {
      v += 27;
    }
  }
  var sBytes = Array.from(bytes.slice(32, 64));
  if (v === 28) {
    sBytes[0] |= 128;
  }
  var yParityAndS = "0x" + sBytes.map(function(b) {
    return b.toString(16).padStart(2, "0");
  }).join("");
  var compactSignature = r + yParityAndS.slice(2);
  return {
    v,
    r,
    s,
    compact: compactSignature
  };
}
function encodeEIP_2612PermitFunctionInput(_ref) {
  var owner = _ref.owner, spender = _ref.spender, value = _ref.value, deadline = _ref.deadline, permitSignature = _ref.permitSignature;
  var _splitSignature = splitSignature(permitSignature), v = _splitSignature.v, r = _splitSignature.r, s = _splitSignature.s;
  var encodedOwner = encodeAddress(owner);
  var encodedSpender = encodeAddress(spender);
  var encodedValue = encodeUint256(value);
  var encodedDeadline = encodeUint256(deadline.toString());
  var encodedV = encodeUint8(v);
  var encodedR = encodeBytes32(r);
  var encodedS = encodeBytes32(s);
  return "0x" + [encodedOwner, encodedSpender, encodedValue, encodedDeadline, encodedV, encodedR, encodedS].map(function(val) {
    return val.slice(2);
  }).join("");
}
function encodeDAIlikePermitFunctionInput(_ref2) {
  var permitSignature = _ref2.permitSignature, holder = _ref2.holder, spender = _ref2.spender, nonce = _ref2.nonce, expiry = _ref2.expiry;
  var _splitSignature2 = splitSignature(permitSignature), v = _splitSignature2.v, r = _splitSignature2.r, s = _splitSignature2.s;
  var encodedHolder = encodeAddress(holder);
  var encodedSpender = encodeAddress(spender);
  var encodedNonce = encodeUint256(nonce.toString());
  var encodedExpiry = encodeUint256(expiry.toString());
  var encodedV = encodeUint8(v);
  var encodedR = encodeBytes32(r);
  var encodedS = encodeBytes32(s);
  return "0x" + [
    encodedHolder,
    encodedSpender,
    encodedNonce,
    encodedExpiry,
    encodeBool(true),
    //allowed=true
    encodedV,
    encodedR,
    encodedS
  ].map(function(val) {
    return val.slice(2);
  }).join("");
}
function encodeAddress(address) {
  var strippedAddress = address.replace(/^0x/, "");
  return "0x" + strippedAddress.toLowerCase().padStart(64, "0");
}
function encodeUint256(value) {
  var bn = BigInt(value);
  return "0x" + bn.toString(16).padStart(64, "0");
}
function encodeUint8(value) {
  return "0x" + value.toString(16).padStart(64, "0");
}
function encodeBytes32(value) {
  var strippedValue = value.replace(/^0x/, "");
  return "0x" + strippedValue.padStart(64, "0").toLowerCase();
}
function encodeBool(value) {
  var encodedValue = value ? "1" : "0";
  return "0x" + encodedValue.padStart(64, "0");
}
var MinAugustusRFQAbi = [{
  inputs: [{
    components: [{
      internalType: "uint256",
      name: "nonceAndMeta",
      type: "uint256"
    }, {
      internalType: "uint128",
      name: "expiry",
      type: "uint128"
    }, {
      internalType: "address",
      name: "makerAsset",
      type: "address"
    }, {
      internalType: "address",
      name: "takerAsset",
      type: "address"
    }, {
      internalType: "address",
      name: "maker",
      type: "address"
    }, {
      internalType: "address",
      name: "taker",
      type: "address"
    }, {
      internalType: "uint256",
      name: "makerAmount",
      type: "uint256"
    }, {
      internalType: "uint256",
      name: "takerAmount",
      type: "uint256"
    }],
    internalType: "struct AugustusRFQ.Order",
    name: "order",
    type: "tuple"
  }, {
    internalType: "bytes",
    name: "signature",
    type: "bytes"
  }],
  name: "fillOrder",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    components: [{
      internalType: "uint256",
      name: "nonceAndMeta",
      type: "uint256"
    }, {
      internalType: "uint128",
      name: "expiry",
      type: "uint128"
    }, {
      internalType: "address",
      name: "makerAsset",
      type: "address"
    }, {
      internalType: "address",
      name: "takerAsset",
      type: "address"
    }, {
      internalType: "address",
      name: "maker",
      type: "address"
    }, {
      internalType: "address",
      name: "taker",
      type: "address"
    }, {
      internalType: "uint256",
      name: "makerAmount",
      type: "uint256"
    }, {
      internalType: "uint256",
      name: "takerAmount",
      type: "uint256"
    }],
    internalType: "struct AugustusRFQ.Order",
    name: "order",
    type: "tuple"
  }, {
    internalType: "bytes",
    name: "signature",
    type: "bytes"
  }, {
    internalType: "uint256",
    name: "takerTokenFillAmount",
    type: "uint256"
  }, {
    internalType: "address",
    name: "target",
    type: "address"
  }, {
    internalType: "bytes",
    name: "permitTakerAsset",
    type: "bytes"
  }, {
    internalType: "bytes",
    name: "permitMakerAsset",
    type: "bytes"
  }],
  name: "partialFillOrderWithTargetPermit",
  outputs: [{
    internalType: "uint256",
    name: "makerTokenFilledAmount",
    type: "uint256"
  }],
  stateMutability: "nonpayable",
  type: "function"
}];
function constructFillOrderDirectly(options) {
  var _constructGetSpender = constructGetSpender(options), getAugustusRFQ = _constructGetSpender.getAugustusRFQ;
  var fillOrderDirectly = function() {
    var _ref2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(_ref, overrides, requestParams) {
      var order, signature, takerPermit, AugustusRFQ, sanitizedOrder, _res, permitTakerAsset, res;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              order = _ref.order, signature = _ref.signature, takerPermit = _ref.takerPermit;
              if (overrides === void 0) {
                overrides = {};
              }
              _context.next = 4;
              return getAugustusRFQ(requestParams);
            case 4:
              AugustusRFQ = _context.sent;
              sanitizedOrder = sanitizeOrderData$1(order);
              if (takerPermit) {
                _context.next = 11;
                break;
              }
              _context.next = 9;
              return options.contractCaller.transactCall({
                address: AugustusRFQ,
                abi: MinAugustusRFQAbi,
                contractMethod: "fillOrder",
                args: [sanitizedOrder, signature],
                overrides
              });
            case 9:
              _res = _context.sent;
              return _context.abrupt("return", _res);
            case 11:
              if ("encodedPermitParams" in takerPermit) {
                permitTakerAsset = takerPermit.encodedPermitParams;
              } else if ("isDaiPermit" in takerPermit && takerPermit.isDaiPermit) {
                permitTakerAsset = encodeDAIlikePermitFunctionInput({
                  holder: order.taker,
                  spender: AugustusRFQ,
                  expiry: takerPermit.expiry,
                  nonce: takerPermit.nonce,
                  permitSignature: takerPermit.signature
                });
              } else {
                permitTakerAsset = encodeEIP_2612PermitFunctionInput({
                  owner: order.taker,
                  spender: AugustusRFQ,
                  value: takerPermit.amount || order.takerAmount,
                  // can use permit with a bigger value, fallback to exact Order takerAmount
                  deadline: takerPermit.deadline,
                  permitSignature: takerPermit.signature
                });
              }
              _context.next = 14;
              return options.contractCaller.transactCall({
                address: AugustusRFQ,
                abi: MinAugustusRFQAbi,
                contractMethod: "partialFillOrderWithTargetPermit",
                args: [
                  sanitizedOrder,
                  // order
                  signature,
                  // order.signature
                  order.takerAmount,
                  // takerTokenFillAmount, can even partially fill
                  order.taker,
                  // target
                  permitTakerAsset,
                  "0x"
                  // permitMakerAsset, unused because hard to account for changing nonce for long running Orders
                ],
                overrides
              });
            case 14:
              res = _context.sent;
              return _context.abrupt("return", res);
            case 16:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function fillOrderDirectly2(_x, _x2, _x3) {
      return _ref2.apply(this, arguments);
    };
  }();
  return {
    fillOrderDirectly
  };
}
var constructGetLimitOrders = function constructGetLimitOrders2(_ref) {
  var _ref$apiURL = _ref.apiURL, apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL, chainId = _ref.chainId, fetcher = _ref.fetcher;
  var getBaseFetchURLByEntityType = constructBaseFetchUrlGetter$1({
    apiURL,
    chainId
  });
  var getLimitOrders = function() {
    var _ref2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(userParams, requestParams) {
      var baseFetchURL, userURL, offset, limit, hideSmallBalances, orderBy, search, fetchURL, response;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              baseFetchURL = getBaseFetchURLByEntityType(userParams.type);
              userURL = "maker" in userParams ? "maker/" + userParams.maker : "taker/" + userParams.taker;
              offset = userParams.offset, limit = userParams.limit, hideSmallBalances = userParams.hideSmallBalances, orderBy = userParams.orderBy;
              search = constructSearchString({
                offset,
                limit,
                hideSmallBalances,
                orderBy
              });
              fetchURL = baseFetchURL + "/" + userURL + search;
              _context.next = 7;
              return fetcher({
                url: fetchURL,
                method: "GET",
                requestParams
              });
            case 7:
              response = _context.sent;
              return _context.abrupt("return", response);
            case 9:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function getLimitOrders2(_x, _x2) {
      return _ref2.apply(this, arguments);
    };
  }();
  var getRequiredBalance = function() {
    var _ref3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(userParams, requestParams) {
      var baseFetchURL, userURL, fetchURL, response;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1)
          switch (_context2.prev = _context2.next) {
            case 0:
              baseFetchURL = getBaseFetchURLByEntityType("fillablebalance");
              userURL = baseFetchURL + "/" + userParams.maker;
              fetchURL = userParams.token ? userURL + "/" + userParams.token : userURL;
              _context2.next = 5;
              return fetcher({
                url: fetchURL,
                method: "GET",
                requestParams
              });
            case 5:
              response = _context2.sent;
              return _context2.abrupt("return", response);
            case 7:
            case "end":
              return _context2.stop();
          }
      }, _callee2);
    }));
    return function getRequiredBalance2(_x3, _x4) {
      return _ref3.apply(this, arguments);
    };
  }();
  var getLimitOrderByHash = function() {
    var _ref4 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee3(orderHash, requestParams) {
      var baseFetchURL, fetchURL, order;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1)
          switch (_context3.prev = _context3.next) {
            case 0:
              baseFetchURL = getBaseFetchURLByEntityType();
              fetchURL = baseFetchURL + "/" + orderHash;
              _context3.next = 4;
              return fetcher({
                url: fetchURL,
                method: "GET",
                requestParams
              });
            case 4:
              order = _context3.sent;
              return _context3.abrupt("return", order);
            case 6:
            case "end":
              return _context3.stop();
          }
      }, _callee3);
    }));
    return function getLimitOrderByHash2(_x5, _x6) {
      return _ref4.apply(this, arguments);
    };
  }();
  return {
    getLimitOrders,
    getLimitOrderByHash,
    getRequiredBalance
  };
};
var constructPostLimitOrder = function constructPostLimitOrder2(_ref) {
  var _ref$apiURL = _ref.apiURL, apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL, chainId = _ref.chainId, fetcher = _ref.fetcher;
  var getBaseFetchURLByOrderType = constructBaseFetchUrlGetter$1({
    apiURL,
    chainId
  });
  var postTypedOrder = function() {
    var _ref2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(limitOrderWithSignatureAndPermit, type, requestParams) {
      var fetchURL, _yield$fetcher, newOrder;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              fetchURL = getBaseFetchURLByOrderType(type);
              _context.next = 3;
              return fetcher({
                url: fetchURL,
                method: "POST",
                data: limitOrderWithSignatureAndPermit,
                requestParams
              });
            case 3:
              _yield$fetcher = _context.sent;
              newOrder = _yield$fetcher.order;
              return _context.abrupt("return", newOrder);
            case 6:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function postTypedOrder2(_x, _x2, _x3) {
      return _ref2.apply(this, arguments);
    };
  }();
  var postLimitOrder = function postLimitOrder2(limitOrderWithSignatureAndPermit, requestParams) {
    return postTypedOrder(limitOrderWithSignatureAndPermit, "LIMIT", requestParams);
  };
  var postP2POrder = function postP2POrder2(limitOrderWithSignatureAndPermit, requestParams) {
    return postTypedOrder(limitOrderWithSignatureAndPermit, "P2P", requestParams);
  };
  return {
    postLimitOrder,
    postP2POrder
  };
};
var constructApproveTokenForLimitOrder = function constructApproveTokenForLimitOrder2(options) {
  var _constructGetSpender = constructGetSpender(options), getAugustusRFQ = _constructGetSpender.getAugustusRFQ;
  var approveMakerTokenForLimitOrder = approveTokenMethodFactory(options.contractCaller, getAugustusRFQ);
  var _constructApproveToke = constructApproveToken(options), approveTakerTokenForLimitOrder = _constructApproveToke.approveToken;
  return {
    approveMakerTokenForLimitOrder,
    approveTakerTokenForFillingP2POrderDirectly: approveMakerTokenForLimitOrder,
    approveTakerTokenForLimitOrder
  };
};
var constructGetLimitOrdersContract = function constructGetLimitOrdersContract2(options) {
  var _constructGetSpender = constructGetSpender(options), getTokenTransferProxy = _constructGetSpender.getSpender, getLimitOrdersContract = _constructGetSpender.getAugustusRFQ;
  return {
    getLimitOrdersContract,
    getTokenTransferProxy
  };
};
var _excluded$6 = ["srcToken", "destToken", "amount", "options"];
var constructBuildLimitOrderTx = function constructBuildLimitOrderTx2(_ref) {
  var _ref$apiURL = _ref.apiURL, apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL, _ref$version = _ref.version, version2 = _ref$version === void 0 ? DEFAULT_VERSION : _ref$version, chainId = _ref.chainId, fetcher = _ref.fetcher;
  var _constructBuildTx = constructBuildTx({
    apiURL,
    chainId,
    fetcher,
    version: version2
  }), buildSwapTx = _constructBuildTx.buildTx;
  var _constructGetRate = constructGetRate({
    apiURL,
    version: version2,
    chainId,
    fetcher
  }), getSwapAndLimitOrderRate = _constructGetRate.getRate;
  var getLimitOrdersRate = function() {
    var _ref3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(_ref2, orders, requestParams) {
      var srcToken, destToken, amount, _ref2$options, _options, rest, _checkAndParseOrders, totalTakerAmount, takerAsset, takerAmountString, options, side, rateInput, optimalRate;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              srcToken = _ref2.srcToken, destToken = _ref2.destToken, amount = _ref2.amount, _ref2$options = _ref2.options, _options = _ref2$options === void 0 ? {} : _ref2$options, rest = _objectWithoutPropertiesLoose(_ref2, _excluded$6);
              (0, import_ts_essentials.assert)(orders.length > 0, "must pass at least 1 order");
              _checkAndParseOrders = checkAndParseOrders$1(orders), totalTakerAmount = _checkAndParseOrders.totalTakerAmount, takerAsset = _checkAndParseOrders.takerAsset;
              (0, import_ts_essentials.assert)(takerAsset.toLowerCase() === destToken.toLowerCase(), "All orders must have the same takerAsset as destToken");
              takerAmountString = totalTakerAmount.toString(10);
              if (amount) {
                (0, import_ts_essentials.assert)(amount === takerAmountString, "`amount` must equal the total of the orders' `takerAmounts`");
              }
              options = _extends({}, _options, {
                includeContractMethods: [import_core.ContractMethod.simpleBuy]
              });
              side = import_core.SwapSide.BUY;
              rateInput = _extends({}, rest, {
                srcToken,
                destToken,
                amount: takerAmountString,
                side,
                options
              });
              _context.next = 11;
              return getSwapAndLimitOrderRate(rateInput, requestParams);
            case 11:
              optimalRate = _context.sent;
              return _context.abrupt("return", optimalRate);
            case 13:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function getLimitOrdersRate2(_x, _x2, _x3) {
      return _ref3.apply(this, arguments);
    };
  }();
  var buildLimitOrderTx = function buildLimitOrderTx2(params, options, requestParams) {
    var _checkAndParseOrders2 = checkAndParseOrders$1(params.orders), makerAsset = _checkAndParseOrders2.makerAsset, takerAsset = _checkAndParseOrders2.takerAsset, totalTakerAmount = _checkAndParseOrders2.totalTakerAmount;
    var fillParams = _extends({}, params, {
      // taker supplies takerAsset
      srcToken: takerAsset,
      // no `slippage` in `params`
      srcAmount: totalTakerAmount.toString(10),
      // taker gets makerAsset in the end
      destToken: makerAsset
    });
    return buildSwapTx(fillParams, options, requestParams);
  };
  var buildSwapAndLimitOrderTx = function buildSwapAndLimitOrderTx2(params, options, requestParams) {
    var _checkAndParseOrders3 = checkAndParseOrders$1(params.orders), makerAsset = _checkAndParseOrders3.makerAsset;
    var fillParams = _extends({}, params, {
      // taker supplies srcToken
      srcToken: params.priceRoute.srcToken,
      // which is swapped for makerAsset, that would go towards filling the orders
      destToken: makerAsset,
      destDecimals: params.priceRoute.destDecimals
    }, params.slippage ? {
      slippage: params.slippage
    } : (
      //                                        may sneak in as part of `params`
      {
        srcAmount: params.priceRoute.srcAmount,
        slippage: void 0
      }
    ));
    return buildSwapTx(fillParams, options, requestParams);
  };
  return {
    getLimitOrdersRate,
    buildLimitOrderTx,
    buildSwapAndLimitOrderTx
  };
};
function checkAndParseOrders$1(orders) {
  (0, import_ts_essentials.assert)(isFilledArray(orders), "must pass at least 1 order");
  var _orders$reduce = orders.reduce(function(accum, order) {
    accum.takerAssetsSet.add(order.takerAsset.toLowerCase());
    accum.makerAssetsSet.add(order.makerAsset.toLowerCase());
    accum.totalTakerAmount = accum.totalTakerAmount + BigInt(order.takerAmount);
    return accum;
  }, {
    takerAssetsSet: /* @__PURE__ */ new Set(),
    makerAssetsSet: /* @__PURE__ */ new Set(),
    totalTakerAmount: BigInt(0)
  }), takerAssetsSet = _orders$reduce.takerAssetsSet, makerAssetsSet = _orders$reduce.makerAssetsSet, totalTakerAmount = _orders$reduce.totalTakerAmount;
  (0, import_ts_essentials.assert)(takerAssetsSet.size === 1, "All orders must have the same takerAsset as destToken");
  (0, import_ts_essentials.assert)(makerAssetsSet.size === 1, "All orders must have the same makerAsset");
  var _orders$ = orders[0], maker = _orders$.maker, taker = _orders$.taker, makerAsset = _orders$.makerAsset, takerAsset = _orders$.takerAsset;
  return {
    totalTakerAmount,
    maker,
    taker,
    makerAsset,
    takerAsset
  };
}
var constructBuildNFTOrder = function constructBuildNFTOrder2(options) {
  var chainId = options.chainId;
  var _constructGetSpender = constructGetSpender(options), getContracts = _constructGetSpender.getContracts;
  var buildNFTOrder = function() {
    var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(buildNFTOrderParams, requestParams) {
      var _yield$getContracts, AugustusAddress, verifyingContract;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return getContracts(requestParams);
            case 2:
              _yield$getContracts = _context.sent;
              AugustusAddress = _yield$getContracts.AugustusSwapper;
              verifyingContract = _yield$getContracts.AugustusRFQ;
              return _context.abrupt("return", buildOrderData$1(_extends({}, buildNFTOrderParams, {
                chainId,
                verifyingContract,
                AugustusAddress
              })));
            case 6:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function buildNFTOrder2(_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }();
  return {
    buildNFTOrder
  };
};
var constructSignNFTOrder = function constructSignNFTOrder2(options) {
  var signNFTOrder = function signNFTOrder2(typedData) {
    var typedDataOnly = _extends({}, typedData, {
      // here assetType isn't provided, SignableData must already have corrent BigIntAsString
      // @TODO consider using `template_${types}` for Address, likely bad idea when considering 3rd-party code
      data: sanitizeOrderData(typedData.data)
    });
    return options.contractCaller.signTypedDataCall(typedDataOnly);
  };
  return {
    signNFTOrder
  };
};
var constructCancelNFTOrder = function constructCancelNFTOrder2(options) {
  var _constructCancelLimit = constructCancelLimitOrder(options), cancelLimitOrder = _constructCancelLimit.cancelLimitOrder, cancelLimitOrderBulk = _constructCancelLimit.cancelLimitOrderBulk;
  return {
    cancelNFTOrder: cancelLimitOrder,
    cancelNFTOrderBulk: cancelLimitOrderBulk
  };
};
var constructGetNFTOrders = function constructGetNFTOrders2(_ref) {
  var _ref$apiURL = _ref.apiURL, apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL, chainId = _ref.chainId, fetcher = _ref.fetcher;
  var getBaseFetchURLByOrderType = constructBaseFetchUrlGetter({
    apiURL,
    chainId
  });
  var getNFTOrders = function() {
    var _ref2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(userParams, requestParams) {
      var baseFetchURL, userURL, fetchURL, response;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              baseFetchURL = getBaseFetchURLByOrderType(userParams.type);
              userURL = "maker" in userParams ? "maker/" + userParams.maker : "taker/" + userParams.taker;
              fetchURL = baseFetchURL + "/" + userURL;
              _context.next = 5;
              return fetcher({
                url: fetchURL,
                method: "GET",
                requestParams
              });
            case 5:
              response = _context.sent;
              return _context.abrupt("return", response);
            case 7:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function getNFTOrders2(_x, _x2) {
      return _ref2.apply(this, arguments);
    };
  }();
  var getNFTOrderByHash = function() {
    var _ref3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(orderHash, requestParams) {
      var baseFetchURL, fetchURL, order;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1)
          switch (_context2.prev = _context2.next) {
            case 0:
              baseFetchURL = getBaseFetchURLByOrderType();
              fetchURL = baseFetchURL + "/" + orderHash;
              _context2.next = 4;
              return fetcher({
                url: fetchURL,
                method: "GET",
                requestParams
              });
            case 4:
              order = _context2.sent;
              return _context2.abrupt("return", order);
            case 6:
            case "end":
              return _context2.stop();
          }
      }, _callee2);
    }));
    return function getNFTOrderByHash2(_x3, _x4) {
      return _ref3.apply(this, arguments);
    };
  }();
  return {
    getNFTOrders,
    getNFTOrderByHash
  };
};
var constructPostNFTOrder = function constructPostNFTOrder2(_ref) {
  var _ref$apiURL = _ref.apiURL, apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL, chainId = _ref.chainId, fetcher = _ref.fetcher;
  var getBaseFetchURLByOrderType = constructBaseFetchUrlGetter({
    apiURL,
    chainId
  });
  var postTypedOrder = function() {
    var _ref2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(NFTOrderWithSignatureAndPermit, type, requestParams) {
      var fetchURL, _yield$fetcher, newOrder;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              fetchURL = getBaseFetchURLByOrderType(type);
              _context.next = 3;
              return fetcher({
                url: fetchURL,
                method: "POST",
                data: NFTOrderWithSignatureAndPermit,
                requestParams
              });
            case 3:
              _yield$fetcher = _context.sent;
              newOrder = _yield$fetcher.order;
              return _context.abrupt("return", _extends({}, newOrder));
            case 6:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function postTypedOrder2(_x, _x2, _x3) {
      return _ref2.apply(this, arguments);
    };
  }();
  var postNFTLimitOrder = function postNFTLimitOrder2(NFTOrderWithSignatureAndPermit, requestParams) {
    return postTypedOrder(NFTOrderWithSignatureAndPermit, "LIMIT", requestParams);
  };
  var postNFTP2POrder = function postNFTP2POrder2(NFTOrderWithSignatureAndPermit, requestParams) {
    return postTypedOrder(NFTOrderWithSignatureAndPermit, "P2P", requestParams);
  };
  return {
    postNFTLimitOrder,
    postNFTP2POrder
  };
};
var constructGetNFTOrdersContract = function constructGetNFTOrdersContract2(options) {
  var _constructGetSpender = constructGetSpender(options), getTokenTransferProxy = _constructGetSpender.getSpender, getNFTOrdersContract = _constructGetSpender.getAugustusRFQ;
  return {
    getNFTOrdersContract,
    getTokenTransferProxy
  };
};
var MinNFTAbi = [{
  constant: false,
  inputs: [{
    name: "_operator",
    type: "address"
  }, {
    name: "_approved",
    type: "bool"
  }],
  name: "setApprovalForAll",
  outputs: [],
  payable: false,
  stateMutability: "nonpayable",
  type: "function"
}];
var constructApproveTokenForNFTOrder = function constructApproveTokenForNFTOrder2(options) {
  var _constructApproveToke = constructApproveToken(options), approveERC20ForNFTOrder = _constructApproveToke.approveToken;
  var _constructGetNFTOrder = constructGetNFTOrdersContract(options), getNFTOrdersContract = _constructGetNFTOrder.getNFTOrdersContract;
  var approveNFTForNFTOrder = function() {
    var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(tokenAddress, overrides, requestParams) {
      var AugustusRFQ, res;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }
              _context.next = 3;
              return getNFTOrdersContract(requestParams);
            case 3:
              AugustusRFQ = _context.sent;
              _context.next = 6;
              return options.contractCaller.transactCall({
                address: tokenAddress,
                abi: MinNFTAbi,
                contractMethod: "setApprovalForAll",
                args: [AugustusRFQ, true],
                overrides
              });
            case 6:
              res = _context.sent;
              return _context.abrupt("return", res);
            case 8:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function approveNFTForNFTOrder2(_x, _x2, _x3) {
      return _ref.apply(this, arguments);
    };
  }();
  return {
    approveERC20ForNFTOrder,
    approveNFTForNFTOrder
  };
};
var _excluded$5 = ["srcToken", "destToken", "amount", "options"];
var constructBuildNFTOrderTx = function constructBuildNFTOrderTx2(_ref) {
  var _ref$apiURL = _ref.apiURL, apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL, _ref$version = _ref.version, version2 = _ref$version === void 0 ? DEFAULT_VERSION : _ref$version, chainId = _ref.chainId, fetcher = _ref.fetcher;
  var _constructBuildTx = constructBuildTx({
    apiURL,
    version: version2,
    chainId,
    fetcher
  }), buildSwapTx = _constructBuildTx.buildTx;
  var _constructGetRate = constructGetRate({
    apiURL,
    version: version2,
    chainId,
    fetcher
  }), getSwapAndNFTOrderRate = _constructGetRate.getRate;
  var getNFTOrdersRate = function() {
    var _ref3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(_ref2, orders, requestParams) {
      var srcToken, destToken, amount, _ref2$options, _options, rest, _checkAndParseOrders, totalTakerAmount, takerAsset, takerAmountString, options, side, rateInput, optimalRate;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              srcToken = _ref2.srcToken, destToken = _ref2.destToken, amount = _ref2.amount, _ref2$options = _ref2.options, _options = _ref2$options === void 0 ? {} : _ref2$options, rest = _objectWithoutPropertiesLoose(_ref2, _excluded$5);
              (0, import_ts_essentials.assert)(orders.length > 0, "must pass at least 1 order");
              _checkAndParseOrders = checkAndParseOrders(orders), totalTakerAmount = _checkAndParseOrders.totalTakerAmount, takerAsset = _checkAndParseOrders.takerAsset;
              (0, import_ts_essentials.assert)(takerAsset.toLowerCase() === destToken.toLowerCase(), "All orders must have the same takerAsset as destToken");
              takerAmountString = totalTakerAmount.toString(10);
              if (amount) {
                (0, import_ts_essentials.assert)(amount === takerAmountString, "`amount` must equal the total of the orders' `takerAmounts`");
              }
              options = _extends({}, _options, {
                includeContractMethods: [import_core.ContractMethod.simpleBuy]
              });
              side = import_core.SwapSide.BUY;
              rateInput = _extends({}, rest, {
                srcToken,
                destToken,
                amount: takerAmountString,
                side,
                options
              });
              _context.next = 11;
              return getSwapAndNFTOrderRate(rateInput, requestParams);
            case 11:
              optimalRate = _context.sent;
              return _context.abrupt("return", optimalRate);
            case 13:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function getNFTOrdersRate2(_x, _x2, _x3) {
      return _ref3.apply(this, arguments);
    };
  }();
  var buildNFTOrderTx = function buildNFTOrderTx2(params, options, requestParams) {
    var _checkAndParseOrders2 = checkAndParseOrders(params.orders), takerAsset = _checkAndParseOrders2.takerAsset, totalTakerAmount = _checkAndParseOrders2.totalTakerAmount;
    var fillParams = _extends({}, params, {
      // taker supplies takerAsset
      srcToken: takerAsset,
      srcAmount: totalTakerAmount.toString(10),
      // taker gets makerAsset in the end
      destToken: "NFT"
      // support any NFT
    });
    return buildSwapTx(fillParams, options, requestParams);
  };
  var buildSwapAndNFTOrderTx = function buildSwapAndNFTOrderTx2(params, options, requestParams) {
    checkAndParseOrders(params.orders);
    var fillParams = _extends({}, params, {
      // taker supplies srcToken
      srcToken: params.priceRoute.srcToken
    }, params.slippage ? {
      slippage: params.slippage
    } : (
      //                                        may sneak in as part of `params`
      {
        srcAmount: params.priceRoute.srcAmount,
        slippage: void 0
      }
    ), {
      destToken: "NFT",
      // support any NFT,
      destDecimals: params.priceRoute.destDecimals
    });
    return buildSwapTx(fillParams, options, requestParams);
  };
  return {
    getNFTOrdersRate,
    buildNFTOrderTx,
    buildSwapAndNFTOrderTx
  };
};
function checkAndParseOrders(orders) {
  (0, import_ts_essentials.assert)(isFilledArray(orders), "must pass at least 1 order");
  var _orders$reduce = orders.reduce(function(accum, order) {
    accum.takerAssetsSet.add(order.takerAsset.toLowerCase());
    accum.makerAssetsSet.add(order.makerAsset.toLowerCase());
    accum.totalTakerAmount = accum.totalTakerAmount + BigInt(order.takerAmount);
    return accum;
  }, {
    takerAssetsSet: /* @__PURE__ */ new Set(),
    makerAssetsSet: /* @__PURE__ */ new Set(),
    totalTakerAmount: BigInt(0)
  }), takerAssetsSet = _orders$reduce.takerAssetsSet, makerAssetsSet = _orders$reduce.makerAssetsSet, totalTakerAmount = _orders$reduce.totalTakerAmount;
  (0, import_ts_essentials.assert)(takerAssetsSet.size === 1, "All orders must have the same takerAsset as destToken");
  (0, import_ts_essentials.assert)(makerAssetsSet.size === 1, "All orders must have the same makerAsset");
  var _orders$ = orders[0], maker = _orders$.maker, taker = _orders$.taker, makerAsset = _orders$.makerAsset, takerAsset = _orders$.takerAsset;
  return {
    totalTakerAmount,
    maker,
    taker,
    makerAsset: makerAsset.startsWith("0x") ? makerAsset : uintToAssetAddress(makerAsset),
    takerAsset: takerAsset.startsWith("0x") ? takerAsset : uintToAssetAddress(takerAsset)
  };
}
function uintToAssetAddress(assetUint) {
  return "0x" + (BigInt(assetUint) & (BigInt(1) << BigInt(160)) - BigInt(1)).toString(16);
}
var _excluded$4 = ["requestParams"];
var constructFetcher$2 = function constructFetcher(axios, extra) {
  return function() {
    var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(params) {
      var requestParams, rest, headers, allParams, _yield$axios$request, data;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              requestParams = params.requestParams, rest = _objectWithoutPropertiesLoose(params, _excluded$4);
              headers = extra != null && extra.apiKey ? _extends({
                "X-API-KEY": extra.apiKey
              }, rest.headers, requestParams == null ? void 0 : requestParams.headers) : _extends({}, rest.headers, requestParams == null ? void 0 : requestParams.headers);
              allParams = _extends({}, rest, requestParams, {
                headers
              });
              _context.next = 6;
              return axios.request(allParams);
            case 6:
              _yield$axios$request = _context.sent;
              data = _yield$axios$request.data;
              return _context.abrupt("return", data);
            case 11:
              _context.prev = 11;
              _context.t0 = _context["catch"](0);
              if (!axios.isAxiosError(_context.t0)) {
                _context.next = 15;
                break;
              }
              throw new FetcherError(_context.t0);
            case 15:
              throw _context.t0;
            case 16:
            case "end":
              return _context.stop();
          }
      }, _callee, null, [[0, 11]]);
    }));
    return function(_x) {
      return _ref.apply(this, arguments);
    };
  }();
};
var constructFetcher$1 = function constructFetcher2(fetch, extra) {
  return function() {
    var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(params) {
      var url, method, requestParams, body, POSTheaders, apiHeaders, headers, response, data;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              url = params.url, method = params.method, requestParams = params.requestParams;
              body = method === "POST" ? JSON.stringify(params.data) : null;
              POSTheaders = method === "POST" && body ? {
                "Content-Type": "application/json"
              } : void 0;
              apiHeaders = extra != null && extra.apiKey ? {
                "X-API-KEY": extra.apiKey
              } : void 0;
              headers = POSTheaders || apiHeaders || params.headers || requestParams != null && requestParams.headers ? _extends({}, apiHeaders, POSTheaders, params.headers, requestParams == null ? void 0 : requestParams.headers) : void 0;
              _context.next = 8;
              return fetch(url, _extends({
                method,
                body
              }, requestParams, {
                headers
              }));
            case 8:
              response = _context.sent;
              _context.next = 11;
              return response.json();
            case 11:
              data = _context.sent;
              if (response.ok) {
                _context.next = 14;
                break;
              }
              throw new FetcherError({
                code: String(response.status),
                response: {
                  data,
                  status: response.status,
                  statusText: response.statusText,
                  headers: Object.fromEntries(response.headers.entries()),
                  config: {
                    url,
                    method
                  }
                },
                message: response.statusText,
                isAxiosError: false
              });
            case 14:
              return _context.abrupt("return", data);
            case 17:
              _context.prev = 17;
              _context.t0 = _context["catch"](0);
              if (!(_context.t0 instanceof FetcherError)) {
                _context.next = 21;
                break;
              }
              throw _context.t0;
            case 21:
              throw new FetcherError(_context.t0);
            case 22:
            case "end":
              return _context.stop();
          }
      }, _callee, null, [[0, 17]]);
    }));
    return function(_x) {
      return _ref.apply(this, arguments);
    };
  }();
};
var _excluded$3 = ["block", "gas"];
var _excluded2$2 = ["gas", "from"];
var constructEthersV5ContractCaller = function constructEthersV5ContractCaller2(_ref, account) {
  var providerOrSigner = _ref.ethersProviderOrSigner, Contract = _ref.EthersContract;
  var staticCall = function() {
    var _ref2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(params) {
      var _contract$callStatic;
      var address, abi, contractMethod, args, overrides, contract, block, gas, restOverrides, normalizedOverrides, callOverrides;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              address = params.address, abi = params.abi, contractMethod = params.contractMethod, args = params.args, overrides = params.overrides;
              contract = new Contract(address, abi, providerOrSigner);
              assertEthersContractHasMethodsV5(contract, contractMethod);
              block = overrides.block, gas = overrides.gas, restOverrides = _objectWithoutPropertiesLoose(overrides, _excluded$3);
              normalizedOverrides = _extends({}, restOverrides, {
                blockTag: block,
                gasLimit: gas
              });
              callOverrides = normalizedOverrides;
              return _context.abrupt("return", (_contract$callStatic = contract.callStatic)[contractMethod].apply(_contract$callStatic, args.concat([callOverrides])));
            case 7:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function staticCall2(_x) {
      return _ref2.apply(this, arguments);
    };
  }();
  var transactCall = function() {
    var _ref3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(params) {
      var address, abi, contractMethod, args, overrides, signer, contract, gas, restOverrides, normalizedOverrides, txOverrides, txResponse;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1)
          switch (_context2.prev = _context2.next) {
            case 0:
              (0, import_ts_essentials.assert)(account, "account must be specified to create a signer");
              (0, import_ts_essentials.assert)(isEthersProviderWithSigner$1(providerOrSigner) || isEthersSigner$1(providerOrSigner), "ethers must be an instance of Signer or JsonRpcProvider to create a signer");
              address = params.address, abi = params.abi, contractMethod = params.contractMethod, args = params.args, overrides = params.overrides;
              signer = "getSigner" in providerOrSigner ? providerOrSigner.getSigner(account) : providerOrSigner;
              contract = new Contract(address, abi, signer);
              assertEthersContractHasMethodsV5(contract, contractMethod);
              gas = overrides.gas, restOverrides = _objectWithoutPropertiesLoose(overrides, _excluded2$2);
              normalizedOverrides = _extends({}, restOverrides, {
                gasLimit: gas
              });
              txOverrides = normalizedOverrides;
              _context2.next = 11;
              return contract[contractMethod].apply(contract, args.concat([txOverrides]));
            case 11:
              txResponse = _context2.sent;
              return _context2.abrupt("return", txResponse);
            case 13:
            case "end":
              return _context2.stop();
          }
      }, _callee2);
    }));
    return function transactCall2(_x2) {
      return _ref3.apply(this, arguments);
    };
  }();
  var signTypedDataCall = function() {
    var _ref4 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee3(typedData) {
      var signer, data, domain, types;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1)
          switch (_context3.prev = _context3.next) {
            case 0:
              (0, import_ts_essentials.assert)(account, "account must be specified to create a signer");
              (0, import_ts_essentials.assert)(isEthersProviderWithSigner$1(providerOrSigner) || isEthersSigner$1(providerOrSigner), "ethers must be an instance of Signer or JsonRpcProvider to create a signer");
              signer = "getSigner" in providerOrSigner ? providerOrSigner.getSigner(account) : providerOrSigner;
              (0, import_ts_essentials.assert)(isTypedDataCapableSigner(signer), "Signer can sign typed data");
              data = typedData.data, domain = typedData.domain, types = typedData.types;
              return _context3.abrupt("return", signer._signTypedData(domain, types, data));
            case 6:
            case "end":
              return _context3.stop();
          }
      }, _callee3);
    }));
    return function signTypedDataCall2(_x3) {
      return _ref4.apply(this, arguments);
    };
  }();
  return {
    staticCall,
    transactCall,
    signTypedDataCall
  };
};
function isEthersProvider(providerOrSigner) {
  return "_isProvider" in providerOrSigner && providerOrSigner._isProvider;
}
function isEthersProviderWithSigner$1(providerOrSigner) {
  return isEthersProvider(providerOrSigner) && "getSigner" in providerOrSigner;
}
function isEthersSigner$1(providerOrSigner) {
  return "_isSigner" in providerOrSigner && providerOrSigner._isSigner;
}
function isTypedDataCapableSigner(signer) {
  return "_signTypedData" in signer;
}
function ethersContractHasMethodsV5(contract) {
  for (var _len = arguments.length, methods = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    methods[_key - 1] = arguments[_key];
  }
  return methods.every(function(method) {
    return typeof contract[method] === "function";
  });
}
function assertEthersContractHasMethodsV5(contract) {
  for (var _len2 = arguments.length, methods = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    methods[_key2 - 1] = arguments[_key2];
  }
  (0, import_ts_essentials.assert)(ethersContractHasMethodsV5.apply(void 0, [contract].concat(methods)), "Contract must have methods: " + methods.join(", "));
}
var _excluded$2 = ["block", "gas"];
var _excluded2$1 = ["gas", "from"];
var constructContractCaller$2 = function constructContractCaller(_ref, account) {
  var providerOrSigner = _ref.ethersV6ProviderOrSigner, Contract = _ref.EthersV6Contract;
  var staticCall = function() {
    var _ref2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(params) {
      var address, abi, contractMethod, args, overrides, contract, block, gas, restOverrides, normalizedOverrides, callableContractFunction;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              address = params.address, abi = params.abi, contractMethod = params.contractMethod, args = params.args, overrides = params.overrides;
              contract = new Contract(address, abi, providerOrSigner);
              block = overrides.block, gas = overrides.gas, restOverrides = _objectWithoutPropertiesLoose(overrides, _excluded$2);
              normalizedOverrides = _extends({}, restOverrides, {
                blockTag: block,
                gasLimit: gas
              });
              callableContractFunction = contract.getFunction(contractMethod);
              return _context.abrupt("return", callableContractFunction.staticCall.apply(callableContractFunction, args.concat([normalizedOverrides])));
            case 6:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function staticCall2(_x) {
      return _ref2.apply(this, arguments);
    };
  }();
  var transactCall = function() {
    var _ref3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(params) {
      var address, abi, contractMethod, args, overrides, signer, contract, gas, restOverrides, normalizedOverrides, callableContractFunction, txResponse;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1)
          switch (_context2.prev = _context2.next) {
            case 0:
              (0, import_ts_essentials.assert)(account, "account must be specified to create a signer");
              (0, import_ts_essentials.assert)(isEthersProviderWithSigner(providerOrSigner) || isEthersSigner(providerOrSigner), "ethers must be an instance of Signer or JsonRpcProvider to create a signer");
              address = params.address, abi = params.abi, contractMethod = params.contractMethod, args = params.args, overrides = params.overrides;
              if (!("getSigner" in providerOrSigner)) {
                _context2.next = 9;
                break;
              }
              _context2.next = 6;
              return providerOrSigner.getSigner(account);
            case 6:
              _context2.t0 = _context2.sent;
              _context2.next = 10;
              break;
            case 9:
              _context2.t0 = providerOrSigner;
            case 10:
              signer = _context2.t0;
              contract = new Contract(address, abi, signer);
              gas = overrides.gas, restOverrides = _objectWithoutPropertiesLoose(overrides, _excluded2$1);
              normalizedOverrides = _extends({}, restOverrides, {
                gasLimit: gas
              });
              callableContractFunction = contract.getFunction(contractMethod);
              _context2.next = 17;
              return callableContractFunction.send.apply(callableContractFunction, args.concat([normalizedOverrides]));
            case 17:
              txResponse = _context2.sent;
              return _context2.abrupt("return", txResponse);
            case 19:
            case "end":
              return _context2.stop();
          }
      }, _callee2);
    }));
    return function transactCall2(_x2) {
      return _ref3.apply(this, arguments);
    };
  }();
  var signTypedDataCall = function() {
    var _ref4 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee3(typedData) {
      var signer, data, domain, types;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1)
          switch (_context3.prev = _context3.next) {
            case 0:
              (0, import_ts_essentials.assert)(account, "account must be specified to create a signer");
              (0, import_ts_essentials.assert)(isEthersProviderWithSigner(providerOrSigner) || isEthersSigner(providerOrSigner), "ethers must be an instance of Signer or JsonRpcProvider to create a signer");
              if (!("getSigner" in providerOrSigner)) {
                _context3.next = 8;
                break;
              }
              _context3.next = 5;
              return providerOrSigner.getSigner(account);
            case 5:
              _context3.t0 = _context3.sent;
              _context3.next = 9;
              break;
            case 8:
              _context3.t0 = providerOrSigner;
            case 9:
              signer = _context3.t0;
              data = typedData.data, domain = typedData.domain, types = typedData.types;
              return _context3.abrupt("return", signer.signTypedData(domain, types, data));
            case 12:
            case "end":
              return _context3.stop();
          }
      }, _callee3);
    }));
    return function signTypedDataCall2(_x3) {
      return _ref4.apply(this, arguments);
    };
  }();
  return {
    staticCall,
    transactCall,
    signTypedDataCall
  };
};
function isEthersProviderWithSigner(providerOrSigner) {
  return "getSigner" in providerOrSigner;
}
function isEthersSigner(providerOrSigner) {
  return "getAddress" in providerOrSigner;
}
var baseTypeRegex = /^([^\x5b]*)(\x5b|$)/;
function findPrimaryType(types) {
  var candidates = Object.keys(types);
  var candidatesSet = new Set(candidates);
  candidates.forEach(function(candidate) {
    var typedDataFields = types[candidate];
    if (!typedDataFields)
      return;
    typedDataFields.forEach(function(_ref) {
      var _type$match;
      var type = _ref.type;
      var baseType = (_type$match = type.match(baseTypeRegex)) == null ? void 0 : _type$match[1];
      if (!baseType)
        return;
      candidatesSet["delete"](baseType);
    });
  });
  var _Array$from = Array.from(candidatesSet), primaryType = _Array$from[0];
  (0, import_ts_essentials.assert)(primaryType, "No primary type found in SignableTypedData types, " + JSON.stringify(types));
  return primaryType;
}
var _excluded$1 = ["block", "gas", "value"];
var _excluded2 = ["gas", "from", "value", "nonce"];
var constructContractCaller$1 = function constructContractCaller2(web3, account) {
  var staticCall = function() {
    var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(params) {
      var _contract$methods;
      var address, abi, contractMethod, args, overrides, contract, gas, value, restOverrides, normalizedOverrides;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              (0, import_ts_essentials.assert)(web3.currentProvider, "web3.currentProvider is not set");
              address = params.address, abi = params.abi, contractMethod = params.contractMethod, args = params.args, overrides = params.overrides;
              contract = new web3.eth.Contract(
                abi,
                // FIXME abi types ethers dependant
                address
              );
              assertWeb3ContractHasMethods(contract, contractMethod);
              gas = overrides.gas, value = overrides.value, restOverrides = _objectWithoutPropertiesLoose(overrides, _excluded$1);
              normalizedOverrides = _extends({}, restOverrides, {
                gas: gas == null ? void 0 : gas.toString(10),
                value: value == null ? void 0 : value.toString(10)
              });
              return _context.abrupt("return", (_contract$methods = contract.methods)[contractMethod].apply(_contract$methods, args).call(normalizedOverrides));
            case 7:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function staticCall2(_x) {
      return _ref.apply(this, arguments);
    };
  }();
  var transactCall = function() {
    var _ref2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(params) {
      var _contract$methods2;
      var address, abi, contractMethod, args, overrides, contract, gas, from, value, nonce, restOverrides, _from, normalizedOverrides, preparedCall, promiEvent, unpromiEvent;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1)
          switch (_context2.prev = _context2.next) {
            case 0:
              (0, import_ts_essentials.assert)(web3.currentProvider, "web3.currentProvider is not set");
              (0, import_ts_essentials.assert)(account, "account must be specified to send transactions");
              address = params.address, abi = params.abi, contractMethod = params.contractMethod, args = params.args, overrides = params.overrides;
              contract = new web3.eth.Contract(
                abi,
                // FIXME
                address
              );
              assertWeb3ContractHasMethods(contract, contractMethod);
              gas = overrides.gas, from = overrides.from, value = overrides.value, nonce = overrides.nonce, restOverrides = _objectWithoutPropertiesLoose(overrides, _excluded2);
              _from = from || account;
              (0, import_ts_essentials.assert)(_from, "from is required");
              normalizedOverrides = _extends({}, restOverrides, {
                from: _from,
                gas: gas == null ? void 0 : gas.toString(10),
                value: value == null ? void 0 : value.toString(10),
                nonce: nonce == null ? void 0 : nonce.toString(10)
              });
              preparedCall = (_contract$methods2 = contract.methods)[contractMethod].apply(_contract$methods2, args);
              promiEvent = preparedCall.send(normalizedOverrides);
              unpromiEvent = {
                on: promiEvent.on.bind(promiEvent),
                once: promiEvent.once.bind(promiEvent)
              };
              return _context2.abrupt("return", unpromiEvent);
            case 13:
            case "end":
              return _context2.stop();
          }
      }, _callee2);
    }));
    return function transactCall2(_x2) {
      return _ref2.apply(this, arguments);
    };
  }();
  var signTypedDataCall = function() {
    var _ref3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee3(typedData) {
      var data, domain, types, _typedData, signature;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1)
          switch (_context3.prev = _context3.next) {
            case 0:
              (0, import_ts_essentials.assert)(web3.currentProvider, "web3.currentProvider is not set");
              (0, import_ts_essentials.assert)(account, "account must be specified to sign data");
              data = typedData.data, domain = typedData.domain, types = typedData.types;
              _typedData = {
                types: _extends({
                  EIP712Domain: [{
                    name: "name",
                    type: "string"
                  }, {
                    name: "version",
                    type: "string"
                  }, {
                    name: "chainId",
                    type: "uint256"
                  }, {
                    name: "verifyingContract",
                    type: "address"
                  }]
                }, types),
                primaryType: findPrimaryType(types),
                domain,
                message: data
              };
              _context3.next = 6;
              return web3.eth.signTypedData(account, _typedData);
            case 6:
              signature = _context3.sent;
              return _context3.abrupt("return", signature);
            case 8:
            case "end":
              return _context3.stop();
          }
      }, _callee3);
    }));
    return function signTypedDataCall2(_x3) {
      return _ref3.apply(this, arguments);
    };
  }();
  return {
    staticCall,
    transactCall,
    signTypedDataCall
  };
};
function web3ContractHasMethods(contract) {
  for (var _len = arguments.length, methods = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    methods[_key - 1] = arguments[_key];
  }
  return methods.every(function(method) {
    return typeof contract.methods[method] === "function";
  });
}
function assertWeb3ContractHasMethods(contract) {
  for (var _len2 = arguments.length, methods = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    methods[_key2 - 1] = arguments[_key2];
  }
  (0, import_ts_essentials.assert)(web3ContractHasMethods.apply(void 0, [contract].concat(methods)), "Contract must have methods: " + methods.join(", "));
}
var constructContractCaller3 = function constructContractCaller4(viemClient, account) {
  var staticCall = function() {
    var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(params) {
      var address, abi, contractMethod, args, overrides, block, _ref2, blockNumber, blockTag, result;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              (0, import_ts_essentials.assert)(viemClient.readContract, "Viem client must have readContract Public Action");
              address = params.address, abi = params.abi, contractMethod = params.contractMethod, args = params.args, overrides = params.overrides;
              block = overrides.block;
              _ref2 = typeof block === "number" ? {
                blockNumber: BigInt(block)
              } : {
                blockTag: block
              }, blockNumber = _ref2.blockNumber, blockTag = _ref2.blockTag;
              result = viemClient.readContract({
                account: viemClient.account || account,
                address,
                abi,
                functionName: contractMethod,
                args,
                blockTag,
                blockNumber
              });
              return _context.abrupt("return", result);
            case 6:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function staticCall2(_x) {
      return _ref.apply(this, arguments);
    };
  }();
  var transactCall = function() {
    var _ref3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(params) {
      var _overrides$gas, _overrides$value;
      var address, abi, contractMethod, args, overrides, viemTxParams, gasPriceParams, txHash;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1)
          switch (_context2.prev = _context2.next) {
            case 0:
              (0, import_ts_essentials.assert)(account, "account must be specified sign transactions");
              (0, import_ts_essentials.assert)(viemClient.writeContract, "Viem client must have writeContract Wallet Action");
              address = params.address, abi = params.abi, contractMethod = params.contractMethod, args = params.args, overrides = params.overrides;
              viemTxParams = txParamsToViemTxParams(_extends({}, overrides, {
                to: address,
                gas: (_overrides$gas = overrides.gas) == null ? void 0 : _overrides$gas.toString(10),
                value: (_overrides$value = overrides.value) == null ? void 0 : _overrides$value.toString(10)
              }));
              gasPriceParams = "maxFeePerGas" in viemTxParams ? {
                maxFeePerGas: viemTxParams.maxFeePerGas,
                maxPriorityFeePerGas: viemTxParams.maxPriorityFeePerGas
              } : "gasPrice" in viemTxParams ? {
                gasPrice: viemTxParams.gasPrice
              } : {};
              _context2.next = 7;
              return viemClient.writeContract(_extends({
                // either `viemClient` has account assigned to it,
                // or the provider `viemClient` was created with must control `account` (viemClient.getAddresses()[0]===account);
                // otherwise breaks with ` ProviderError: Unknown account 0x...`
                account: viemClient.account || account,
                address,
                abi,
                functionName: contractMethod,
                args: argsToViemArgs(args),
                value: viemTxParams.value,
                gas: viemTxParams.gas,
                // ...viemTxParams,
                // account: (overrides.from || account) as Hex,
                nonce: overrides.nonce
              }, gasPriceParams));
            case 7:
              txHash = _context2.sent;
              return _context2.abrupt("return", txHash);
            case 9:
            case "end":
              return _context2.stop();
          }
      }, _callee2);
    }));
    return function transactCall2(_x2) {
      return _ref3.apply(this, arguments);
    };
  }();
  var signTypedDataCall = function() {
    var _ref4 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee3(typedData) {
      var data, domain, types, primaryType, chainId, viemDomain, signature;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1)
          switch (_context3.prev = _context3.next) {
            case 0:
              (0, import_ts_essentials.assert)(account, "account must be specified to create a signer");
              (0, import_ts_essentials.assert)(viemClient.signTypedData, "Viem client must have signTypedData Wallet Action");
              data = typedData.data, domain = typedData.domain, types = typedData.types;
              primaryType = findPrimaryType(types);
              chainId = domain.chainId === void 0 ? void 0 : Number(domain.chainId);
              viemDomain = {
                chainId,
                name: domain.name,
                version: domain.version,
                verifyingContract: domain.verifyingContract,
                salt: domain.salt
              };
              _context3.next = 8;
              return viemClient.signTypedData({
                // either `viemClient` has account assigned to it,
                // or the provider `viemClient` was created with must control `account` (viemClient.getAddresses()[0]===account)
                account: viemClient.account || account,
                domain: viemDomain,
                types,
                primaryType,
                message: data
              });
            case 8:
              signature = _context3.sent;
              return _context3.abrupt("return", signature);
            case 10:
            case "end":
              return _context3.stop();
          }
      }, _callee3);
    }));
    return function signTypedDataCall2(_x3) {
      return _ref4.apply(this, arguments);
    };
  }();
  return {
    staticCall,
    transactCall,
    signTypedDataCall
  };
};
function txParamsToViemTxParams(txParams) {
  var gas = txParams.gas !== void 0 ? BigInt(txParams.gas) : void 0;
  var gasPrice = txParams.gasPrice !== void 0 ? BigInt(txParams.gasPrice) : void 0;
  var maxFeePerGas = txParams.maxFeePerGas !== void 0 ? BigInt(txParams.maxFeePerGas) : void 0;
  var maxPriorityFeePerGas = txParams.maxPriorityFeePerGas !== void 0 ? BigInt(txParams.maxPriorityFeePerGas) : void 0;
  var viemTxParams = _extends({
    to: txParams.to,
    data: txParams.data,
    value: txParams.value !== void 0 ? BigInt(txParams.value) : void 0,
    gas
  }, txParams.maxFeePerGas !== void 0 ? {
    maxFeePerGas,
    maxPriorityFeePerGas
  } : {
    gasPrice
  });
  return viemTxParams;
}
function argsToViemArgs(args) {
  return args.map(function(arg) {
    if (typeof arg === "string") {
      if (arg.startsWith("0x")) {
        return arg;
      }
      var asNumber = Number(arg);
      if (Number.isNaN(asNumber)) {
        return arg;
      }
      return BigInt(asNumber);
    }
    return arg;
  });
}
var constructGetDeltaContract = function constructGetDeltaContract2(options) {
  var _constructGetSpender = constructGetSpender(options), getContracts = _constructGetSpender.getContracts;
  var getDeltaContract = function() {
    var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(requestParams) {
      var _yield$getContracts, ParaswapDelta;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return getContracts(requestParams);
            case 2:
              _yield$getContracts = _context.sent;
              ParaswapDelta = _yield$getContracts.ParaswapDelta;
              return _context.abrupt("return", ParaswapDelta || null);
            case 5:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function getDeltaContract2(_x) {
      return _ref.apply(this, arguments);
    };
  }();
  return {
    getDeltaContract
  };
};
var constructGetPartnerFee = function constructGetPartnerFee2(_ref) {
  var _ref$apiURL = _ref.apiURL, apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL, chainId = _ref.chainId, fetcher = _ref.fetcher;
  var partnerFeeUrl = apiURL + "/prices/partnerfee/" + chainId;
  var cachedPartnerFee = /* @__PURE__ */ new Map();
  var getPartnerFee = function() {
    var _ref2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(options, requestParams) {
      var search, fetchURL, data;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              if (!cachedPartnerFee.has(options.partner)) {
                _context.next = 2;
                break;
              }
              return _context.abrupt("return", cachedPartnerFee.get(options.partner));
            case 2:
              search = constructSearchString(options);
              fetchURL = partnerFeeUrl + "/" + search;
              _context.next = 6;
              return fetcher({
                url: fetchURL,
                method: "GET",
                requestParams
              });
            case 6:
              data = _context.sent;
              cachedPartnerFee.set(options.partner, data);
              return _context.abrupt("return", data);
            case 9:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function getPartnerFee2(_x, _x2) {
      return _ref2.apply(this, arguments);
    };
  }();
  return {
    getPartnerFee
  };
};
var SWAP_ORDER_EIP_712_TYPES = {
  Order: [{
    name: "owner",
    type: "address"
  }, {
    name: "beneficiary",
    type: "address"
  }, {
    name: "srcToken",
    type: "address"
  }, {
    name: "destToken",
    type: "address"
  }, {
    name: "srcAmount",
    type: "uint256"
  }, {
    name: "destAmount",
    type: "uint256"
  }, {
    name: "expectedAmount",
    type: "uint256"
  }, {
    name: "deadline",
    type: "uint256"
  }, {
    name: "kind",
    type: "uint8"
  }, {
    name: "nonce",
    type: "uint256"
  }, {
    name: "partnerAndFee",
    type: "uint256"
  }, {
    name: "permit",
    type: "bytes"
  }, {
    name: "metadata",
    type: "bytes"
  }, {
    name: "bridge",
    type: "Bridge"
  }],
  Bridge: [{
    name: "protocolSelector",
    type: "bytes4"
  }, {
    name: "destinationChainId",
    type: "uint256"
  }, {
    name: "outputToken",
    type: "address"
  }, {
    name: "scalingFactor",
    type: "int8"
  }, {
    name: "protocolData",
    type: "bytes"
  }]
};
function produceDeltaOrderTypedData(_ref) {
  var orderInput = _ref.orderInput, chainId = _ref.chainId, paraswapDeltaAddress = _ref.paraswapDeltaAddress;
  var typedData = {
    types: {
      Order: SWAP_ORDER_EIP_712_TYPES.Order,
      Bridge: SWAP_ORDER_EIP_712_TYPES.Bridge
    },
    domain: {
      name: "Portikus",
      version: "2.0.0",
      chainId,
      verifyingContract: paraswapDeltaAddress
    },
    data: orderInput
  };
  return typedData;
}
var DELTA_DEFAULT_EXPIRY = 60 * 60;
function buildDeltaSignableOrderData(_ref2) {
  var owner = _ref2.owner, _ref2$beneficiary = _ref2.beneficiary, beneficiary = _ref2$beneficiary === void 0 ? owner : _ref2$beneficiary, srcToken = _ref2.srcToken, destToken = _ref2.destToken, srcAmount = _ref2.srcAmount, destAmount = _ref2.destAmount, expectedAmount = _ref2.expectedAmount, _ref2$deadline = _ref2.deadline, deadline = _ref2$deadline === void 0 ? Math.floor(Date.now() / 1e3 + DELTA_DEFAULT_EXPIRY) : _ref2$deadline, _ref2$nonce = _ref2.nonce, nonce = _ref2$nonce === void 0 ? Date.now().toString(10) : _ref2$nonce, _ref2$permit = _ref2.permit, permit = _ref2$permit === void 0 ? "0x" : _ref2$permit, kind = _ref2.kind, _ref2$metadata = _ref2.metadata, metadata = _ref2$metadata === void 0 ? "0x" : _ref2$metadata, partnerAddress = _ref2.partnerAddress, partnerFeeBps = _ref2.partnerFeeBps, _ref2$partnerTakesSur = _ref2.partnerTakesSurplus, partnerTakesSurplus = _ref2$partnerTakesSur === void 0 ? false : _ref2$partnerTakesSur, chainId = _ref2.chainId, paraswapDeltaAddress = _ref2.paraswapDeltaAddress, bridge = _ref2.bridge;
  var orderInput = {
    owner,
    beneficiary,
    srcToken,
    destToken,
    srcAmount,
    destAmount,
    expectedAmount,
    deadline,
    nonce,
    permit,
    partnerAndFee: producePartnerAndFee({
      partnerFeeBps,
      partnerAddress,
      partnerTakesSurplus
    }),
    bridge,
    kind,
    metadata
  };
  return produceDeltaOrderTypedData({
    orderInput,
    chainId,
    paraswapDeltaAddress
  });
}
function producePartnerAndFee(_ref3) {
  var partnerFeeBps = _ref3.partnerFeeBps, partnerAddress = _ref3.partnerAddress, partnerTakesSurplus = _ref3.partnerTakesSurplus;
  if (partnerAddress === ZERO_ADDRESS)
    return "0";
  var partnerAndFee = BigInt(partnerAddress) << BigInt(96) | BigInt(partnerFeeBps.toFixed(0)) | BigInt(partnerTakesSurplus) << BigInt(8);
  return partnerAndFee.toString(10);
}
var _SwapSideToOrderKind;
var OrderKind;
(function(OrderKind2) {
  OrderKind2[OrderKind2["Sell"] = 0] = "Sell";
  OrderKind2[OrderKind2["Buy"] = 1] = "Buy";
})(OrderKind || (OrderKind = {}));
var SwapSideToOrderKind = (_SwapSideToOrderKind = {}, _SwapSideToOrderKind[import_core.SwapSide.SELL] = OrderKind.Sell, _SwapSideToOrderKind[import_core.SwapSide.BUY] = OrderKind.Buy, _SwapSideToOrderKind);
var constructBuildDeltaOrder = function constructBuildDeltaOrder2(options) {
  var chainId = options.chainId;
  var _constructGetDeltaCon = constructGetDeltaContract(options), getDeltaContract = _constructGetDeltaCon.getDeltaContract;
  var _constructGetPartnerF = constructGetPartnerFee(options), getPartnerFee = _constructGetPartnerF.getPartnerFee;
  var buildDeltaOrder = function() {
    var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(options2, requestParams) {
      var _options$partnerFeeBp, _options$side, _options$nonce;
      var ParaswapDelta, partnerAddress, partnerFeeBps, partnerTakesSurplus, feeOrTakeSurplusSupplied, _partnerAddress, _partnerFeeBps, _partnerTakesSurplus, partner, partnerFeeResponse, swapSide, expectedAmount, input;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return getDeltaContract(requestParams);
            case 2:
              ParaswapDelta = _context.sent;
              if (ParaswapDelta) {
                _context.next = 5;
                break;
              }
              throw new Error("Delta is not available on chain " + chainId);
            case 5:
              partnerAddress = options2.partnerAddress;
              partnerFeeBps = (_options$partnerFeeBp = options2.partnerFeeBps) != null ? _options$partnerFeeBp : options2.deltaPrice.partnerFee * 100;
              partnerTakesSurplus = options2.partnerTakesSurplus;
              feeOrTakeSurplusSupplied = partnerFeeBps !== void 0 || partnerTakesSurplus !== void 0;
              if (!(partnerAddress === void 0 || feeOrTakeSurplusSupplied)) {
                _context.next = 17;
                break;
              }
              partner = options2.partner || options2.deltaPrice.partner;
              _context.next = 13;
              return getPartnerFee({
                partner
              }, requestParams);
            case 13:
              partnerFeeResponse = _context.sent;
              partnerAddress = (_partnerAddress = partnerAddress) != null ? _partnerAddress : partnerFeeResponse.partnerAddress;
              partnerFeeBps = (_partnerFeeBps = partnerFeeBps) != null ? _partnerFeeBps : partnerFeeResponse.partnerFee;
              partnerTakesSurplus = (_partnerTakesSurplus = partnerTakesSurplus) != null ? _partnerTakesSurplus : partnerFeeResponse.takeSurplus;
            case 17:
              swapSide = (_options$side = options2.side) != null ? _options$side : import_core.SwapSide.SELL;
              expectedAmount = swapSide === import_core.SwapSide.SELL ? options2.deltaPrice.destAmount : options2.deltaPrice.srcAmount;
              input = {
                owner: options2.owner,
                beneficiary: options2.beneficiary,
                srcToken: options2.srcToken,
                // for some cases of WETH->ETH crosschain swaps, the destToken is changed to WETH or ETH,
                // this is already reflected in deltaPrice
                destToken: options2.deltaPrice.destToken,
                srcAmount: options2.srcAmount,
                destAmount: options2.destAmount,
                expectedAmount,
                deadline: options2.deadline,
                nonce: (_options$nonce = options2.nonce) == null ? void 0 : _options$nonce.toString(10),
                permit: options2.permit,
                kind: SwapSideToOrderKind[swapSide],
                metadata: options2.metadata,
                chainId,
                paraswapDeltaAddress: ParaswapDelta,
                partnerAddress,
                partnerTakesSurplus,
                partnerFeeBps,
                bridge: options2.deltaPrice.bridge
                // ZERO_BRIDGE for same-chain Orders
              };
              return _context.abrupt("return", buildDeltaSignableOrderData(input));
            case 21:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function buildDeltaOrder2(_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }();
  return {
    buildDeltaOrder
  };
};
var constructBuildCrosschainOrderBridge = function constructBuildCrosschainOrderBridge2(options) {
  var chainId = options.chainId;
  var buildCrosschainOrderBridge = function() {
    var _ref2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(_ref, requestParams) {
      var destChainId, deltaPrice, bridge;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              destChainId = _ref.destChainId, deltaPrice = _ref.deltaPrice;
              (0, import_ts_essentials.assert)(chainId !== deltaPrice.bridge.destinationChainId, "`deltaPrice.bridge.destinationChainId` must be different from `chainId` for crosschain Order.bridge");
              (0, import_ts_essentials.assert)(destChainId === deltaPrice.bridge.destinationChainId, "`destChainId` must match `deltaPrice.bridge.destinationChainId` for crosschain Order.bridge");
              bridge = {
                protocolSelector: "0x00000000",
                scalingFactor: 0,
                protocolData: "0x",
                destinationChainId: deltaPrice.bridge.destinationChainId,
                outputToken: deltaPrice.bridge.outputToken
              };
              return _context.abrupt("return", {
                bridge
              });
            case 5:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function buildCrosschainOrderBridge2(_x, _x2) {
      return _ref2.apply(this, arguments);
    };
  }();
  return {
    buildCrosschainOrderBridge
  };
};
var constructPostDeltaOrder = function constructPostDeltaOrder2(_ref) {
  var _ref$apiURL = _ref.apiURL, apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL, chainId = _ref.chainId, fetcher = _ref.fetcher;
  var postOrderUrl = apiURL + "/delta/orders";
  var postDeltaOrder = function postDeltaOrder2(postData, requestParams) {
    var deltaOrderToPost = _extends({}, postData, {
      chainId
    });
    return fetcher({
      url: postOrderUrl,
      method: "POST",
      data: deltaOrderToPost,
      requestParams
    });
  };
  return {
    postDeltaOrder
  };
};
function sanitizeDeltaOrderData(_ref) {
  var owner = _ref.owner, beneficiary = _ref.beneficiary, srcToken = _ref.srcToken, destToken = _ref.destToken, srcAmount = _ref.srcAmount, destAmount = _ref.destAmount, expectedAmount = _ref.expectedAmount, deadline = _ref.deadline, nonce = _ref.nonce, permit = _ref.permit, partnerAndFee = _ref.partnerAndFee, bridge = _ref.bridge, kind = _ref.kind, metadata = _ref.metadata;
  return {
    owner,
    beneficiary,
    srcToken,
    destToken,
    srcAmount,
    destAmount,
    expectedAmount,
    deadline,
    nonce,
    permit,
    partnerAndFee,
    bridge,
    kind,
    metadata
  };
}
var constructSignDeltaOrder = function constructSignDeltaOrder2(options) {
  var signDeltaOrder = function() {
    var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(typedData) {
      var typedDataOnly, signature;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              typedDataOnly = _extends({}, typedData, {
                data: sanitizeDeltaOrderData(typedData.data)
              });
              _context.next = 3;
              return options.contractCaller.signTypedDataCall(typedDataOnly);
            case 3:
              signature = _context.sent;
              return _context.abrupt("return", signature);
            case 5:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function signDeltaOrder2(_x) {
      return _ref.apply(this, arguments);
    };
  }();
  return {
    signDeltaOrder
  };
};
var _excluded = ["includeAgents", "excludeAgents"];
var constructGetDeltaPrice = function constructGetDeltaPrice2(_ref) {
  var _ref$apiURL = _ref.apiURL, apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL, chainId = _ref.chainId, fetcher = _ref.fetcher;
  var pricesUrl = apiURL + "/delta/prices";
  function getDeltaPrice(_x, _x2) {
    return _getDeltaPrice.apply(this, arguments);
  }
  function _getDeltaPrice() {
    _getDeltaPrice = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(options, requestParams) {
      var _options$side;
      var includeAgents, excludeAgents, rest, includeAgentsString, excludeAgentsString, search, fetchURL, data;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              includeAgents = options.includeAgents, excludeAgents = options.excludeAgents, rest = _objectWithoutPropertiesLoose(options, _excluded);
              includeAgentsString = includeAgents ? includeAgents.join(",") : void 0;
              excludeAgentsString = excludeAgents ? excludeAgents.join(",") : void 0;
              search = constructSearchString(_extends({}, rest, {
                chainId,
                side: (_options$side = options.side) != null ? _options$side : import_core.SwapSide.SELL,
                includeAgents: includeAgentsString,
                excludeAgents: excludeAgentsString
              }));
              fetchURL = pricesUrl + "/" + search;
              _context.next = 7;
              return fetcher({
                url: fetchURL,
                method: "GET",
                requestParams
              });
            case 7:
              data = _context.sent;
              return _context.abrupt("return", data.price);
            case 9:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return _getDeltaPrice.apply(this, arguments);
  }
  return {
    getDeltaPrice
  };
};
var constructGetDeltaOrders = function constructGetDeltaOrders2(_ref) {
  var _ref$apiURL = _ref.apiURL, apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL, fetcher = _ref.fetcher, chainId = _ref.chainId;
  var baseUrl = apiURL + "/delta/orders";
  var getDeltaOrderById = function() {
    var _ref2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(orderId, requestParams) {
      var fetchURL, order;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              fetchURL = baseUrl + "/" + orderId;
              _context.next = 3;
              return fetcher({
                url: fetchURL,
                method: "GET",
                requestParams
              });
            case 3:
              order = _context.sent;
              return _context.abrupt("return", order);
            case 5:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function getDeltaOrderById2(_x, _x2) {
      return _ref2.apply(this, arguments);
    };
  }();
  var getDeltaOrderByHash = function() {
    var _ref3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(orderHash, requestParams) {
      var fetchURL, order;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1)
          switch (_context2.prev = _context2.next) {
            case 0:
              fetchURL = baseUrl + "/hash/" + orderHash;
              _context2.next = 3;
              return fetcher({
                url: fetchURL,
                method: "GET",
                requestParams
              });
            case 3:
              order = _context2.sent;
              return _context2.abrupt("return", order);
            case 5:
            case "end":
              return _context2.stop();
          }
      }, _callee2);
    }));
    return function getDeltaOrderByHash2(_x3, _x4) {
      return _ref3.apply(this, arguments);
    };
  }();
  var getDeltaOrders = function() {
    var _ref4 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee3(options, requestParams) {
      var search, fetchURL, orders;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1)
          switch (_context3.prev = _context3.next) {
            case 0:
              search = constructSearchString({
                userAddress: options.userAddress,
                page: options.page,
                limit: options.limit,
                chainId: options.chainId,
                type: options.type
              });
              fetchURL = "" + baseUrl + search;
              _context3.next = 4;
              return fetcher({
                url: fetchURL,
                method: "GET",
                requestParams
              });
            case 4:
              orders = _context3.sent;
              return _context3.abrupt("return", orders);
            case 6:
            case "end":
              return _context3.stop();
          }
      }, _callee3);
    }));
    return function getDeltaOrders2(_x5, _x6) {
      return _ref4.apply(this, arguments);
    };
  }();
  var getRequiredBalanceForDeltaLimitOrders = function() {
    var _ref5 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee4(userParams, requestParams) {
      var userURL, fetchURL, response;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1)
          switch (_context4.prev = _context4.next) {
            case 0:
              userURL = baseUrl + "/fillablebalance/" + chainId + "/" + userParams.userAddress;
              fetchURL = userParams.tokenAddress ? userURL + "/" + userParams.tokenAddress : userURL;
              _context4.next = 4;
              return fetcher({
                url: fetchURL,
                method: "GET",
                requestParams
              });
            case 4:
              response = _context4.sent;
              return _context4.abrupt("return", response);
            case 6:
            case "end":
              return _context4.stop();
          }
      }, _callee4);
    }));
    return function getRequiredBalanceForDeltaLimitOrders2(_x7, _x8) {
      return _ref5.apply(this, arguments);
    };
  }();
  return {
    getDeltaOrderById,
    getDeltaOrderByHash,
    getDeltaOrders,
    getRequiredBalanceForDeltaLimitOrders
  };
};
var constructApproveTokenForDelta = function constructApproveTokenForDelta2(options) {
  var _constructGetDeltaCon = constructGetDeltaContract(options), getDeltaContract = _constructGetDeltaCon.getDeltaContract;
  var getParaswapDeltaAddress = function() {
    var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(requestParams) {
      var deltaContract;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return getDeltaContract(requestParams);
            case 2:
              deltaContract = _context.sent;
              if (deltaContract) {
                _context.next = 5;
                break;
              }
              throw new Error("Delta is not available on chain " + options.chainId);
            case 5:
              return _context.abrupt("return", deltaContract);
            case 6:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function getParaswapDeltaAddress2(_x) {
      return _ref.apply(this, arguments);
    };
  }();
  var approveTokenForDelta = approveTokenMethodFactory(options.contractCaller, getParaswapDeltaAddress);
  return {
    approveTokenForDelta
  };
};
var constructGetBridgeInfo = function constructGetBridgeInfo2(_ref) {
  var _ref$apiURL = _ref.apiURL, apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL, fetcher = _ref.fetcher;
  var bridgeInfoUrl = apiURL + "/delta/prices/bridge-info";
  var getBridgeInfo = function() {
    var _ref2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(requestParams) {
      var data;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return fetcher({
                url: bridgeInfoUrl,
                method: "GET",
                requestParams
              });
            case 2:
              data = _context.sent;
              return _context.abrupt("return", data.supportedTokens);
            case 4:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function getBridgeInfo2(_x) {
      return _ref2.apply(this, arguments);
    };
  }();
  return {
    getBridgeInfo
  };
};
var constructGetMulticallHandlers = function constructGetMulticallHandlers2(_ref) {
  var _ref$apiURL = _ref.apiURL, apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL, fetcher = _ref.fetcher;
  var multicallHandlersUrl = apiURL + "/delta/prices/multicall-handlers";
  var _getMulticallHandlers = function() {
    var _ref2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(requestParams) {
      var data;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return fetcher({
                url: multicallHandlersUrl,
                method: "GET",
                requestParams
              });
            case 2:
              data = _context.sent;
              return _context.abrupt("return", data);
            case 4:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function _getMulticallHandlers2(_x) {
      return _ref2.apply(this, arguments);
    };
  }();
  var getMulticallHandlers = runOnceAndCache(_getMulticallHandlers);
  return {
    getMulticallHandlers
  };
};
var constructIsTokenSupportedInDelta = function constructIsTokenSupportedInDelta2(_ref) {
  var _ref$apiURL = _ref.apiURL, apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL, chainId = _ref.chainId, fetcher = _ref.fetcher;
  var bridgeInfoUrl = apiURL + "/delta/prices/is-token-supported";
  var isTokenSupportedInDelta = function() {
    var _ref2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(token, requestParams) {
      var search, fetchURL, data;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              search = constructSearchString({
                token,
                chainId
              });
              fetchURL = bridgeInfoUrl + "/" + search;
              _context.next = 4;
              return fetcher({
                url: fetchURL,
                method: "GET",
                requestParams
              });
            case 4:
              data = _context.sent;
              return _context.abrupt("return", data.supported);
            case 6:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function isTokenSupportedInDelta2(_x, _x2) {
      return _ref2.apply(this, arguments);
    };
  }();
  return {
    isTokenSupportedInDelta
  };
};
var constructGetQuote = function constructGetQuote2(_ref) {
  var _ref$apiURL = _ref.apiURL, apiURL = _ref$apiURL === void 0 ? API_URL : _ref$apiURL, chainId = _ref.chainId, fetcher = _ref.fetcher;
  var pricesUrl = apiURL + "/quote";
  function getQuote(_x, _x2) {
    return _getQuote.apply(this, arguments);
  }
  function _getQuote() {
    _getQuote = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(options, requestParams) {
      var _options$side;
      var search, fetchURL, data;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              search = constructSearchString(_extends({}, options, {
                chainId,
                side: (_options$side = options.side) != null ? _options$side : import_core.SwapSide.SELL
              }));
              fetchURL = pricesUrl + "/" + search;
              _context.next = 4;
              return fetcher({
                url: fetchURL,
                method: "GET",
                requestParams
              });
            case 4:
              data = _context.sent;
              return _context.abrupt("return", data);
            case 6:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return _getQuote.apply(this, arguments);
  }
  return {
    getQuote
  };
};
var ORDER_CANCELLATIONS_EIP_712_TYPES = {
  OrderCancellations: [{
    name: "orderIds",
    type: "string[]"
  }]
};
function buildCancelDeltaOrderSignableData(_ref) {
  var orderInput = _ref.orderInput, chainId = _ref.chainId, paraswapDeltaAddress = _ref.paraswapDeltaAddress;
  var typedData = {
    types: {
      OrderCancellations: ORDER_CANCELLATIONS_EIP_712_TYPES.OrderCancellations
    },
    domain: {
      name: "Portikus",
      version: "2.0.0",
      chainId,
      verifyingContract: paraswapDeltaAddress
    },
    data: {
      // explicityly pick only the necessary fields,
      // otherwise signing will break if more is present
      orderIds: orderInput.orderIds
    }
  };
  return typedData;
}
var constructCancelDeltaOrder = function constructCancelDeltaOrder2(options) {
  var _constructGetDeltaCon = constructGetDeltaContract(options), getDeltaContract = _constructGetDeltaCon.getDeltaContract;
  var signCancelLimitDeltaOrderRequest = function() {
    var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(params, requestParams) {
      var ParaswapDelta, typedData, signature;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return getDeltaContract(requestParams);
            case 2:
              ParaswapDelta = _context.sent;
              if (ParaswapDelta) {
                _context.next = 5;
                break;
              }
              throw new Error("Delta is not available on chain " + options.chainId);
            case 5:
              typedData = buildCancelDeltaOrderSignableData({
                orderInput: params,
                paraswapDeltaAddress: ParaswapDelta,
                chainId: options.chainId
              });
              _context.next = 8;
              return options.contractCaller.signTypedDataCall(typedData);
            case 8:
              signature = _context.sent;
              return _context.abrupt("return", signature);
            case 10:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function signCancelLimitDeltaOrderRequest2(_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }();
  var postCancelLimitDeltaOrderRequest = function() {
    var _ref2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(params, requestParams) {
      var cancelUrl, res;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1)
          switch (_context2.prev = _context2.next) {
            case 0:
              cancelUrl = options.apiURL + "/delta/orders/cancel";
              _context2.next = 3;
              return options.fetcher({
                url: cancelUrl,
                method: "POST",
                data: params,
                requestParams
              });
            case 3:
              res = _context2.sent;
              return _context2.abrupt("return", res);
            case 5:
            case "end":
              return _context2.stop();
          }
      }, _callee2);
    }));
    return function postCancelLimitDeltaOrderRequest2(_x3, _x4) {
      return _ref2.apply(this, arguments);
    };
  }();
  var cancelLimitDeltaOrders = function() {
    var _ref4 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee3(_ref3, requestParams) {
      var orderIds, signature, res;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1)
          switch (_context3.prev = _context3.next) {
            case 0:
              orderIds = _ref3.orderIds;
              _context3.next = 3;
              return signCancelLimitDeltaOrderRequest({
                orderIds
              }, requestParams);
            case 3:
              signature = _context3.sent;
              _context3.next = 6;
              return postCancelLimitDeltaOrderRequest({
                orderIds,
                signature
              }, requestParams);
            case 6:
              res = _context3.sent;
              return _context3.abrupt("return", res);
            case 8:
            case "end":
              return _context3.stop();
          }
      }, _callee3);
    }));
    return function cancelLimitDeltaOrders2(_x5, _x6) {
      return _ref4.apply(this, arguments);
    };
  }();
  return {
    signCancelLimitDeltaOrderRequest,
    postCancelLimitDeltaOrderRequest,
    cancelLimitDeltaOrders
  };
};
var constructPartialSDK = function constructPartialSDK2(config) {
  var _config$apiURL, _config$version;
  for (var _len = arguments.length, funcs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    funcs[_key - 1] = arguments[_key];
  }
  var sdkFuncs = funcs.reduce(function(accum, func) {
    var sdkSlice = func(config);
    return Object.assign(accum, sdkSlice);
  }, {});
  var sdk = _extends({}, sdkFuncs, {
    apiURL: (_config$apiURL = config.apiURL) != null ? _config$apiURL : API_URL,
    version: (_config$version = config.version) != null ? _config$version : DEFAULT_VERSION,
    chainId: config.chainId
  });
  return sdk;
};
var constructSwapSDK = function constructSwapSDK2(config) {
  var constructApproveTokenWithTxResponse = constructApproveToken;
  return constructPartialSDK(config, constructGetBalances, constructGetTokens, constructGetSpender, constructApproveTokenWithTxResponse, constructBuildTx, constructGetAdapters, constructGetRate, constructSwapTx);
};
var constructSubmitLimitOrder = function constructSubmitLimitOrder2(options) {
  var _constructBuildLimitO = constructBuildLimitOrder(options), buildLimitOrder = _constructBuildLimitO.buildLimitOrder;
  var _constructSignLimitOr = constructSignLimitOrder(options), signLimitOrder = _constructSignLimitOr.signLimitOrder;
  var _constructPostLimitOr = constructPostLimitOrder(options), postLimitOrder = _constructPostLimitOr.postLimitOrder, postP2POrder = _constructPostLimitOr.postP2POrder;
  var prepareLimitOrder = function() {
    var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(buildLimitOrderParams, extra) {
      var orderData, signature, orderWithSignature;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return buildLimitOrder(buildLimitOrderParams);
            case 2:
              orderData = _context.sent;
              _context.next = 5;
              return signLimitOrder(orderData);
            case 5:
              signature = _context.sent;
              orderWithSignature = _extends({}, orderData.data, extra, {
                signature
              });
              return _context.abrupt("return", orderWithSignature);
            case 8:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function prepareLimitOrder2(_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }();
  var submitLimitOrder = function() {
    var _ref2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(buildLimitOrderParams, extra, requestParams) {
      var orderWithSignature, newOrder;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1)
          switch (_context2.prev = _context2.next) {
            case 0:
              if (extra === void 0) {
                extra = {};
              }
              _context2.next = 3;
              return prepareLimitOrder(buildLimitOrderParams, extra);
            case 3:
              orderWithSignature = _context2.sent;
              _context2.next = 6;
              return postLimitOrder(orderWithSignature, requestParams);
            case 6:
              newOrder = _context2.sent;
              return _context2.abrupt("return", newOrder);
            case 8:
            case "end":
              return _context2.stop();
          }
      }, _callee2);
    }));
    return function submitLimitOrder2(_x3, _x4, _x5) {
      return _ref2.apply(this, arguments);
    };
  }();
  var submitP2POrder = function() {
    var _ref3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee3(buildLimitOrderParams, extra, requestParams) {
      var orderWithSignature, newOrder;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1)
          switch (_context3.prev = _context3.next) {
            case 0:
              if (extra === void 0) {
                extra = {};
              }
              _context3.next = 3;
              return prepareLimitOrder(buildLimitOrderParams, extra);
            case 3:
              orderWithSignature = _context3.sent;
              _context3.next = 6;
              return postP2POrder(orderWithSignature, requestParams);
            case 6:
              newOrder = _context3.sent;
              return _context3.abrupt("return", newOrder);
            case 8:
            case "end":
              return _context3.stop();
          }
      }, _callee3);
    }));
    return function submitP2POrder2(_x6, _x7, _x8) {
      return _ref3.apply(this, arguments);
    };
  }();
  return {
    submitLimitOrder,
    submitP2POrder
  };
};
var constructAllLimitOrdersHandlers = function constructAllLimitOrdersHandlers2(options) {
  var limitOrdersGetters = constructGetLimitOrders(options);
  var limitOrdersContractGetter = constructGetLimitOrdersContract(options);
  var limitOrdersSubmit = constructSubmitLimitOrder(options);
  var limitOrdersBuild = constructBuildLimitOrder(options);
  var limitOrdersSign = constructSignLimitOrder(options);
  var limitOrdersPost = constructPostLimitOrder(options);
  var limitOrdersCancel = constructCancelLimitOrder(options);
  var limitOrdersApproveToken = constructApproveTokenForLimitOrder(options);
  var limitOrdersFillOrderDirectly = constructFillOrderDirectly(options);
  var limitOrdersBuildTx = constructBuildLimitOrderTx(options);
  return _extends({}, limitOrdersGetters, limitOrdersContractGetter, limitOrdersSubmit, limitOrdersBuild, limitOrdersSign, limitOrdersPost, limitOrdersCancel, limitOrdersApproveToken, limitOrdersFillOrderDirectly, limitOrdersBuildTx);
};
var constructSubmitDeltaOrder = function constructSubmitDeltaOrder2(options) {
  var _constructBuildDeltaO = constructBuildDeltaOrder(options), buildDeltaOrder = _constructBuildDeltaO.buildDeltaOrder;
  var _constructSignDeltaOr = constructSignDeltaOrder(options), signDeltaOrder = _constructSignDeltaOr.signDeltaOrder;
  var _constructPostDeltaOr = constructPostDeltaOrder(options), postDeltaOrder = _constructPostDeltaOr.postDeltaOrder;
  var submitDeltaOrder = function() {
    var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(orderParams) {
      var orderData, signature, response;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return buildDeltaOrder(orderParams);
            case 2:
              orderData = _context.sent;
              _context.next = 5;
              return signDeltaOrder(orderData);
            case 5:
              signature = _context.sent;
              _context.next = 8;
              return postDeltaOrder({
                signature,
                partner: orderParams.partner,
                order: orderData.data,
                partiallyFillable: orderParams.partiallyFillable,
                referrerAddress: orderParams.referrerAddress,
                type: orderParams.type,
                includeAgents: orderParams.includeAgents,
                excludeAgents: orderParams.excludeAgents
              });
            case 8:
              response = _context.sent;
              return _context.abrupt("return", response);
            case 10:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function submitDeltaOrder2(_x) {
      return _ref.apply(this, arguments);
    };
  }();
  return {
    submitDeltaOrder
  };
};
var constructAllDeltaOrdersHandlers = function constructAllDeltaOrdersHandlers2(options) {
  var deltaOrdersGetters = constructGetDeltaOrders(options);
  var deltaOrdersContractGetter = constructGetDeltaContract(options);
  var deltaPrice = constructGetDeltaPrice(options);
  var partnerFee = constructGetPartnerFee(options);
  var bridgeInfo = constructGetBridgeInfo(options);
  var isTokenSupportedInDelta = constructIsTokenSupportedInDelta(options);
  var multicallHandlers = constructGetMulticallHandlers(options);
  var approveTokenForDelta = constructApproveTokenForDelta(options);
  var deltaOrdersSubmit = constructSubmitDeltaOrder(options);
  var buildCrosschainOrderBridge = constructBuildCrosschainOrderBridge(options);
  var deltaOrdersBuild = constructBuildDeltaOrder(options);
  var deltaOrdersSign = constructSignDeltaOrder(options);
  var deltaOrdersPost = constructPostDeltaOrder(options);
  var deltaOrdersCancel = constructCancelDeltaOrder(options);
  return _extends({}, deltaOrdersGetters, deltaOrdersContractGetter, deltaPrice, partnerFee, bridgeInfo, isTokenSupportedInDelta, multicallHandlers, approveTokenForDelta, deltaOrdersSubmit, deltaOrdersBuild, deltaOrdersSign, deltaOrdersPost, deltaOrdersCancel, buildCrosschainOrderBridge);
};
var constructSubmitNFTOrder = function constructSubmitNFTOrder2(options) {
  var _constructBuildNFTOrd = constructBuildNFTOrder(options), buildNFTOrder = _constructBuildNFTOrd.buildNFTOrder;
  var _constructSignNFTOrde = constructSignNFTOrder(options), signNFTOrder = _constructSignNFTOrde.signNFTOrder;
  var _constructPostNFTOrde = constructPostNFTOrder(options), postNFTLimitOrder = _constructPostNFTOrde.postNFTLimitOrder, postNFTP2POrder = _constructPostNFTOrde.postNFTP2POrder;
  var prepareNFTOrder = function() {
    var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(buildNFTOrderParams, extra) {
      var orderData, signature, orderWithSignature;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return buildNFTOrder(buildNFTOrderParams);
            case 2:
              orderData = _context.sent;
              _context.next = 5;
              return signNFTOrder(orderData);
            case 5:
              signature = _context.sent;
              orderWithSignature = _extends({}, orderData.data, extra, {
                signature
              });
              return _context.abrupt("return", orderWithSignature);
            case 8:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function prepareNFTOrder2(_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }();
  var submitNFTOrder = function() {
    var _ref2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(buildNFTOrderParams, extra, requestParams) {
      var orderWithSignature, newOrder;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1)
          switch (_context2.prev = _context2.next) {
            case 0:
              if (extra === void 0) {
                extra = {};
              }
              _context2.next = 3;
              return prepareNFTOrder(buildNFTOrderParams, extra);
            case 3:
              orderWithSignature = _context2.sent;
              _context2.next = 6;
              return postNFTLimitOrder(orderWithSignature, requestParams);
            case 6:
              newOrder = _context2.sent;
              return _context2.abrupt("return", newOrder);
            case 8:
            case "end":
              return _context2.stop();
          }
      }, _callee2);
    }));
    return function submitNFTOrder2(_x3, _x4, _x5) {
      return _ref2.apply(this, arguments);
    };
  }();
  var submitP2POrder = function() {
    var _ref3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee3(buildNFTOrderParams, extra, requestParams) {
      var orderWithSignature, newOrder;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1)
          switch (_context3.prev = _context3.next) {
            case 0:
              if (extra === void 0) {
                extra = {};
              }
              _context3.next = 3;
              return prepareNFTOrder(buildNFTOrderParams, extra);
            case 3:
              orderWithSignature = _context3.sent;
              _context3.next = 6;
              return postNFTP2POrder(orderWithSignature, requestParams);
            case 6:
              newOrder = _context3.sent;
              return _context3.abrupt("return", newOrder);
            case 8:
            case "end":
              return _context3.stop();
          }
      }, _callee3);
    }));
    return function submitP2POrder2(_x6, _x7, _x8) {
      return _ref3.apply(this, arguments);
    };
  }();
  return {
    submitNFTOrder,
    submitP2POrder
  };
};
var constructAllNFTOrdersHandlers = function constructAllNFTOrdersHandlers2(options) {
  var NFTOrdersGetters = constructGetNFTOrders(options);
  var NFTOrdersContractGetter = constructGetNFTOrdersContract(options);
  var NFTOrdersSubmit = constructSubmitNFTOrder(options);
  var NFTOrdersBuild = constructBuildNFTOrder(options);
  var NFTOrdersSign = constructSignNFTOrder(options);
  var NFTOrdersPost = constructPostNFTOrder(options);
  var NFTOrdersCancel = constructCancelNFTOrder(options);
  var NFTOrdersApproveToken = constructApproveTokenForNFTOrder(options);
  var NFTOrdersBuildTx = constructBuildNFTOrderTx(options);
  return _extends({}, NFTOrdersGetters, NFTOrdersContractGetter, NFTOrdersSubmit, NFTOrdersBuild, NFTOrdersSign, NFTOrdersPost, NFTOrdersCancel, NFTOrdersApproveToken, NFTOrdersBuildTx);
};
var constructFullSDK = function constructFullSDK2(config) {
  var _config$apiURL, _config$version;
  var swap = constructSwapSDK(config);
  var limitOrders = constructAllLimitOrdersHandlers(config);
  var nftOrders = constructAllNFTOrdersHandlers(config);
  var delta = constructAllDeltaOrdersHandlers(config);
  var quote = constructGetQuote(config);
  return {
    swap,
    limitOrders,
    nftOrders,
    delta,
    quote,
    apiURL: (_config$apiURL = config.apiURL) != null ? _config$apiURL : API_URL,
    chainId: config.chainId,
    version: (_config$version = config.version) != null ? _config$version : DEFAULT_VERSION
  };
};
var constructFetcher3 = function constructFetcher4(options) {
  if ("axios" in options) {
    return constructFetcher$2(options.axios, options);
  }
  if ("fetch" in options) {
    return constructFetcher$1(options.fetch, options);
  }
  return function(params) {
    var _params$requestParams;
    var headers = options != null && options.apiKey ? _extends({
      "X-API-KEY": options.apiKey
    }, params.headers, (_params$requestParams = params.requestParams) == null ? void 0 : _params$requestParams.headers) : params.headers;
    return options.fetcher(_extends({}, params, {
      headers
    }));
  };
};
function constructSimpleSDK(options, providerOptions) {
  var _options$apiURL2, _options$version2;
  var fetcher = constructFetcher3(options);
  if (!providerOptions) {
    var _options$apiURL, _options$version;
    var _config = {
      apiURL: options.apiURL,
      chainId: options.chainId,
      version: options.version,
      fetcher
    };
    var _swap = constructPartialSDK(_config, constructGetBalances, constructGetTokens, constructGetSpender, constructBuildTx, constructGetAdapters, constructGetRate, constructSwapTx);
    var _limitOrders = constructPartialSDK(_config, constructBuildLimitOrder, constructPostLimitOrder, constructGetLimitOrders, constructGetLimitOrdersContract, constructBuildLimitOrderTx);
    var _nftOrders = constructPartialSDK(_config, constructBuildNFTOrder, constructPostNFTOrder, constructGetNFTOrders, constructGetNFTOrdersContract, constructBuildNFTOrderTx);
    var _delta = constructPartialSDK(_config, constructBuildDeltaOrder, constructBuildCrosschainOrderBridge, constructPostDeltaOrder, constructGetDeltaOrders, constructGetDeltaPrice, constructGetDeltaContract, constructGetPartnerFee, constructGetMulticallHandlers, constructGetBridgeInfo, constructIsTokenSupportedInDelta);
    var _quote = constructPartialSDK(_config, constructGetQuote);
    return {
      swap: _swap,
      limitOrders: _limitOrders,
      nftOrders: _nftOrders,
      delta: _delta,
      quote: _quote,
      apiURL: (_options$apiURL = options.apiURL) != null ? _options$apiURL : API_URL,
      chainId: options.chainId,
      version: (_options$version = options.version) != null ? _options$version : DEFAULT_VERSION
    };
  }
  var contractCaller = constructSimpleContractCaller(providerOptions);
  var config = {
    apiURL: options.apiURL,
    version: options.version,
    chainId: options.chainId,
    fetcher,
    contractCaller
  };
  var swap = constructSwapSDK(config);
  var limitOrders = constructAllLimitOrdersHandlers(config);
  var nftOrders = constructAllNFTOrdersHandlers(config);
  var delta = constructAllDeltaOrdersHandlers(config);
  var quote = constructGetQuote(config);
  return {
    swap,
    limitOrders,
    nftOrders,
    delta,
    quote,
    apiURL: (_options$apiURL2 = options.apiURL) != null ? _options$apiURL2 : API_URL,
    chainId: options.chainId,
    version: (_options$version2 = options.version) != null ? _options$version2 : DEFAULT_VERSION
  };
}
function constructSimpleContractCaller(providerOptions) {
  if ("ethersProviderOrSigner" in providerOptions) {
    var _constructEthersV5Con = constructEthersV5ContractCaller(providerOptions, providerOptions.account), _staticCall = _constructEthersV5Con.staticCall, _transactCall2 = _constructEthersV5Con.transactCall, _signTypedDataCall = _constructEthersV5Con.signTypedDataCall;
    var _transactCall3 = function() {
      var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(params) {
        var contractTx;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1)
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _transactCall2(params);
              case 2:
                contractTx = _context.sent;
                return _context.abrupt("return", contractTx.hash);
              case 4:
              case "end":
                return _context.stop();
            }
        }, _callee);
      }));
      return function _transactCall32(_x) {
        return _ref.apply(this, arguments);
      };
    }();
    return {
      staticCall: _staticCall,
      transactCall: _transactCall3,
      signTypedDataCall: _signTypedDataCall
    };
  }
  if ("ethersV6ProviderOrSigner" in providerOptions) {
    var _constructEthersV6Con = constructContractCaller$2(providerOptions, providerOptions.account), _staticCall2 = _constructEthersV6Con.staticCall, _transactCall4 = _constructEthersV6Con.transactCall, _signTypedDataCall2 = _constructEthersV6Con.signTypedDataCall;
    var _transactCall5 = function() {
      var _ref2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(params) {
        var contractTx;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1)
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return _transactCall4(params);
              case 2:
                contractTx = _context2.sent;
                return _context2.abrupt("return", contractTx.hash);
              case 4:
              case "end":
                return _context2.stop();
            }
        }, _callee2);
      }));
      return function _transactCall52(_x2) {
        return _ref2.apply(this, arguments);
      };
    }();
    return {
      staticCall: _staticCall2,
      transactCall: _transactCall5,
      signTypedDataCall: _signTypedDataCall2
    };
  }
  if ("viemClient" in providerOptions) {
    var contractCaller = constructContractCaller3(providerOptions.viemClient, providerOptions.account);
    return contractCaller;
  }
  var _constructWeb3Contrac = constructContractCaller$1(providerOptions.web3, providerOptions.account), staticCall = _constructWeb3Contrac.staticCall, _transactCall = _constructWeb3Contrac.transactCall, signTypedDataCall = _constructWeb3Contrac.signTypedDataCall;
  var transactCall = function() {
    var _ref3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee3(params) {
      var unpromiEvent;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1)
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return _transactCall(params);
            case 2:
              unpromiEvent = _context3.sent;
              return _context3.abrupt("return", new Promise(function(resolve, reject) {
                unpromiEvent.once("transactionHash", function(hash) {
                  return resolve(hash);
                });
                unpromiEvent.once("error", reject);
              }));
            case 4:
            case "end":
              return _context3.stop();
          }
      }, _callee3);
    }));
    return function transactCall2(_x3) {
      return _ref3.apply(this, arguments);
    };
  }();
  return {
    staticCall,
    transactCall,
    signTypedDataCall
  };
}
var export_ContractMethod = import_core2.ContractMethod;
var export_ContractMethodV5 = import_core2.ContractMethodV5;
var export_ContractMethodV6 = import_core2.ContractMethodV6;
var export_SwapSide = import_core2.SwapSide;
export {
  API_URL,
  AssetType,
  export_ContractMethod as ContractMethod,
  export_ContractMethodV5 as ContractMethodV5,
  export_ContractMethodV6 as ContractMethodV6,
  DEFAULT_VERSION,
  export_SwapSide as SwapSide,
  constructAllDeltaOrdersHandlers,
  constructAllLimitOrdersHandlers,
  constructAllNFTOrdersHandlers,
  constructApproveToken,
  constructApproveTokenForDelta,
  constructApproveTokenForLimitOrder,
  constructApproveTokenForNFTOrder,
  constructFetcher$2 as constructAxiosFetcher,
  constructBuildCrosschainOrderBridge,
  constructBuildDeltaOrder,
  constructBuildLimitOrder,
  constructBuildLimitOrderTx,
  constructBuildNFTOrder,
  constructBuildNFTOrderTx,
  constructBuildTx,
  constructCancelDeltaOrder,
  constructCancelLimitOrder,
  constructCancelNFTOrder,
  constructEthersV5ContractCaller as constructEthersContractCaller,
  constructEthersV5ContractCaller,
  constructContractCaller$2 as constructEthersV6ContractCaller,
  constructFetcher$1 as constructFetchFetcher,
  constructFillOrderDirectly,
  constructFullSDK,
  constructGetAdapters,
  constructGetBalances,
  constructGetBridgeInfo,
  constructGetDeltaContract,
  constructGetDeltaOrders,
  constructGetDeltaPrice,
  constructGetLimitOrders,
  constructGetLimitOrdersContract,
  constructGetMulticallHandlers,
  constructGetNFTOrders,
  constructGetNFTOrdersContract,
  constructGetPartnerFee,
  constructGetQuote,
  constructGetRate,
  constructGetSpender,
  constructGetTokens,
  constructIsTokenSupportedInDelta,
  constructPartialSDK,
  constructPostDeltaOrder,
  constructPostLimitOrder,
  constructPostNFTOrder,
  constructSignDeltaOrder,
  constructSignLimitOrder,
  constructSignNFTOrder,
  constructSimpleSDK,
  constructSubmitDeltaOrder,
  constructSubmitLimitOrder,
  constructSubmitNFTOrder,
  constructSwapSDK,
  constructSwapTx,
  constructToken,
  constructContractCaller3 as constructViemContractCaller,
  constructContractCaller$1 as constructWeb3ContractCaller,
  isAllowance,
  isFetcherError,
  txParamsToViemTxParams
};
//# sourceMappingURL=@velora-dex_sdk.js.map
